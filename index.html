<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Team Dominos - Digital Transformation Journey</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Courier New', monospace;
            background: #000;
            color: #fff;
            overflow: hidden;
        }
        
        #gameCanvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
        
        #ui {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            padding: 20px;
            pointer-events: none;
            z-index: 100;
        }
        
        #stats {
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border: 2px solid #0ff;
            border-radius: 5px;
            display: inline-block;
            pointer-events: auto;
        }
        
        #levelInfo {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border: 2px solid #ff0;
            border-radius: 5px;
            pointer-events: auto;
        }
        
        #controls {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border: 2px solid #0f0;
            border-radius: 5px;
            pointer-events: auto;
            max-width: 300px;
        }
        
        .stat-bar {
            height: 20px;
            background: #222;
            border: 1px solid #fff;
            margin: 5px 0;
            position: relative;
            overflow: hidden;
        }
        
        .stat-fill {
            height: 100%;
            background: linear-gradient(90deg, #0ff, #00f);
            transition: width 0.3s;
        }
        
        .stat-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 12px;
            font-weight: bold;
            text-shadow: 1px 1px 2px #000;
        }
        
        button {
            background: #0ff;
            color: #000;
            border: none;
            padding: 10px 20px;
            margin: 5px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            border-radius: 3px;
            pointer-events: auto;
        }
        
        button:hover {
            background: #0dd;
            transform: scale(1.05);
        }
        
        button:disabled {
            background: #444;
            color: #666;
            cursor: not-allowed;
        }
        
        #cutscene {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #fff;
            z-index: 1000;
            display: none;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            animation: fadeIn 1s;
        }
        
        #cutscene.glitch {
            animation: glitchEffect 0.5s;
            background: #000;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        @keyframes glitchEffect {
            0%, 100% { transform: translate(0); }
            20% { transform: translate(-5px, 5px); }
            40% { transform: translate(-5px, -5px); }
            60% { transform: translate(5px, 5px); }
            80% { transform: translate(5px, -5px); }
        }
        
        .cutscene-text {
            font-size: 48px;
            font-weight: bold;
            margin: 20px;
            text-align: center;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        @keyframes flash {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }
        
        #menu {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            padding: 40px;
            border: 3px solid #0ff;
            border-radius: 10px;
            z-index: 500;
            display: none;
            text-align: center;
        }
        
        #menu h1 {
            color: #0ff;
            margin-bottom: 20px;
            font-size: 36px;
        }
        
        #menu p {
            margin: 10px 0;
            font-size: 14px;
        }
        
        .glow {
            text-shadow: 0 0 10px currentColor;
        }
        
        #workers {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border: 2px solid #f0f;
            border-radius: 5px;
            max-width: 300px;
            max-height: 300px;
            overflow-y: auto;
            pointer-events: auto;
        }
        
        .worker-item {
            background: rgba(255, 0, 255, 0.2);
            padding: 8px;
            margin: 5px 0;
            border-radius: 3px;
            font-size: 12px;
        }
        
        #buildings {
            position: fixed;
            top: 50%;
            right: 20px;
            transform: translateY(-50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border: 2px solid #fa0;
            border-radius: 5px;
            max-width: 250px;
            pointer-events: auto;
        }
        
        .building-btn {
            width: 100%;
            margin: 3px 0;
            background: #fa0;
            font-size: 11px;
            padding: 8px;
        }
        
        .building-btn:hover {
            background: #fc0;
        }
        
        .building-btn.selected {
            background: #f00;
            box-shadow: 0 0 10px #f00;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
    <div id="ui">
        <div id="stats">
            <div><strong class="glow">Level <span id="currentLevel">1</span></strong> - Phase <span id="currentPhase">1</span></div>
            <div>OKRs: <span id="okrCount">0</span> / <span id="okrGoal">3</span></div>
            <div class="stat-bar">
                <div class="stat-fill" id="okrProgress"></div>
                <div class="stat-text"><span id="okrPercent">0</span>%</div>
            </div>
            <div style="margin-top: 10px;">
                <span id="currencyDisplay">DP: <span id="dpAmount">0</span></span>
            </div>
            <div style="margin-top: 5px; font-size: 12px;">
                Total OKRs: <span id="totalOKRs">0</span>
            </div>
        </div>
    </div>
    
    <div id="levelInfo">
        <div><strong>Objective:</strong></div>
        <div id="objective">Collect all OKRs and reach Jrod HQ!</div>
        <div style="margin-top: 10px; font-size: 12px;" id="phaseDesc">
            <strong>Phase 1:</strong> Manual Collection
        </div>
    </div>
    
    <div id="controls">
        <div><strong>Controls:</strong></div>
        <div style="font-size: 12px; margin-top: 5px;">
            <div id="controlsText">
                WASD - Move<br>
                SPACE - Jump<br>
                SHIFT - Sprint (unlocked L3)
            </div>
        </div>
        <div style="margin-top: 10px;">
            <button id="saveBtn" onclick="game.saveGame()">Save</button>
            <button id="nextBtn" onclick="game.skipToNextLevel()" style="font-size: 10px;">Skip Level</button>
            <button id="muteBtn" onclick="game.toggleMusic()" style="font-size: 10px;">ðŸ”Š Music</button>
        </div>
    </div>
    
    <div id="workers" style="display: none;">
        <div><strong>AI Workers:</strong></div>
        <div id="workerList"></div>
        <button onclick="game.hireWorker()" id="hireBtn">Hire Worker (Cost: <span id="hireCost">50</span> MP)</button>
    </div>
    
    <div id="buildings" style="display: none;">
        <div><strong>Automation:</strong></div>
        <div id="buildingList"></div>
    </div>
    
    <div id="menu">
        <h1>TEAM DOMINOS</h1>
        <p>A Digital Transformation Journey</p>
        <p style="margin-top: 20px;">Evolve through 3 phases of productivity:</p>
        <p>ðŸŽ® Levels 1-5: Manual Platforming</p>
        <p>ðŸ¤– Levels 6-10: AI Management</p>
        <p>âš¡ Levels 11-15: Full Automation</p>
        <button onclick="game.startGame()" style="margin-top: 20px;">NEW GAME</button>
        <button onclick="game.loadGame()">CONTINUE</button>
        <button onclick="game.clearSave()" style="font-size: 12px; background: #600; margin-top: 10px;">CLEAR SAVE DATA</button>
    </div>
    
    <div id="cutscene">
        <div class="cutscene-text" id="cutsceneText"></div>
    </div>

    <script type="module">
        import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js';
        
        class TeamDominosGame {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
                
                this.state = {
                    currentLevel: 1,
                    phase: 1,
                    renderMode: '3D',
                    currencies: { dp: 0, mp: 0, ac: 0 },
                    totalOKRs: 0,
                    playerStats: {
                        speed: 15,
                        jump: 18,
                        capacity: 1,
                        sprint: 0,
                        autoCollect: 0
                    },
                    aiWorkers: [],
                    buildings: [],
                    completedLevels: [],
                    okrsCollected: 0
                };
                
                this.keys = {};
                this.gameStarted = false;
                this.paused = false;
                
                this.levelConfigs = this.initLevelConfigs();
                this.currentLevelData = null;
                
                // Three.js objects
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.player = null;
                this.playerVelocity = { x: 0, y: 0, z: 0 };
                this.isGrounded = false;
                this.canDoubleJump = false;
                this.hasDoubleJumped = false;
                
                // 2D Canvas context
                this.ctx = null;
                
                // Camera offset for 3D
                this.cameraOffset = { x: 0, y: 5, z: 10 };
                
                // Game objects
                this.okrs = [];
                this.platforms = [];
                this.jrodHQ = null;
                
                // Time
                this.lastTime = performance.now();
                this.deltaTime = 0;
                this.gameTime = 0;
                
                // AI Workers
                this.workerIdCounter = 0;
                this.hireCost = 50;
                
                // Buildings
                this.buildingIdCounter = 0;
                this.automationNodes = [];
                this.selectedBuilding = null;
                
                // Spectators
                this.currentLevelSpectators = [];
                this.initSpectatorConfigs();
                
                // Music system
                this.audioCtx = null;
                this.musicPlaying = false;
                this.musicNodes = [];
                this.initMusicConfigs();
                
                this.setupEventListeners();
                this.showMenu();
            }
            
            initLevelConfigs() {
                return {
                    1: { okrGoal: 3, reward: 10, currency: 'dp', description: 'Tutorial - Learn the basics', boss: false },
                    2: { okrGoal: 5, reward: 15, currency: 'dp', description: 'Navigate gaps', boss: false },
                    3: { okrGoal: 7, reward: 20, currency: 'dp', description: 'Avoid obstacles', boss: false, unlock: 'sprint' },
                    4: { okrGoal: 10, reward: 30, currency: 'dp', description: 'Vertical challenge', boss: false, unlock: 'doubleJump' },
                    5: { okrGoal: 15, reward: 50, currency: 'dp', description: 'BOSS: The Bureaucrat', boss: true, evolution: 1 },
                    6: { okrGoal: 10, reward: 30, currency: 'mp', description: 'First AI hire', boss: false },
                    7: { okrGoal: 15, reward: 50, currency: 'mp', description: 'Manage 3 workers', boss: false },
                    8: { okrGoal: 20, reward: 75, currency: 'mp', description: 'Timed challenge', boss: false },
                    9: { okrGoal: 30, reward: 100, currency: 'mp', description: 'Optimization puzzle', boss: false },
                    10: { okrGoal: 50, reward: 150, currency: 'mp', description: 'BOSS: Scope Creep', boss: true, evolution: 2 },
                    11: { okrGoal: 100, reward: 100, currency: 'ac', description: 'First conveyor', boss: false },
                    12: { okrGoal: 500, reward: 200, currency: 'ac', description: 'Network topology', boss: false },
                    13: { okrGoal: 10000, reward: 500, currency: 'ac', description: 'Exponential growth', boss: false },
                    14: { okrGoal: 100000, reward: 1000, currency: 'ac', description: 'Singularity', boss: false },
                    15: { okrGoal: 1000000, reward: 0, currency: 'ac', description: 'FINAL: Digital Transformation', boss: true, final: true }
                };
            }
            
            initSpectatorConfigs() {
                this.levelSpectators = {
                    1: [{ name: 'Bea', color: '#4a90e2', quote: 'Welcome!' }],
                    2: [{ name: 'Francisco', color: '#e74c3c' }, { name: 'Mason', color: '#27ae60' }],
                    3: [{ name: 'Ramon', color: '#3498db', quote: 'Speed is key!' }],
                    4: [{ name: 'Erik', color: '#9b59b6', quote: 'Go vertical!' }],
                    5: [{ name: 'Murali', color: '#e67e22' }, { name: 'Stephane', color: '#1abc9c' }],
                    6: [{ name: 'Avital', color: '#f39c12', quote: "I'll help!" }],
                    7: [{ name: 'Parker', color: '#2ecc71' }, { name: 'Zaki', color: '#16a085' }],
                    8: [{ name: 'Jeff', color: '#8e44ad' }, { name: 'Lauren B.', color: '#c0392b' }],
                    9: [{ name: 'Patrick', color: '#d35400' }, { name: 'Katy', color: '#2980b9' }],
                    10: [{ name: 'Jason', color: '#27ae60' }, { name: 'Ada', color: '#e91e63' }],
                    11: [{ name: 'Josh', color: '#00bcd4', quote: 'Build it!' }],
                    12: [{ name: 'James', color: '#9c27b0', quote: 'Connect!' }],
                    13: [{ name: 'Yanan', color: '#ff9800' }, { name: 'Lauren G.', color: '#4caf50' }],
                    14: [{ name: 'ALL 20', color: '#00ffff', quote: 'Almost there!' }],
                    15: [{ name: 'Jrod', color: '#ffd700', quote: 'Choose wisely...' }]
                };
            }
            
            initMusicConfigs() {
                // Each level: scale (MIDI notes), tempo (BPM), waveform, bassLine, feel
                this.musicConfigs = {
                    1:  { scale: [60,62,64,67,69], tempo: 120, wave: 'triangle', bass: [48,48,52,55], mood: 'bright' },
                    2:  { scale: [62,64,66,69,71], tempo: 130, wave: 'triangle', bass: [50,50,54,57], mood: 'adventurous' },
                    3:  { scale: [64,66,68,71,73], tempo: 140, wave: 'square',   bass: [52,52,55,59], mood: 'energetic' },
                    4:  { scale: [65,67,69,72,74], tempo: 145, wave: 'square',   bass: [53,53,57,60], mood: 'climbing' },
                    5:  { scale: [60,63,65,67,70], tempo: 155, wave: 'sawtooth', bass: [48,51,48,55], mood: 'boss' },
                    6:  { scale: [67,69,71,74,76], tempo: 110, wave: 'sine',     bass: [55,55,59,62], mood: 'chill' },
                    7:  { scale: [69,71,72,74,76], tempo: 115, wave: 'sine',     bass: [57,57,60,64], mood: 'groovy' },
                    8:  { scale: [64,67,69,71,74], tempo: 125, wave: 'triangle', bass: [52,55,52,59], mood: 'focused' },
                    9:  { scale: [62,65,67,69,72], tempo: 135, wave: 'triangle', bass: [50,53,50,57], mood: 'puzzle' },
                    10: { scale: [60,63,66,67,70], tempo: 150, wave: 'sawtooth', bass: [48,51,54,48], mood: 'boss' },
                    11: { scale: [72,74,76,79,81], tempo: 90,  wave: 'square',   bass: [48,48,52,55], mood: 'retro' },
                    12: { scale: [74,76,78,81,83], tempo: 95,  wave: 'square',   bass: [50,50,53,57], mood: 'retro' },
                    13: { scale: [67,69,71,74,76], tempo: 100, wave: 'square',   bass: [55,55,59,62], mood: 'building' },
                    14: { scale: [60,64,67,69,72], tempo: 105, wave: 'square',   bass: [48,52,55,48], mood: 'epic' },
                    15: { scale: [60,63,65,67,70,72,74,75], tempo: 160, wave: 'sawtooth', bass: [48,51,55,48], mood: 'final' }
                };
            }
            
            startMusic(levelNum) {
                this.stopMusic();
                if (this.musicMuted) return;
                
                // Create AudioContext on first user interaction
                if (!this.audioCtx) {
                    try {
                        this.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                    } catch(e) { return; }
                }
                if (this.audioCtx.state === 'suspended') this.audioCtx.resume();
                
                const config = this.musicConfigs[levelNum];
                if (!config) return;
                
                const ctx = this.audioCtx;
                const bps = config.tempo / 60;
                const beatLen = 1 / bps;
                
                // Master gain
                const master = ctx.createGain();
                master.gain.value = 0.15;
                master.connect(ctx.destination);
                this.musicNodes.push(master);
                
                // Create a looping melody + bass pattern
                const melodyLen = 16; // 16 beats per loop
                const loopDuration = melodyLen * beatLen;
                
                // Generate a deterministic melody pattern from level number
                const rng = (seed) => { seed = (seed * 16807 + 0) % 2147483647; return seed; };
                let seed = levelNum * 12345;
                const melodyPattern = [];
                for (let i = 0; i < melodyLen; i++) {
                    seed = rng(seed);
                    const noteIdx = seed % config.scale.length;
                    const rest = (seed >> 8) % 4 === 0; // ~25% rests
                    melodyPattern.push(rest ? -1 : config.scale[noteIdx]);
                }
                
                // Schedule loop function
                const scheduleLoop = (startTime) => {
                    if (!this.musicPlaying) return;
                    
                    // Melody
                    melodyPattern.forEach((note, i) => {
                        if (note < 0) return;
                        const t = startTime + i * beatLen;
                        if (t < ctx.currentTime - 0.1) return;
                        
                        const osc = ctx.createOscillator();
                        const gain = ctx.createGain();
                        osc.type = config.wave;
                        osc.frequency.value = 440 * Math.pow(2, (note - 69) / 12);
                        
                        // ADSR envelope
                        const noteLen = beatLen * 0.8;
                        gain.gain.setValueAtTime(0, t);
                        gain.gain.linearRampToValueAtTime(0.3, t + 0.02);
                        gain.gain.exponentialRampToValueAtTime(0.15, t + noteLen * 0.3);
                        gain.gain.exponentialRampToValueAtTime(0.001, t + noteLen);
                        
                        osc.connect(gain);
                        gain.connect(master);
                        osc.start(t);
                        osc.stop(t + noteLen);
                        this.musicNodes.push(osc, gain);
                    });
                    
                    // Bass line (4 notes per loop, each 4 beats)
                    config.bass.forEach((note, i) => {
                        const t = startTime + i * 4 * beatLen;
                        if (t < ctx.currentTime - 0.1) return;
                        
                        const osc = ctx.createOscillator();
                        const gain = ctx.createGain();
                        osc.type = 'sine';
                        osc.frequency.value = 440 * Math.pow(2, (note - 69) / 12);
                        
                        const dur = 4 * beatLen * 0.9;
                        gain.gain.setValueAtTime(0, t);
                        gain.gain.linearRampToValueAtTime(0.25, t + 0.05);
                        gain.gain.setValueAtTime(0.2, t + dur * 0.7);
                        gain.gain.exponentialRampToValueAtTime(0.001, t + dur);
                        
                        osc.connect(gain);
                        gain.connect(master);
                        osc.start(t);
                        osc.stop(t + dur);
                        this.musicNodes.push(osc, gain);
                    });
                    
                    // Hi-hat / percussion (for energetic levels)
                    if (config.tempo >= 120) {
                        for (let i = 0; i < melodyLen; i++) {
                            const t = startTime + i * beatLen;
                            if (t < ctx.currentTime - 0.1) return;
                            
                            // Noise burst for hi-hat
                            const bufSize = ctx.sampleRate * 0.05;
                            const buf = ctx.createBuffer(1, bufSize, ctx.sampleRate);
                            const data = buf.getChannelData(0);
                            for (let j = 0; j < bufSize; j++) data[j] = (Math.random() * 2 - 1) * 0.3;
                            
                            const noise = ctx.createBufferSource();
                            noise.buffer = buf;
                            const hiGain = ctx.createGain();
                            const accent = i % 4 === 0 ? 0.12 : (i % 2 === 0 ? 0.06 : 0.03);
                            hiGain.gain.setValueAtTime(accent, t);
                            hiGain.gain.exponentialRampToValueAtTime(0.001, t + 0.05);
                            
                            // Bandpass for metallic sound
                            const filter = ctx.createBiquadFilter();
                            filter.type = 'highpass';
                            filter.frequency.value = 8000;
                            
                            noise.connect(filter);
                            filter.connect(hiGain);
                            hiGain.connect(master);
                            noise.start(t);
                            noise.stop(t + 0.06);
                            this.musicNodes.push(noise, hiGain, filter);
                        }
                    }
                    
                    // Schedule next loop
                    const nextStart = startTime + loopDuration;
                    const scheduleAhead = loopDuration * 0.8;
                    this._musicTimer = setTimeout(() => scheduleLoop(nextStart), scheduleAhead * 1000);
                };
                
                this.musicPlaying = true;
                scheduleLoop(ctx.currentTime + 0.1);
            }
            
            stopMusic() {
                this.musicPlaying = false;
                if (this._musicTimer) {
                    clearTimeout(this._musicTimer);
                    this._musicTimer = null;
                }
                this.musicNodes.forEach(node => {
                    try { node.disconnect(); } catch(e) {}
                    try { if (node.stop) node.stop(); } catch(e) {}
                });
                this.musicNodes = [];
            }
            
            toggleMusic() {
                this.musicMuted = !this.musicMuted;
                const btn = document.getElementById('muteBtn');
                if (this.musicMuted) {
                    this.stopMusic();
                    btn.textContent = 'ðŸ”‡ Music';
                } else {
                    btn.textContent = 'ðŸ”Š Music';
                    if (this.state.currentLevel) this.startMusic(this.state.currentLevel);
                }
            }
            
            setupEventListeners() {
                window.addEventListener('keydown', (e) => {
                    this.keys[e.code] = true;
                    if (e.code === 'Space' && this.state.phase === 1) {
                        e.preventDefault();
                    }
                });
                
                window.addEventListener('keyup', (e) => {
                    this.keys[e.code] = false;
                });
                
                window.addEventListener('resize', () => {
                    this.canvas.width = window.innerWidth;
                    this.canvas.height = window.innerHeight;
                    if (this.state.renderMode === '3D' && this.camera) {
                        this.camera.aspect = window.innerWidth / window.innerHeight;
                        this.camera.updateProjectionMatrix();
                        this.renderer.setSize(window.innerWidth, window.innerHeight);
                    }
                });
                
                this.canvas.addEventListener('click', (e) => {
                    if (this.state.phase === 3) {
                        this.handleCanvasClick(e);
                    }
                });
            }
            
            showMenu() {
                document.getElementById('menu').style.display = 'block';
            }
            
            startGame() {
                document.getElementById('menu').style.display = 'none';
                this.gameStarted = true;
                this.setupPhase1();
                this.loadLevel(1);
                this.gameLoop();
            }
            
            setupPhase1() {
                console.log('Setting up Phase 1 - 3D mode');
                // Initialize Three.js
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x87ceeb);
                this.scene.fog = new THREE.Fog(0x87ceeb, 50, 200);
                console.log('Scene created');
                
                this.camera = new THREE.PerspectiveCamera(
                    60,
                    window.innerWidth / window.innerHeight,
                    0.1,
                    1000
                );
                this.camera.position.set(0, 5, 10);
                this.camera.lookAt(0, 0, 0);
                
                this.renderer = new THREE.WebGLRenderer({ canvas: this.canvas, antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                
                // Lighting
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                this.scene.add(ambientLight);
                
                const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
                dirLight.position.set(10, 20, 10);
                dirLight.castShadow = true;
                dirLight.shadow.camera.left = -50;
                dirLight.shadow.camera.right = 50;
                dirLight.shadow.camera.top = 50;
                dirLight.shadow.camera.bottom = -50;
                dirLight.shadow.mapSize.width = 2048;
                dirLight.shadow.mapSize.height = 2048;
                this.scene.add(dirLight);
                
                // Hemisphere light (sky/ground color blend)
                const hemiLight = new THREE.HemisphereLight(0x87ceeb, 0x228b22, 0.4);
                this.scene.add(hemiLight);
                
                // Car headlight (moves with player)
                this.playerLight = new THREE.SpotLight(0xffffcc, 1.5, 30, Math.PI / 6, 0.3);
                this.playerLight.position.set(0, 1, 2);
                this.playerLight.castShadow = true;
                
                // Warm rim light from behind
                this.rimLight = new THREE.PointLight(0xff8844, 0.6, 15);
                this.rimLight.position.set(0, 3, -5);
                
                // Create player - character in a small car
                const playerGroup = new THREE.Group();
                const carBodyMat = new THREE.MeshPhongMaterial({ color: 0x2266cc });
                const metalMat = new THREE.MeshPhongMaterial({ color: 0x888888 });
                const glassMat = new THREE.MeshPhongMaterial({ color: 0x88ccff, transparent: true, opacity: 0.6 });
                const tireMat = new THREE.MeshPhongMaterial({ color: 0x222222 });
                const skinMat = new THREE.MeshPhongMaterial({ color: 0xffcc99 });
                const hairMat = new THREE.MeshPhongMaterial({ color: 0x442200 });
                
                // Car body (lower)
                const chassis = new THREE.Mesh(new THREE.BoxGeometry(1.4, 0.4, 2.2), carBodyMat);
                chassis.position.set(0, 0.35, 0);
                playerGroup.add(chassis);
                
                // Car cabin (upper)
                const cabin = new THREE.Mesh(new THREE.BoxGeometry(1.2, 0.5, 1.2), carBodyMat);
                cabin.position.set(0, 0.75, -0.1);
                playerGroup.add(cabin);
                
                // Windshield
                const windshield = new THREE.Mesh(new THREE.BoxGeometry(1.1, 0.45, 0.05), glassMat);
                windshield.position.set(0, 0.78, 0.52);
                windshield.rotation.x = -0.2;
                playerGroup.add(windshield);
                
                // Rear window
                const rearWindow = new THREE.Mesh(new THREE.BoxGeometry(1.1, 0.4, 0.05), glassMat);
                rearWindow.position.set(0, 0.78, -0.72);
                rearWindow.rotation.x = 0.2;
                playerGroup.add(rearWindow);
                
                // Wheels
                const wheelGeo = new THREE.CylinderGeometry(0.2, 0.2, 0.15, 12);
                const hubGeo = new THREE.CylinderGeometry(0.08, 0.08, 0.16, 8);
                const hubMat = new THREE.MeshPhongMaterial({ color: 0xcccccc });
                
                const wheelPositions = [
                    [-0.7, 0.2, 0.65], [0.7, 0.2, 0.65],
                    [-0.7, 0.2, -0.65], [0.7, 0.2, -0.65]
                ];
                wheelPositions.forEach(pos => {
                    const wheel = new THREE.Mesh(wheelGeo, tireMat);
                    wheel.rotation.z = Math.PI / 2;
                    wheel.position.set(pos[0], pos[1], pos[2]);
                    playerGroup.add(wheel);
                    const hub = new THREE.Mesh(hubGeo, hubMat);
                    hub.rotation.z = Math.PI / 2;
                    hub.position.set(pos[0], pos[1], pos[2]);
                    playerGroup.add(hub);
                });
                
                // Headlights
                const headlightMat = new THREE.MeshPhongMaterial({ color: 0xffffaa, emissive: 0xffffaa, emissiveIntensity: 0.8 });
                const hlGeo = new THREE.SphereGeometry(0.1, 8, 8);
                const hl1 = new THREE.Mesh(hlGeo, headlightMat);
                hl1.position.set(-0.45, 0.4, 1.1);
                playerGroup.add(hl1);
                const hl2 = new THREE.Mesh(hlGeo, headlightMat);
                hl2.position.set(0.45, 0.4, 1.1);
                playerGroup.add(hl2);
                
                // Bumper
                const bumper = new THREE.Mesh(new THREE.BoxGeometry(1.3, 0.12, 0.1), metalMat);
                bumper.position.set(0, 0.2, 1.12);
                playerGroup.add(bumper);
                
                // Driver head (visible above cabin)
                const head = new THREE.Mesh(new THREE.SphereGeometry(0.2, 10, 10), skinMat);
                head.position.set(0, 1.15, 0);
                playerGroup.add(head);
                
                // Driver hair
                const hair = new THREE.Mesh(new THREE.SphereGeometry(0.21, 10, 10, 0, Math.PI * 2, 0, Math.PI / 2), hairMat);
                hair.position.set(0, 1.2, 0);
                playerGroup.add(hair);
                
                // Eyes
                const eyeMat = new THREE.MeshPhongMaterial({ color: 0x000000 });
                const le = new THREE.Mesh(new THREE.SphereGeometry(0.04, 6, 6), eyeMat);
                le.position.set(-0.08, 1.17, 0.18);
                playerGroup.add(le);
                const re = new THREE.Mesh(new THREE.SphereGeometry(0.04, 6, 6), eyeMat);
                re.position.set(0.08, 1.17, 0.18);
                playerGroup.add(re);
                
                playerGroup.traverse(child => { child.castShadow = true; });
                playerGroup.position.set(0, 2, 0);
                this.player = playerGroup;
                this.scene.add(this.player);
                
                // Attach lights to scene (follow player in update loop)
                this.scene.add(this.playerLight);
                this.scene.add(this.playerLight.target);
                this.scene.add(this.rimLight);
                
                console.log('Three.js setup complete', {
                    scene: this.scene,
                    camera: this.camera,
                    renderer: this.renderer,
                    player: this.player
                });
            }
            
            disposeThreeJS() {
                if (this.renderer) {
                    this.renderer.dispose();
                }
                if (this.scene) {
                    this.scene.traverse((obj) => {
                        if (obj.geometry) obj.geometry.dispose();
                        if (obj.material) {
                            if (Array.isArray(obj.material)) {
                                obj.material.forEach(m => m.dispose());
                            } else {
                                obj.material.dispose();
                            }
                        }
                    });
                }
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.player = null;
            }
            
            setupPhase2() {
                this.disposeThreeJS();
                
                // Create a fresh 2D canvas (WebGL canvas can't switch to 2D)
                const oldCanvas = this.canvas;
                const newCanvas = document.createElement('canvas');
                newCanvas.id = 'gameCanvas';
                newCanvas.width = window.innerWidth;
                newCanvas.height = window.innerHeight;
                newCanvas.style.cssText = oldCanvas.style.cssText;
                oldCanvas.parentNode.replaceChild(newCanvas, oldCanvas);
                this.canvas = newCanvas;
                
                this.ctx = this.canvas.getContext('2d');
                this.state.renderMode = '2d-platformer';
                
                // Re-attach click handler
                this.canvas.addEventListener('click', (e) => {
                    if (this.state.phase === 3) this.handleCanvasClick(e);
                });
                
                // 2D platformer player: x, y position, velocity, facing direction
                this.player = { x: 100, y: 0, vx: 0, vy: 0, facingRight: true, grounded: false };
                this.p2Gravity = 900;
                this.p2JumpForce = -450;
                this.p2Speed = 250;
                
                // Start with 1 AI worker
                if (this.state.aiWorkers.length === 0) {
                    this.state.aiWorkers.push({
                        id: this.workerIdCounter++,
                        x: 200, y: 0,
                        targetOKR: null
                    });
                }
                
                // Camera
                this.p2CamX = 0;
                
                // Update UI
                document.getElementById('controlsText').innerHTML = 
                    'A/D - Move<br>SPACE - Jump<br>Collect OKR coins!';
                document.getElementById('workers').style.display = 'block';
                this.updateWorkerUI();
            }
            
            setupPhase3() {
                // If coming from Phase 2, canvas already supports 2D
                // If somehow context is lost, create fresh canvas
                if (!this.ctx) {
                    const oldCanvas = this.canvas;
                    const newCanvas = document.createElement('canvas');
                    newCanvas.id = 'gameCanvas';
                    newCanvas.width = window.innerWidth;
                    newCanvas.height = window.innerHeight;
                    newCanvas.style.cssText = oldCanvas.style.cssText;
                    oldCanvas.parentNode.replaceChild(newCanvas, oldCanvas);
                    this.canvas = newCanvas;
                    this.ctx = this.canvas.getContext('2d');
                }
                this.state.renderMode = 'abstract';
                
                // Hide workers, show buildings
                document.getElementById('workers').style.display = 'none';
                document.getElementById('buildings').style.display = 'block';
                
                // Update UI
                document.getElementById('controlsText').innerHTML = 
                    'Click - Place Automation<br>Watch - Numbers grow';
                
                this.automationNodes = [];
                this.initAutomationBuildings();
            }
            
            initAutomationBuildings() {
                const buildingList = document.getElementById('buildingList');
                buildingList.innerHTML = '';
                
                const buildings = [
                    { name: 'Collector', cost: 50, rate: 0, acRate: 2, mult: 1 },
                    { name: 'Processor', cost: 150, rate: 5, acRate: 0, mult: 1 },
                    { name: 'Multiplier', cost: 500, rate: 0, acRate: 0, mult: 1.5 },
                    { name: 'Synthesizer', cost: 2000, rate: 100, acRate: 0, mult: 1 }
                ];
                
                buildings.forEach(b => {
                    const btn = document.createElement('button');
                    btn.className = 'building-btn';
                    btn.id = 'building-' + b.name;
                    const desc = b.acRate > 0 ? `+${b.acRate} AC/s` : b.mult > 1 ? `x${b.mult} all rates` : `${b.rate} OKR/s`;
                    btn.textContent = `${b.name} (${b.cost} AC) - ${desc}`;
                    btn.onclick = () => this.selectBuilding(b, btn);
                    buildingList.appendChild(btn);
                });
            }
            
            selectBuilding(building, btn) {
                // Deselect previous
                document.querySelectorAll('.building-btn').forEach(b => b.classList.remove('selected'));
                
                this.selectedBuilding = building;
                if (btn) btn.classList.add('selected');
            }
            
            handleCanvasClick(e) {
                if (!this.selectedBuilding) return;
                
                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                if (this.state.currencies.ac >= this.selectedBuilding.cost) {
                    this.state.currencies.ac -= this.selectedBuilding.cost;
                    this.automationNodes.push({
                        x, y,
                        name: this.selectedBuilding.name,
                        rate: this.selectedBuilding.rate,
                        acRate: this.selectedBuilding.acRate || 0,
                        mult: this.selectedBuilding.mult || 1,
                        id: this.buildingIdCounter++
                    });
                    this.updateUI();
                }
            }
            
            loadLevel(levelNum) {
                this.levelCompleting = false;
                this.liftAnimating = false;
                this.levelStartTime = performance.now();
                this.currentLevelData = this.levelConfigs[levelNum];
                this.state.currentLevel = levelNum;
                this.state.okrsCollected = 0;
                
                // Clear existing objects
                this.okrs = [];
                this.platforms = [];
                this.jrodHQ = null;
                
                // Determine phase
                if (levelNum <= 5) this.state.phase = 1;
                else if (levelNum <= 10) this.state.phase = 2;
                else this.state.phase = 3;
                
                // Generate level based on phase
                if (this.state.phase === 1) {
                    this.generatePhase1Level(levelNum);
                } else if (this.state.phase === 2) {
                    this.generatePhase2Level(levelNum);
                } else {
                    this.generatePhase3Level(levelNum);
                }
                
                this.updateUI();
                
                // Start level music
                this.startMusic(levelNum);
            }
            
            generatePhase1Level(levelNum) {
                // Clear scene
                if (this.scene) {
                    const objectsToRemove = [];
                    this.scene.traverse((obj) => {
                        if (obj.userData.isLevelObject) {
                            objectsToRemove.push(obj);
                        }
                    });
                    objectsToRemove.forEach(obj => this.scene.remove(obj));
                }
                
                // Reset player
                this.player.position.set(0, 2, 0);
                this.playerVelocity = { x: 0, y: 0, z: 0 };
                
                const config = this.currentLevelData;
                
                // Create ground platform
                this.createPlatform(0, -1, 0, 20, 2, 20, 0x228b22);
                
                // Generate platforms based on level
                if (levelNum === 1) {
                    // Tutorial - flat platforms
                    this.createPlatform(10, 0, 0, 5, 1, 5, 0x8b4513);
                    this.createPlatform(20, 0, 0, 8, 1, 8, 0x8b4513);
                } else if (levelNum === 2) {
                    // Gaps
                    this.createPlatform(8, 0, 0, 4, 1, 4, 0x8b4513);
                    this.createPlatform(16, 0, 0, 4, 1, 4, 0x8b4513);
                    this.createPlatform(24, 0, 0, 4, 1, 4, 0x8b4513);
                } else if (levelNum === 3) {
                    // Obstacles
                    for (let i = 0; i < 5; i++) {
                        this.createPlatform(8 + i * 6, Math.random() * 2, 0, 3, 1, 3, 0x8b4513);
                    }
                } else if (levelNum === 4) {
                    // Vertical
                    for (let i = 0; i < 5; i++) {
                        this.createPlatform(5, i * 3 + 1, 0, 4, 1, 4, 0x8b4513);
                    }
                } else if (levelNum === 5) {
                    // Boss level - spiral staircase (tighter radius, bigger platforms)
                    for (let i = 0; i < 8; i++) {
                        const angle = (i / 8) * Math.PI * 2;
                        const x = Math.cos(angle) * 8;
                        const z = Math.sin(angle) * 8;
                        this.createPlatform(x, i * 1.5, z, 5, 1, 5, 0x8b4513);
                    }
                }
                
                // Place OKRs
                for (let i = 0; i < config.okrGoal; i++) {
                    let pos;
                    if (levelNum === 1) {
                        pos = { x: 10 + i * 5, y: 3, z: 0 };
                    } else {
                        const platform = this.platforms[Math.floor(Math.random() * this.platforms.length)];
                        if (platform) {
                            pos = {
                                x: platform.position.x + (Math.random() - 0.5) * 2,
                                y: platform.position.y + 3,
                                z: platform.position.z + (Math.random() - 0.5) * 2
                            };
                        } else {
                            pos = { x: i * 5, y: 3, z: 0 };
                        }
                    }
                    this.createOKR(pos.x, pos.y, pos.z);
                }
                
                // Create Jrod HQ - Car Lift goal
                const lastPlatform = this.platforms[this.platforms.length - 1];
                const hqX = lastPlatform ? lastPlatform.position.x + 8 : 25;
                
                const liftGroup = new THREE.Group();
                const steelMat = new THREE.MeshPhongMaterial({ color: 0x888888 });
                const baseMat = new THREE.MeshPhongMaterial({ color: 0x444444 });
                const yellowMat = new THREE.MeshPhongMaterial({ color: 0xffcc00, emissive: 0xffaa00, emissiveIntensity: 0.3 });
                
                // Base plate
                const base = new THREE.Mesh(new THREE.BoxGeometry(3, 0.2, 4), baseMat);
                base.position.set(0, 0.1, 0);
                liftGroup.add(base);
                
                // Left pillar
                const pillar = new THREE.Mesh(new THREE.BoxGeometry(0.3, 6, 0.3), steelMat);
                pillar.position.set(-1.2, 3, 0);
                liftGroup.add(pillar);
                
                // Right pillar
                const pillar2 = pillar.clone();
                pillar2.position.set(1.2, 3, 0);
                liftGroup.add(pillar2);
                
                // Cross beam at top
                const beam = new THREE.Mesh(new THREE.BoxGeometry(3, 0.2, 0.2), steelMat);
                beam.position.set(0, 6, 0);
                liftGroup.add(beam);
                
                // Lift platform (the part that goes up)
                const liftPlatform = new THREE.Mesh(new THREE.BoxGeometry(2.5, 0.15, 3.5), yellowMat);
                liftPlatform.position.set(0, 0.3, 0);
                liftPlatform.name = 'liftPlatform';
                liftGroup.add(liftPlatform);
                
                // Lift arms (scissors)
                const armMat = new THREE.MeshPhongMaterial({ color: 0xcc0000 });
                const leftArm = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.1, 3), armMat);
                leftArm.position.set(-1, 0.3, 0);
                liftGroup.add(leftArm);
                const rightArm = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.1, 3), armMat);
                rightArm.position.set(1, 0.3, 0);
                liftGroup.add(rightArm);
                
                // Warning stripes on base
                const stripeMat = new THREE.MeshPhongMaterial({ color: 0x000000 });
                for (let i = -1; i <= 1; i += 0.5) {
                    const stripe = new THREE.Mesh(new THREE.BoxGeometry(3, 0.01, 0.1), stripeMat);
                    stripe.position.set(0, 0.21, i);
                    liftGroup.add(stripe);
                }
                
                // Arrow indicator (glowing)
                const arrowMat = new THREE.MeshPhongMaterial({ color: 0x00ff00, emissive: 0x00ff00, emissiveIntensity: 0.8 });
                const arrow = new THREE.Mesh(new THREE.ConeGeometry(0.3, 0.6, 4), arrowMat);
                arrow.position.set(0, 7, 0);
                arrow.rotation.x = Math.PI;
                liftGroup.add(arrow);
                
                liftGroup.position.set(hqX, 0, 0);
                liftGroup.traverse(child => {
                    child.castShadow = true;
                    child.userData.isLevelObject = true;
                });
                
                this.jrodHQ = liftGroup;
                this.jrodHQ.userData.isLevelObject = true;
                this.scene.add(this.jrodHQ);
                
                // Platform under HQ so player can reach it
                this.createPlatform(hqX, 0, 0, 6, 1, 6, 0x228b22);
                
                // Add spectators for this level
                this.loadSpectators3D(levelNum);
            }
            
            createPlatform(x, y, z, width, height, depth, color) {
                const geometry = new THREE.BoxGeometry(width, height, depth);
                const material = new THREE.MeshPhongMaterial({ color });
                const platform = new THREE.Mesh(geometry, material);
                platform.position.set(x, y, z);
                platform.receiveShadow = true;
                platform.castShadow = true;
                platform.userData.isLevelObject = true;
                platform.userData.isPlatform = true;
                this.scene.add(platform);
                this.platforms.push(platform);
                
                // Add Domino's logo to large ground platforms (green, 20x20)
                if (color === 0x228b22 && width >= 20) {
                    this.addDominosLogo(platform, width, depth);
                }
            }
            
            addDominosLogo(platform, w, d) {
                const size = 512;
                const c = document.createElement('canvas');
                c.width = size; c.height = size;
                const ctx = c.getContext('2d');
                
                // Transparent background
                ctx.clearRect(0, 0, size, size);
                
                const cx = size / 2, cy = size / 2;
                
                // Domino tile shape (tilted 45Â°)
                ctx.save();
                ctx.translate(cx, cy);
                ctx.rotate(Math.PI / 4);
                
                // Blue square domino tile
                const tileW = 160, tileH = 280;
                const r = 18;
                ctx.beginPath();
                ctx.moveTo(-tileW/2 + r, -tileH/2);
                ctx.lineTo(tileW/2 - r, -tileH/2);
                ctx.quadraticCurveTo(tileW/2, -tileH/2, tileW/2, -tileH/2 + r);
                ctx.lineTo(tileW/2, tileH/2 - r);
                ctx.quadraticCurveTo(tileW/2, tileH/2, tileW/2 - r, tileH/2);
                ctx.lineTo(-tileW/2 + r, tileH/2);
                ctx.quadraticCurveTo(-tileW/2, tileH/2, -tileW/2, tileH/2 - r);
                ctx.lineTo(-tileW/2, -tileH/2 + r);
                ctx.quadraticCurveTo(-tileW/2, -tileH/2, -tileW/2 + r, -tileH/2);
                ctx.closePath();
                ctx.fillStyle = '#0b5ca4';
                ctx.fill();
                
                // Divider line
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.moveTo(-tileW/2 + 10, 0);
                ctx.lineTo(tileW/2 - 10, 0);
                ctx.stroke();
                
                // Top half - red square with 1 dot
                ctx.fillStyle = '#d50032';
                const smallR = 12;
                const inset = 14;
                ctx.beginPath();
                ctx.moveTo(-tileW/2 + inset + smallR, -tileH/2 + inset);
                ctx.lineTo(tileW/2 - inset - smallR, -tileH/2 + inset);
                ctx.quadraticCurveTo(tileW/2 - inset, -tileH/2 + inset, tileW/2 - inset, -tileH/2 + inset + smallR);
                ctx.lineTo(tileW/2 - inset, -smallR);
                ctx.quadraticCurveTo(tileW/2 - inset, -4, tileW/2 - inset - smallR, -4);
                ctx.lineTo(-tileW/2 + inset + smallR, -4);
                ctx.quadraticCurveTo(-tileW/2 + inset, -4, -tileW/2 + inset, -smallR);
                ctx.lineTo(-tileW/2 + inset, -tileH/2 + inset + smallR);
                ctx.quadraticCurveTo(-tileW/2 + inset, -tileH/2 + inset, -tileW/2 + inset + smallR, -tileH/2 + inset);
                ctx.closePath();
                ctx.fill();
                
                // Dot on red half
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(0, -tileH/4, 14, 0, Math.PI * 2);
                ctx.fill();
                
                // Bottom half dots (2 dots)
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(-30, tileH/4 - 20, 14, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(30, tileH/4 + 20, 14, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
                
                // "TEAM DOMINOS" text below the tile
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 52px Arial, sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'top';
                ctx.fillText('TEAM', cx, cy + 130);
                ctx.fillText('DOMINOS', cx, cy + 180);
                
                const texture = new THREE.CanvasTexture(c);
                texture.needsUpdate = true;
                const logoGeo = new THREE.PlaneGeometry(Math.min(w, d) * 0.8, Math.min(w, d) * 0.8);
                const logoMat = new THREE.MeshBasicMaterial({ 
                    map: texture, 
                    transparent: true, 
                    depthWrite: false,
                    polygonOffset: true,
                    polygonOffsetFactor: -1
                });
                const logoMesh = new THREE.Mesh(logoGeo, logoMat);
                logoMesh.rotation.x = -Math.PI / 2;
                logoMesh.position.y = platform.geometry.parameters.height / 2 + 0.01;
                logoMesh.userData.isLevelObject = true;
                platform.add(logoMesh);
            }
            
            createOKR(x, y, z) {
                const coinGroup = new THREE.Group();
                
                // Coin disc (upright â€” rotate so flat face is toward camera)
                const geometry = new THREE.CylinderGeometry(0.5, 0.5, 0.12, 24);
                const material = new THREE.MeshPhongMaterial({
                    color: 0xffd700,
                    emissive: 0xffaa00,
                    emissiveIntensity: 0.5
                });
                const disc = new THREE.Mesh(geometry, material);
                disc.rotation.z = Math.PI / 2; // Stand upright
                coinGroup.add(disc);
                
                // "OKR" text as a flat plane on front face
                const textCanvas = document.createElement('canvas');
                textCanvas.width = 128;
                textCanvas.height = 128;
                const tCtx = textCanvas.getContext('2d');
                tCtx.clearRect(0, 0, 128, 128);
                tCtx.fillStyle = '#000000';
                tCtx.font = 'bold 52px Arial';
                tCtx.textAlign = 'center';
                tCtx.textBaseline = 'middle';
                tCtx.fillText('OKR', 64, 64);
                
                const textTexture = new THREE.CanvasTexture(textCanvas);
                const textGeo = new THREE.PlaneGeometry(0.7, 0.7);
                
                // Front text
                const frontMat = new THREE.MeshBasicMaterial({ map: textTexture, transparent: true });
                const frontText = new THREE.Mesh(textGeo, frontMat);
                frontText.position.set(0.07, 0, 0);
                frontText.rotation.y = Math.PI / 2;
                coinGroup.add(frontText);
                
                // Back text
                const backMat = new THREE.MeshBasicMaterial({ map: textTexture, transparent: true });
                const backText = new THREE.Mesh(textGeo, backMat);
                backText.position.set(-0.07, 0, 0);
                backText.rotation.y = -Math.PI / 2;
                coinGroup.add(backText);
                
                coinGroup.position.set(x, y, z);
                coinGroup.userData.isLevelObject = true;
                coinGroup.userData.isOKR = true;
                this.scene.add(coinGroup);
                this.okrs.push(coinGroup);
            }
            
            loadSpectators3D(levelNum) {
                // Clear existing spectators
                this.currentLevelSpectators.forEach(spec => {
                    if (spec.mesh && this.scene) {
                        this.scene.remove(spec.mesh);
                    }
                });
                this.currentLevelSpectators = [];
                
                const spectators = this.levelSpectators[levelNum];
                if (!spectators) return;
                
                spectators.forEach((spec, i) => {
                    const x = i === 0 ? -10 : 10;
                    const z = -8;
                    const spectator = this.createSpectator3D(spec.name, spec.color, x, z, spec.quote);
                    this.currentLevelSpectators.push(spectator);
                });
            }
            
            createSpectator3D(name, color, x, z, quote) {
                const mesh = new THREE.Group();
                const skinColor = 0xffdbac;
                
                // Legs
                const legMat = new THREE.MeshLambertMaterial({ color: 0x2244aa });
                const leftLeg = new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.7, 0.25), legMat);
                leftLeg.position.set(-0.15, -0.35, 0);
                mesh.add(leftLeg);
                const rightLeg = new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.7, 0.25), legMat);
                rightLeg.position.set(0.15, -0.35, 0);
                mesh.add(rightLeg);
                
                // Shoes
                const shoeMat = new THREE.MeshLambertMaterial({ color: 0x333333 });
                const leftShoe = new THREE.Mesh(new THREE.BoxGeometry(0.27, 0.12, 0.35), shoeMat);
                leftShoe.position.set(-0.15, -0.75, 0.05);
                mesh.add(leftShoe);
                const rightShoe = new THREE.Mesh(new THREE.BoxGeometry(0.27, 0.12, 0.35), shoeMat);
                rightShoe.position.set(0.15, -0.75, 0.05);
                mesh.add(rightShoe);
                
                // Body (shirt color = team color)
                const bodyMaterial = new THREE.MeshLambertMaterial({ color: color });
                const body = new THREE.Mesh(new THREE.BoxGeometry(0.7, 1.0, 0.45), bodyMaterial);
                body.position.set(0, 0.5, 0);
                body.castShadow = true;
                mesh.add(body);
                
                // Collar
                const collarMat = new THREE.MeshLambertMaterial({ color: 0xffffff });
                const collar = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.1, 0.3), collarMat);
                collar.position.set(0, 0.95, 0.1);
                mesh.add(collar);
                
                // Arms
                const armMat = new THREE.MeshLambertMaterial({ color: color });
                const leftArm = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.8, 0.2), armMat);
                leftArm.position.set(-0.45, 0.5, 0);
                leftArm.name = 'leftArm';
                mesh.add(leftArm);
                const rightArm = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.8, 0.2), armMat);
                rightArm.position.set(0.45, 0.5, 0);
                rightArm.name = 'rightArm';
                mesh.add(rightArm);
                
                // Hands
                const handMat = new THREE.MeshLambertMaterial({ color: skinColor });
                const leftHand = new THREE.Mesh(new THREE.SphereGeometry(0.1, 8, 8), handMat);
                leftHand.position.set(-0.45, 0.05, 0);
                mesh.add(leftHand);
                const rightHand = new THREE.Mesh(new THREE.SphereGeometry(0.1, 8, 8), handMat);
                rightHand.position.set(0.45, 0.05, 0);
                mesh.add(rightHand);
                
                // Head
                const headMaterial = new THREE.MeshLambertMaterial({ color: skinColor });
                const head = new THREE.Mesh(new THREE.SphereGeometry(0.3, 12, 12), headMaterial);
                head.position.y = 1.35;
                head.castShadow = true;
                mesh.add(head);
                
                // Hair (random style per person)
                const hairColor = [0x442200, 0x222222, 0x8B4513, 0xDAA520, 0x2F1B14][name.length % 5];
                const hairMat = new THREE.MeshLambertMaterial({ color: hairColor });
                const hair = new THREE.Mesh(
                    new THREE.SphereGeometry(0.32, 12, 12, 0, Math.PI * 2, 0, Math.PI * 0.55),
                    hairMat
                );
                hair.position.y = 1.42;
                mesh.add(hair);
                
                // Eyes
                const eyeMat = new THREE.MeshBasicMaterial({ color: 0x000000 });
                const eyeWhiteMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
                const leWhite = new THREE.Mesh(new THREE.SphereGeometry(0.06, 8, 8), eyeWhiteMat);
                leWhite.position.set(-0.1, 1.38, 0.26);
                mesh.add(leWhite);
                const reWhite = new THREE.Mesh(new THREE.SphereGeometry(0.06, 8, 8), eyeWhiteMat);
                reWhite.position.set(0.1, 1.38, 0.26);
                mesh.add(reWhite);
                const le = new THREE.Mesh(new THREE.SphereGeometry(0.035, 6, 6), eyeMat);
                le.position.set(-0.1, 1.38, 0.3);
                mesh.add(le);
                const re = new THREE.Mesh(new THREE.SphereGeometry(0.035, 6, 6), eyeMat);
                re.position.set(0.1, 1.38, 0.3);
                mesh.add(re);
                
                // Mouth (smile)
                const smileMat = new THREE.MeshBasicMaterial({ color: 0xcc6666 });
                const smile = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.03, 0.02), smileMat);
                smile.position.set(0, 1.28, 0.29);
                mesh.add(smile);
                
                // Nameplate
                const nameCanvas = document.createElement('canvas');
                nameCanvas.width = 256;
                nameCanvas.height = 64;
                const nCtx = nameCanvas.getContext('2d');
                nCtx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                nCtx.roundRect(4, 4, 248, 56, 8);
                nCtx.fill();
                nCtx.strokeStyle = color;
                nCtx.lineWidth = 2;
                nCtx.roundRect(4, 4, 248, 56, 8);
                nCtx.stroke();
                nCtx.fillStyle = '#ffffff';
                nCtx.font = 'bold 24px Arial';
                nCtx.textAlign = 'center';
                nCtx.textBaseline = 'middle';
                nCtx.fillText(name, 128, 32);
                
                const nameTexture = new THREE.CanvasTexture(nameCanvas);
                const nameMaterial = new THREE.SpriteMaterial({ map: nameTexture, transparent: true });
                const nameSprite = new THREE.Sprite(nameMaterial);
                nameSprite.position.y = 2.0;
                nameSprite.scale.set(2.5, 0.6, 1);
                mesh.add(nameSprite);
                
                mesh.position.set(x, 0.75, z);
                mesh.userData.isLevelObject = true;
                
                this.scene.add(mesh);
                
                return {
                    name: name,
                    mesh: mesh,
                    quote: quote,
                    baseY: 0.75,
                    animTime: Math.random() * Math.PI * 2,
                    cheer: function() {
                        // Jump animation using simple tween
                        const startY = this.mesh.position.y;
                        const jumpHeight = 1.5;
                        const duration = 400;
                        const startTime = Date.now();
                        
                        const jump = () => {
                            const elapsed = Date.now() - startTime;
                            const progress = elapsed / duration;
                            
                            if (progress < 0.5) {
                                this.mesh.position.y = startY + (jumpHeight * progress * 2);
                            } else if (progress < 1) {
                                this.mesh.position.y = startY + jumpHeight - (jumpHeight * (progress - 0.5) * 2);
                            } else {
                                this.mesh.position.y = startY;
                                return;
                            }
                            requestAnimationFrame(jump);
                        };
                        jump();
                    }
                };
            }
            
            loadSpectatorsAnime(levelNum) {
                this.currentLevelSpectators = [];
                
                const spectators = this.levelSpectators[levelNum];
                if (!spectators) return;
                
                spectators.forEach((spec, i) => {
                    const x = i === 0 ? 50 : this.canvas.width - 120;
                    const y = 100 + i * 80;
                    const spectator = {
                        name: spec.name,
                        color: spec.color,
                        quote: spec.quote || '',
                        x: x,
                        y: y,
                        emotion: 'neutral',
                        speechBubble: '',
                        speechTimer: 0,
                        react: function(event) {
                            if (event === 'okr') {
                                this.speechBubble = 'Nice!';
                                this.speechTimer = 60;
                            } else if (event === 'complete') {
                                this.speechBubble = this.quote || 'Great!';
                                this.speechTimer = 90;
                            }
                        }
                    };
                    this.currentLevelSpectators.push(spectator);
                });
            }
            
            loadSpectatorsPixel(levelNum) {
                this.currentLevelSpectators = [];
                
                const spectators = this.levelSpectators[levelNum];
                if (!spectators) return;
                
                // Special handling for level 14 - all 20 team members
                if (levelNum === 14) {
                    const allNames = [
                        'Bea', 'Francisco', 'Ramon', 'Erik', 'Mason', 'Stephane', 'Avital', 'Murali',
                        'Parker', 'Zaki', 'Jeff', 'Lauren B', 'Patrick', 'Katy', 'Jason', 'Ada',
                        'Josh', 'James', 'Yanan', 'Lauren G'
                    ];
                    const colors = [
                        '#4a90e2', '#e74c3c', '#3498db', '#9b59b6', '#27ae60', '#1abc9c', '#f39c12', '#e67e22',
                        '#2ecc71', '#16a085', '#8e44ad', '#c0392b', '#d35400', '#2980b9', '#27ae60', '#e91e63',
                        '#00bcd4', '#9c27b0', '#ff9800', '#4caf50'
                    ];
                    
                    allNames.forEach((name, i) => {
                        const row = Math.floor(i / 10);
                        const col = i % 10;
                        const spectator = {
                            name: name,
                            color: colors[i],
                            x: 5 + col * 8,
                            y: 5 + row * 10,
                            scale: 3
                        };
                        this.currentLevelSpectators.push(spectator);
                    });
                } else {
                    spectators.forEach((spec, i) => {
                        const x = i === 0 ? 5 : this.canvas.width / 4 - 10;
                        const y = 5 + i * 10;
                        const spectator = {
                            name: spec.name,
                            color: spec.color,
                            x: x,
                            y: y,
                            scale: 4
                        };
                        this.currentLevelSpectators.push(spectator);
                    });
                }
            }
            
            generatePhase2Level(levelNum) {
                // 2D side-scrolling platformer level
                this.player = { x: 100, y: 0, vx: 0, vy: 0, facingRight: true, grounded: false };
                this.p2CamX = 0;
                
                const groundY = this.canvas ? this.canvas.height - 80 : 640;
                this.p2GroundY = groundY;
                
                // Generate platforms â€” ground + floating platforms
                this.platforms = [];
                const levelWidth = 800 + levelNum * 400; // wider each level
                
                // Ground segments with gaps
                const segLen = 200;
                for (let x = 0; x < levelWidth; x += segLen) {
                    const hasGap = x > 300 && Math.sin(x * 0.01 + levelNum * 7) > 0.4;
                    if (!hasGap) {
                        this.platforms.push({ x, y: groundY, w: segLen - 10, h: 40, type: 'ground' });
                    }
                }
                
                // Floating platforms
                const platCount = 8 + levelNum * 3;
                const rng = (s) => { s = (s * 16807) % 2147483647; return s; };
                let seed = levelNum * 9999;
                for (let i = 0; i < platCount; i++) {
                    seed = rng(seed);
                    const px = 200 + (seed % (levelWidth - 400));
                    seed = rng(seed);
                    const py = groundY - 80 - (seed % 250);
                    seed = rng(seed);
                    const pw = 80 + (seed % 120);
                    this.platforms.push({ x: px, y: py, w: pw, h: 20, type: 'float' });
                }
                
                // OKR coins scattered on platforms and in air
                this.okrs = [];
                for (let i = 0; i < this.currentLevelData.okrGoal; i++) {
                    seed = rng(seed);
                    const plat = this.platforms[seed % this.platforms.length];
                    seed = rng(seed);
                    this.okrs.push({
                        x: plat.x + (seed % Math.max(1, plat.w - 20)) + 10,
                        y: plat.y - 40 - (seed % 60),
                        collected: false
                    });
                }
                
                // Car lift goal at end
                this.jrodHQ = { x: levelWidth - 150, y: groundY };
                // Ensure ground under goal
                this.platforms.push({ x: levelWidth - 250, y: groundY, w: 300, h: 40, type: 'ground' });
                
                // Position AI workers
                this.state.aiWorkers.forEach((w, i) => {
                    w.x = 150 + i * 80;
                    w.y = groundY - 30;
                    w.targetOKR = null;
                });
                
                // Add spectators
                this.loadSpectatorsAnime(levelNum);
            }
            
            generatePhase3Level(levelNum) {
                // Abstract level - just needs goal
                this.okrs = [];
                this.platforms = [];
                this.jrodHQ = { active: true };
                
                // Add spectators for this level
                this.loadSpectatorsPixel(levelNum);
            }
            
            updatePhase1(dt) {
                if (!this.player) return;
                
                const speed = this.state.playerStats.speed;
                const sprint = this.keys['ShiftLeft'] && this.state.playerStats.sprint > 0 ? 1.5 : 1;
                
                // Movement
                let moveX = 0, moveZ = 0;
                if (this.keys['KeyW']) moveZ -= 1;
                if (this.keys['KeyS']) moveZ += 1;
                if (this.keys['KeyA']) moveX -= 1;
                if (this.keys['KeyD']) moveX += 1;
                
                if (moveX !== 0 || moveZ !== 0) {
                    // Normalize diagonal movement
                    const len = Math.sqrt(moveX * moveX + moveZ * moveZ);
                    moveX /= len;
                    moveZ /= len;
                    
                    this.playerVelocity.x = moveX * speed * sprint;
                    this.playerVelocity.z = moveZ * speed * sprint;
                    
                    // Rotate car to face movement direction (smooth)
                    const targetAngle = Math.atan2(moveX, moveZ);
                    let angleDiff = targetAngle - this.player.rotation.y;
                    while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                    while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                    this.player.rotation.y += angleDiff * 0.25;
                } else {
                    // Friction when not pressing keys
                    this.playerVelocity.x *= 0.85;
                    this.playerVelocity.z *= 0.85;
                }
                
                // Jump
                if (this.keys['Space'] && this.isGrounded) {
                    this.playerVelocity.y = this.state.playerStats.jump;
                    this.isGrounded = false;
                    this.hasDoubleJumped = false;
                } else if (this.keys['Space'] && this.canDoubleJump && !this.hasDoubleJumped && !this.isGrounded) {
                    this.playerVelocity.y = this.state.playerStats.jump * 0.8;
                    this.hasDoubleJumped = true;
                    this.keys['Space'] = false;
                }
                
                // Gravity (reduced for better jump feel)
                this.playerVelocity.y -= 20 * dt;
                
                // Apply velocity
                this.player.position.x += this.playerVelocity.x * dt;
                this.player.position.y += this.playerVelocity.y * dt;
                this.player.position.z += this.playerVelocity.z * dt;
                
                // Friction
                this.playerVelocity.x *= 0.9;
                this.playerVelocity.z *= 0.9;
                
                // Collision detection
                this.isGrounded = false;
                const playerBox = new THREE.Box3().setFromObject(this.player);
                const playerHeight = playerBox.max.y - playerBox.min.y;
                const playerBottomOffset = this.player.position.y - playerBox.min.y;
                
                this.platforms.forEach(platform => {
                    const platformBox = new THREE.Box3().setFromObject(platform);
                    
                    if (playerBox.intersectsBox(platformBox)) {
                        if (this.playerVelocity.y <= 0) {
                            this.player.position.y = platformBox.max.y + playerBottomOffset;
                            this.playerVelocity.y = 0;
                            this.isGrounded = true;
                        }
                    }
                });
                
                // Death check - respawn if fallen too far
                if (this.player.position.y < -20) {
                    this.respawnPlayer();
                }
                
                // OKR collection
                this.okrs = this.okrs.filter(okr => {
                    const dist = this.player.position.distanceTo(okr.position);
                    if (dist < 2) {
                        this.collectOKR();
                        this.scene.remove(okr);
                        return false;
                    }
                    return true;
                });
                
                // Rotate OKRs + glow pulse
                this.okrs.forEach(okr => {
                    okr.rotation.y += dt * 2;
                    // Pulse glow on the disc mesh (first child)
                    const disc = okr.children && okr.children[0];
                    if (disc && disc.material) {
                        disc.material.emissiveIntensity = 0.3 + Math.sin(this.gameTime * 4) * 0.3;
                    }
                });
                
                // Update lights to follow player
                if (this.playerLight) {
                    this.playerLight.position.set(
                        this.player.position.x,
                        this.player.position.y + 1.5,
                        this.player.position.z + 2
                    );
                    this.playerLight.target.position.set(
                        this.player.position.x,
                        this.player.position.y,
                        this.player.position.z + 10
                    );
                    this.rimLight.position.set(
                        this.player.position.x,
                        this.player.position.y + 3,
                        this.player.position.z - 5
                    );
                }
                
                // HQ check - car lift animation (2s cooldown after level load to prevent instant re-trigger)
                const timeSinceLevelStart = performance.now() - (this.levelStartTime || 0);
                if (this.jrodHQ && !this.liftAnimating && !this.levelCompleting && timeSinceLevelStart > 2000) {
                    const distToHQ = this.player.position.distanceTo(this.jrodHQ.position);
                    if (distToHQ < 5 && this.state.okrsCollected >= this.currentLevelData.okrGoal) {
                        this.playLiftAnimation();
                    }
                }
                
                // Camera follow
                this.camera.position.x = this.player.position.x + this.cameraOffset.x;
                this.camera.position.y = this.player.position.y + this.cameraOffset.y;
                this.camera.position.z = this.player.position.z + this.cameraOffset.z;
                this.camera.lookAt(this.player.position);
                
                // Animate spectators (idle sway + arm wave)
                this.currentLevelSpectators.forEach(spec => {
                    if (spec.mesh) {
                        spec.animTime += dt;
                        spec.mesh.rotation.z = Math.sin(spec.animTime * 0.8) * 0.05;
                        spec.mesh.position.y = spec.baseY + Math.sin(spec.animTime * 1.5) * 0.05;
                        
                        // Wave arms
                        spec.mesh.traverse(child => {
                            if (child.name === 'rightArm') {
                                child.rotation.z = Math.sin(spec.animTime * 3) * 0.4;
                            }
                            if (child.name === 'leftArm') {
                                child.rotation.z = Math.sin(spec.animTime * 3 + 1) * -0.2;
                            }
                        });
                    }
                });
                
                // Render
                this.renderer.render(this.scene, this.camera);
            }
            
            updatePhase2(dt) {
                if (!this.player) return;
                const p = this.player;
                
                // Horizontal movement
                let moveX = 0;
                if (this.keys['KeyA'] || this.keys['ArrowLeft']) moveX = -1;
                if (this.keys['KeyD'] || this.keys['ArrowRight']) moveX = 1;
                
                if (moveX !== 0) {
                    p.vx = moveX * this.p2Speed;
                    p.facingRight = moveX > 0;
                } else {
                    p.vx *= 0.8; // friction
                }
                
                // Jump
                if ((this.keys['Space'] || this.keys['KeyW'] || this.keys['ArrowUp']) && p.grounded) {
                    p.vy = this.p2JumpForce;
                    p.grounded = false;
                }
                
                // Gravity
                p.vy += this.p2Gravity * dt;
                
                // Apply velocity
                p.x += p.vx * dt;
                p.y += p.vy * dt;
                
                // Platform collision
                p.grounded = false;
                const pw = 30, ph = 36; // player hitbox
                this.platforms.forEach(plat => {
                    const onTop = p.x + pw/2 > plat.x && p.x - pw/2 < plat.x + plat.w;
                    const falling = p.vy >= 0;
                    const feetY = p.y + ph;
                    const wasAbove = (feetY - p.vy * dt) <= plat.y + 4;
                    if (onTop && falling && feetY >= plat.y && wasAbove) {
                        p.y = plat.y - ph;
                        p.vy = 0;
                        p.grounded = true;
                    }
                });
                
                // Death check â€” fall off screen
                if (p.y > this.canvas.height + 100) {
                    p.x = 100;
                    p.y = this.p2GroundY - 100;
                    p.vx = 0; p.vy = 0;
                }
                
                // Keep in horizontal bounds
                p.x = Math.max(0, p.x);
                
                // MP regeneration
                this.state.currencies.mp += 0.5 * dt;
                
                // Player collects OKRs
                this.okrs.forEach(okr => {
                    if (!okr.collected) {
                        const dx = p.x - okr.x;
                        const dy = p.y - okr.y;
                        if (Math.abs(dx) < 30 && Math.abs(dy) < 30) {
                            okr.collected = true;
                            this.collectOKR();
                        }
                    }
                });
                
                // AI workers collect OKRs (walk on ground)
                this.state.aiWorkers.forEach(worker => {
                    if (!worker.targetOKR) {
                        const available = this.okrs.filter(o => !o.collected && !o.claimed);
                        if (available.length > 0) {
                            worker.targetOKR = available[0];
                            worker.targetOKR.claimed = true;
                        }
                    } else {
                        const dx = worker.targetOKR.x - worker.x;
                        const dist = Math.abs(dx);
                        if (dist < 30) {
                            worker.targetOKR.collected = true;
                            this.collectOKR();
                            worker.targetOKR = null;
                        } else {
                            worker.x += Math.sign(dx) * 120 * dt;
                        }
                    }
                });
                
                // Check completion: reach car lift with enough OKRs
                const timeSinceLevelStart = performance.now() - (this.levelStartTime || 0);
                if (this.state.okrsCollected >= this.currentLevelData.okrGoal && this.jrodHQ && timeSinceLevelStart > 2000) {
                    const dx = p.x - this.jrodHQ.x;
                    const dy = p.y - (this.jrodHQ.y - 36);
                    if (Math.abs(dx) < 60 && Math.abs(dy) < 60 && !this.levelCompleting) {
                        this.completeLevel();
                    }
                }
                
                this.renderPhase2();
            }
            
            renderPhase2() {
                const ctx = this.ctx;
                const canvas = this.canvas;
                if (!ctx) return;
                
                // Camera: smooth follow on X axis
                const targetCamX = this.player.x - canvas.width / 3;
                this.p2CamX += (targetCamX - this.p2CamX) * 0.1;
                this.p2CamX = Math.max(0, this.p2CamX);
                const cx = this.p2CamX;
                
                // === SKY ===
                const skyGrad = ctx.createLinearGradient(0, 0, 0, canvas.height);
                skyGrad.addColorStop(0, '#4a90d9');
                skyGrad.addColorStop(0.5, '#87CEEB');
                skyGrad.addColorStop(0.8, '#FFB6C1');
                skyGrad.addColorStop(1, '#FFA07A');
                ctx.fillStyle = skyGrad;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Parallax clouds
                ctx.fillStyle = 'rgba(255,255,255,0.8)';
                for (let i = 0; i < 8; i++) {
                    const cloudX = ((i * 300 + this.gameTime * 10 - cx * 0.1) % (canvas.width + 300)) - 150;
                    const cloudY = 30 + (i * 47) % 150;
                    ctx.beginPath();
                    ctx.arc(cloudX, cloudY, 20 + i * 3, 0, Math.PI * 2);
                    ctx.arc(cloudX + 25, cloudY - 5, 25 + i * 2, 0, Math.PI * 2);
                    ctx.arc(cloudX + 50, cloudY, 20 + i * 3, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Parallax mountains
                ctx.fillStyle = '#6a8fa8';
                ctx.beginPath();
                ctx.moveTo(0, this.p2GroundY - 40);
                for (let i = 0; i < canvas.width + 100; i += 80) {
                    const h = 60 + Math.sin((i + cx * 0.2) * 0.01) * 40 + Math.sin((i + cx * 0.2) * 0.025) * 20;
                    ctx.lineTo(i, this.p2GroundY - 40 - h);
                }
                ctx.lineTo(canvas.width, this.p2GroundY - 40);
                ctx.closePath();
                ctx.fill();
                
                // Parallax trees
                ctx.fillStyle = '#3a7a3a';
                for (let i = 0; i < canvas.width + 50; i += 70) {
                    const tx = i + ((cx * 0.3) % 70);
                    const ty = this.p2GroundY - 50;
                    ctx.beginPath();
                    ctx.moveTo(tx, ty);
                    ctx.lineTo(tx - 15, ty + 30);
                    ctx.lineTo(tx + 15, ty + 30);
                    ctx.fill();
                }
                
                // === PLATFORMS ===
                this.platforms.forEach(plat => {
                    const sx = plat.x - cx;
                    const sy = plat.y;
                    if (sx + plat.w < -50 || sx > canvas.width + 50) return;
                    
                    if (plat.type === 'ground') {
                        // Grass top
                        ctx.fillStyle = '#4a8c3f';
                        ctx.fillRect(sx, sy, plat.w, 8);
                        // Dirt body
                        ctx.fillStyle = '#8B6914';
                        ctx.fillRect(sx, sy + 8, plat.w, plat.h - 8);
                        // Grass blades
                        ctx.fillStyle = '#5aa84f';
                        for (let gx = sx; gx < sx + plat.w; gx += 12) {
                            ctx.fillRect(gx, sy - 3, 3, 5);
                        }
                    } else {
                        // Floating platform - anime style with thick outline
                        ctx.fillStyle = '#7a8a9c';
                        ctx.strokeStyle = '#000';
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.roundRect(sx, sy, plat.w, plat.h, 4);
                        ctx.fill(); ctx.stroke();
                        // Highlight
                        ctx.fillStyle = 'rgba(255,255,255,0.3)';
                        ctx.fillRect(sx + 4, sy + 2, plat.w - 8, 4);
                    }
                });
                
                // === OKR COINS ===
                this.okrs.forEach(okr => {
                    if (okr.collected) return;
                    const sx = okr.x - cx;
                    const sy = okr.y;
                    if (sx < -30 || sx > canvas.width + 30) return;
                    const bounce = Math.sin(this.gameTime * 3 + okr.x * 0.1) * 5;
                    
                    // Shadow
                    ctx.fillStyle = 'rgba(0,0,0,0.15)';
                    ctx.beginPath();
                    ctx.ellipse(sx, sy + 18, 10, 4, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // Coin
                    ctx.fillStyle = '#ffd700';
                    ctx.strokeStyle = '#b8860b';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(sx, sy + bounce, 12, 0, Math.PI * 2);
                    ctx.fill(); ctx.stroke();
                    ctx.strokeStyle = '#daa520'; ctx.lineWidth = 1;
                    ctx.beginPath(); ctx.arc(sx, sy + bounce, 8, 0, Math.PI * 2); ctx.stroke();
                    ctx.fillStyle = '#000';
                    ctx.font = 'bold 8px Arial';
                    ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                    ctx.fillText('OKR', sx, sy + bounce);
                });
                
                // === CAR LIFT GOAL ===
                if (this.jrodHQ) {
                    const hx = this.jrodHQ.x - cx;
                    const hy = this.jrodHQ.y;
                    // Base
                    ctx.fillStyle = '#555';
                    ctx.fillRect(hx - 30, hy - 5, 60, 10);
                    // Pillars
                    ctx.fillStyle = '#888';
                    ctx.fillRect(hx - 28, hy - 80, 8, 80);
                    ctx.fillRect(hx + 20, hy - 80, 8, 80);
                    // Yellow stripes
                    ctx.fillStyle = '#ffcc00';
                    for (let i = 0; i < 4; i++) ctx.fillRect(hx - 20, hy - 15 - i * 18, 40, 5);
                    // Arrow
                    const ab = Math.sin(this.gameTime * 2) * 6;
                    ctx.fillStyle = '#00ff00';
                    ctx.beginPath();
                    ctx.moveTo(hx, hy - 90 + ab);
                    ctx.lineTo(hx - 10, hy - 78 + ab);
                    ctx.lineTo(hx + 10, hy - 78 + ab);
                    ctx.fill();
                    ctx.fillStyle = '#fff';
                    ctx.font = 'bold 12px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('CAR LIFT', hx, hy - 95 + ab);
                }
                
                // === AI WORKERS (robots) ===
                this.state.aiWorkers.forEach(worker => {
                    const wx = worker.x - cx;
                    const wy = this.p2GroundY - 30;
                    if (wx < -30 || wx > canvas.width + 30) return;
                    const bob = Math.sin(this.gameTime * 4 + worker.id) * 2;
                    // Body
                    ctx.fillStyle = '#6a6aff';
                    ctx.strokeStyle = '#000'; ctx.lineWidth = 2;
                    ctx.fillRect(wx - 10, wy - 12 + bob, 20, 24);
                    ctx.strokeRect(wx - 10, wy - 12 + bob, 20, 24);
                    // Head
                    ctx.fillStyle = '#8888ff';
                    ctx.beginPath(); ctx.arc(wx, wy - 20 + bob, 10, 0, Math.PI * 2);
                    ctx.fill(); ctx.stroke();
                    // Eyes
                    ctx.fillStyle = '#0f0';
                    ctx.fillRect(wx - 5, wy - 22 + bob, 4, 4);
                    ctx.fillRect(wx + 1, wy - 22 + bob, 4, 4);
                    // Antenna
                    ctx.strokeStyle = '#888'; ctx.lineWidth = 1;
                    ctx.beginPath(); ctx.moveTo(wx, wy - 30 + bob); ctx.lineTo(wx, wy - 38 + bob); ctx.stroke();
                    ctx.fillStyle = '#f00';
                    ctx.beginPath(); ctx.arc(wx, wy - 38 + bob, 3, 0, Math.PI * 2); ctx.fill();
                });
                
                // === PLAYER (blue car, side view) ===
                const px = this.player.x - cx;
                const py = this.player.y;
                const dir = this.player.facingRight ? 1 : -1;
                ctx.save();
                ctx.translate(px, py);
                ctx.scale(dir, 1);
                
                // Shadow
                ctx.fillStyle = 'rgba(0,0,0,0.15)';
                ctx.beginPath(); ctx.ellipse(0, 36, 22, 6, 0, 0, Math.PI * 2); ctx.fill();
                
                // Car body
                ctx.fillStyle = '#2266cc';
                ctx.strokeStyle = '#000'; ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.roundRect(-22, 8, 44, 22, 4);
                ctx.fill(); ctx.stroke();
                // Cabin
                ctx.fillStyle = '#3377dd';
                ctx.beginPath();
                ctx.roundRect(-14, -4, 28, 16, 3);
                ctx.fill(); ctx.stroke();
                // Windshield
                ctx.fillStyle = '#88ccff';
                ctx.strokeStyle = '#000'; ctx.lineWidth = 2;
                ctx.beginPath(); ctx.roundRect(6, -2, 12, 12, 2); ctx.fill(); ctx.stroke();
                // Rear window
                ctx.beginPath(); ctx.roundRect(-16, 0, 10, 10, 2); ctx.fill(); ctx.stroke();
                // Headlight
                ctx.fillStyle = '#ffffaa';
                ctx.beginPath(); ctx.arc(20, 16, 4, 0, Math.PI * 2); ctx.fill();
                // Taillight
                ctx.fillStyle = '#ff3333';
                ctx.beginPath(); ctx.arc(-20, 16, 3, 0, Math.PI * 2); ctx.fill();
                // Wheels
                ctx.fillStyle = '#222';
                ctx.beginPath(); ctx.arc(-12, 30, 7, 0, Math.PI * 2); ctx.fill();
                ctx.beginPath(); ctx.arc(12, 30, 7, 0, Math.PI * 2); ctx.fill();
                // Wheel hubs
                ctx.fillStyle = '#888';
                ctx.beginPath(); ctx.arc(-12, 30, 3, 0, Math.PI * 2); ctx.fill();
                ctx.beginPath(); ctx.arc(12, 30, 3, 0, Math.PI * 2); ctx.fill();
                // Driver head
                ctx.fillStyle = '#ffcc99';
                ctx.beginPath(); ctx.arc(2, 2, 5, 0, Math.PI * 2); ctx.fill();
                ctx.strokeStyle = '#000'; ctx.lineWidth = 1; ctx.stroke();
                
                ctx.restore();
                
                // === HUD ===
                ctx.fillStyle = 'rgba(0,0,0,0.6)';
                ctx.fillRect(10, 10, 260, 55);
                ctx.strokeStyle = '#0ff'; ctx.lineWidth = 1;
                ctx.strokeRect(10, 10, 260, 55);
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 16px monospace';
                ctx.textAlign = 'left';
                ctx.fillText(`OKR: ${this.state.okrsCollected} / ${this.currentLevelData.okrGoal}`, 20, 32);
                ctx.font = '13px monospace';
                ctx.fillStyle = '#aaf';
                ctx.fillText(`MP: ${Math.floor(this.state.currencies.mp)} | Workers: ${this.state.aiWorkers.length}`, 20, 52);
                
                if (this.state.okrsCollected >= this.currentLevelData.okrGoal && this.jrodHQ) {
                    ctx.fillStyle = '#00ff00';
                    ctx.font = 'bold 20px monospace';
                    ctx.textAlign = 'center';
                    ctx.fillText('â–¶ Jump to the Car Lift! â—€', canvas.width / 2, canvas.height - 20);
                }
                
                // Draw spectators
                this.drawAnimeSpectators();
            }
            
            drawAnimeBackground() {
                const ctx = this.ctx;
                const canvas = this.canvas;
                
                // Gradient sky (anime style)
                const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
                gradient.addColorStop(0, '#87CEEB');
                gradient.addColorStop(0.5, '#FFB6C1');
                gradient.addColorStop(1, '#FFA07A');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Simple puffy anime clouds
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 3;
                const cloudTime = this.gameTime * 10;
                for (let i = 0; i < 5; i++) {
                    const x = ((cloudTime + i * 200) % (canvas.width + 200)) - 100;
                    const y = 50 + i * 80;
                    this.drawCloud(x, y);
                }
            }
            
            drawCloud(x, y) {
                const ctx = this.ctx;
                ctx.beginPath();
                ctx.arc(x, y, 30, 0, Math.PI * 2);
                ctx.arc(x + 25, y, 35, 0, Math.PI * 2);
                ctx.arc(x + 50, y, 30, 0, Math.PI * 2);
                ctx.arc(x + 25, y - 20, 25, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
            }
            
            drawAnimeTile(x, y, color) {
                const ctx = this.ctx;
                
                // Draw with thick black outline
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 4;
                ctx.fillStyle = color;
                
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(x + 32, y + 16);
                ctx.lineTo(x, y + 32);
                ctx.lineTo(x - 32, y + 16);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
            }
            
            drawAnimeCharacter(x, y, keys) {
                const ctx = this.ctx;
                const charW = 48;
                const charH = 72;
                const charX = x - charW / 2;
                const charY = y - charH / 2;
                
                // Black outline
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 4;
                ctx.strokeRect(charX - 2, charY - 2, charW + 4, charH + 4);
                
                // Character body
                ctx.fillStyle = '#E21A2C';
                ctx.fillRect(charX, charY, charW, charH);
                
                // Anime eyes (large and expressive)
                ctx.fillStyle = '#FFFFFF';
                ctx.beginPath();
                ctx.arc(charX + 12, charY + 20, 8, 0, Math.PI * 2);
                ctx.arc(charX + 36, charY + 20, 8, 0, Math.PI * 2);
                ctx.fill();
                
                // Pupils
                ctx.fillStyle = '#000000';
                ctx.beginPath();
                ctx.arc(charX + 12, charY + 20, 4, 0, Math.PI * 2);
                ctx.arc(charX + 36, charY + 20, 4, 0, Math.PI * 2);
                ctx.fill();
                
                // Mouth (simple)
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(charX + 24, charY + 35, 10, 0, Math.PI);
                ctx.stroke();
            }
            
            drawAnimeWorker(x, y) {
                const ctx = this.ctx;
                const size = 32;
                
                // Outline
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 3;
                ctx.fillStyle = '#ff00ff';
                ctx.fillRect(x - size/2, y - size/2, size, size);
                ctx.strokeRect(x - size/2, y - size/2, size, size);
                
                // Simple face
                ctx.fillStyle = '#FFFFFF';
                ctx.fillRect(x - 8, y - 8, 4, 4);
                ctx.fillRect(x + 4, y - 8, 4, 4);
            }
            
            drawSpeedLines(x, y) {
                const ctx = this.ctx;
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.lineWidth = 4;
                
                for (let i = 0; i < 6; i++) {
                    const offsetX = x - 60 - (i * 20);
                    const offsetY = y - 20 + (Math.random() * 60);
                    ctx.beginPath();
                    ctx.moveTo(offsetX, offsetY);
                    ctx.lineTo(offsetX - 50, offsetY);
                    ctx.stroke();
                }
            }
            
            drawAnimeSparkles(x, y, time) {
                const ctx = this.ctx;
                ctx.fillStyle = '#FFD700';
                
                for (let i = 0; i < 4; i++) {
                    const angle = (time * 50 + i * 90) % 360;
                    const rad = angle * Math.PI / 180;
                    const dist = 25 + Math.sin(time * 3 + i) * 8;
                    const sx = x + Math.cos(rad) * dist;
                    const sy = y + Math.sin(rad) * dist;
                    
                    // 4-pointed star
                    ctx.save();
                    ctx.translate(sx, sy);
                    ctx.rotate(angle * Math.PI / 180);
                    ctx.beginPath();
                    ctx.moveTo(0, -6);
                    ctx.lineTo(1.5, -1.5);
                    ctx.lineTo(6, 0);
                    ctx.lineTo(1.5, 1.5);
                    ctx.lineTo(0, 6);
                    ctx.lineTo(-1.5, 1.5);
                    ctx.lineTo(-6, 0);
                    ctx.lineTo(-1.5, -1.5);
                    ctx.closePath();
                    ctx.fill();
                    ctx.restore();
                }
            }
            
            drawIsoTile(x, y, z, color, offsetX, offsetY) {
                const ctx = this.ctx;
                const pos = this.toIso(x - this.player.x, y, z - this.player.z);
                
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.moveTo(offsetX + pos.x, offsetY + pos.y);
                ctx.lineTo(offsetX + pos.x + 32, offsetY + pos.y + 16);
                ctx.lineTo(offsetX + pos.x, offsetY + pos.y + 32);
                ctx.lineTo(offsetX + pos.x - 32, offsetY + pos.y + 16);
                ctx.closePath();
                ctx.fill();
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 1;
                ctx.stroke();
            }
            
            toIso(x, y, z) {
                return {
                    x: (x - z) * 32,
                    y: (x + z) * 16 - y * 24
                };
            }
            
            drawAnimeSpectators() {
                const ctx = this.ctx;
                
                this.currentLevelSpectators.forEach(spectator => {
                    // Decrease speech timer
                    if (spectator.speechTimer > 0) {
                        spectator.speechTimer--;
                        if (spectator.speechTimer === 0) {
                            spectator.speechBubble = '';
                        }
                    }
                    
                    // Character body (anime style)
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 3;
                    ctx.fillStyle = spectator.color;
                    ctx.fillRect(spectator.x, spectator.y, 40, 60);
                    ctx.strokeRect(spectator.x, spectator.y, 40, 60);
                    
                    // Big anime eyes
                    ctx.fillStyle = '#FFFFFF';
                    ctx.beginPath();
                    ctx.arc(spectator.x + 12, spectator.y + 20, 6, 0, Math.PI * 2);
                    ctx.arc(spectator.x + 28, spectator.y + 20, 6, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.fillStyle = '#000';
                    ctx.beginPath();
                    ctx.arc(spectator.x + 12, spectator.y + 20, 3, 0, Math.PI * 2);
                    ctx.arc(spectator.x + 28, spectator.y + 20, 3, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Name label
                    ctx.fillStyle = '#000';
                    ctx.font = 'bold 10px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(spectator.name.split(' ')[0], spectator.x + 20, spectator.y + 75);
                    
                    // Speech bubble
                    if (spectator.speechBubble) {
                        ctx.fillStyle = '#FFF';
                        ctx.strokeStyle = '#000';
                        ctx.lineWidth = 2;
                        const bx = spectator.x + 50, by = spectator.y - 30;
                        ctx.fillRect(bx, by, 100, 30);
                        ctx.strokeRect(bx, by, 100, 30);
                        
                        // Triangle pointer
                        ctx.beginPath();
                        ctx.moveTo(bx, by + 20);
                        ctx.lineTo(bx - 10, by + 15);
                        ctx.lineTo(bx, by + 10);
                        ctx.closePath();
                        ctx.fill();
                        ctx.stroke();
                        
                        ctx.fillStyle = '#000';
                        ctx.font = '12px Arial';
                        ctx.textAlign = 'left';
                        ctx.fillText(spectator.speechBubble, bx + 5, by + 18);
                    }
                });
            }
            
            drawPixelSpectators() {
                const ctx = this.ctx;
                const canvas = this.canvas;
                const s = 5; // bigger pixel scale
                const count = this.currentLevelSpectators.length;
                if (count === 0) return;
                
                // Arrange spectators along the bottom edge
                const totalWidth = canvas.width - 40;
                const spacing = Math.min(60, totalWidth / count);
                const startX = (canvas.width - spacing * (count - 1)) / 2;
                const baseY = canvas.height - 70;
                
                this.currentLevelSpectators.forEach((spectator, i) => {
                    const cx = Math.floor(startX + i * spacing);
                    const cy = baseY;
                    const bobble = Math.sin(this.gameTime * 2 + i * 1.3) * 2;
                    const col = spectator.color || '#888';
                    
                    // Shadow
                    ctx.fillStyle = 'rgba(0,0,0,0.3)';
                    ctx.fillRect(cx - 3*s, cy + 5*s + 2, 6*s, s);
                    
                    // Legs
                    const legKick = Math.sin(this.gameTime * 3 + i) * s * 0.3;
                    ctx.fillStyle = '#334';
                    ctx.fillRect(cx - 2*s, cy + 3*s, s, 2*s + legKick);
                    ctx.fillRect(cx + 1*s, cy + 3*s, s, 2*s - legKick);
                    
                    // Shoes
                    ctx.fillStyle = '#222';
                    ctx.fillRect(cx - 2*s - 1, cy + 5*s + legKick, s + 2, s);
                    ctx.fillRect(cx + 1*s - 1, cy + 5*s - legKick, s + 2, s);
                    
                    // Body
                    ctx.fillStyle = col;
                    ctx.fillRect(cx - 2*s, cy + bobble, 4*s, 3*s);
                    // Shirt highlight
                    ctx.fillStyle = 'rgba(255,255,255,0.2)';
                    ctx.fillRect(cx - s, cy + bobble, 2*s, s);
                    
                    // Arms
                    const wave = Math.sin(this.gameTime * 4 + i * 2);
                    ctx.fillStyle = col;
                    ctx.fillRect(cx - 3*s, cy + bobble + (wave > 0.5 ? -s : 0), s, 2*s);
                    ctx.fillRect(cx + 2*s, cy + bobble, s, 2*s);
                    // Hands
                    ctx.fillStyle = '#ffcc99';
                    ctx.fillRect(cx - 3*s, cy + bobble + 2*s + (wave > 0.5 ? -s : 0), s, s);
                    ctx.fillRect(cx + 2*s, cy + bobble + 2*s, s, s);
                    
                    // Head
                    ctx.fillStyle = '#ffcc99';
                    ctx.fillRect(cx - 1.5*s, cy - 3*s + bobble, 3*s, 3*s);
                    
                    // Hair
                    const hairColors = ['#331100', '#ffdd44', '#884422', '#222', '#cc4400', '#666'];
                    ctx.fillStyle = hairColors[i % hairColors.length];
                    ctx.fillRect(cx - 1.5*s, cy - 3.5*s + bobble, 3*s, s);
                    ctx.fillRect(cx - 2*s, cy - 3*s + bobble, s*0.5, 2*s);
                    
                    // Eyes (blink)
                    const blink = Math.sin(this.gameTime * 0.8 + i * 5) > 0.95;
                    ctx.fillStyle = '#000';
                    if (!blink) {
                        ctx.fillRect(cx - s, cy - 2*s + bobble, s*0.7, s*0.7);
                        ctx.fillRect(cx + s*0.3, cy - 2*s + bobble, s*0.7, s*0.7);
                    } else {
                        ctx.fillRect(cx - s, cy - 1.5*s + bobble, s*0.7, 2);
                        ctx.fillRect(cx + s*0.3, cy - 1.5*s + bobble, s*0.7, 2);
                    }
                    
                    // Mouth
                    ctx.fillRect(cx - s*0.5, cy - 0.5*s + bobble, s, 2);
                    
                    // Name tag with background
                    const name = spectator.name || '';
                    ctx.font = 'bold 10px monospace';
                    ctx.textAlign = 'center';
                    const tw = ctx.measureText(name).width;
                    ctx.fillStyle = 'rgba(0,0,0,0.7)';
                    ctx.fillRect(cx - tw/2 - 3, cy - 5*s + bobble - 2, tw + 6, 14);
                    ctx.fillStyle = '#0ff';
                    ctx.fillText(name, cx, cy - 4*s + bobble + 6);
                });
            }
            
            updatePhase3(dt) {
                // Automation - mostly passive
                let productionRate = 1; // Base rate: 1 OKR/sec always
                let acRegenRate = 1;    // Base AC regen: 1/sec
                let globalMult = 1;     // Multiplier nodes stack multiplicatively
                
                this.automationNodes.forEach(node => {
                    if (node.mult && node.mult > 1) {
                        globalMult *= node.mult; // Multipliers multiply everything
                    } else if (node.acRate && node.acRate > 0) {
                        acRegenRate += node.acRate; // Collectors boost AC regen
                    } else {
                        productionRate += node.rate; // Processors/Synthesizers add OKR/s
                    }
                });
                
                // AI workers contribute
                productionRate += this.state.aiWorkers.length * 0.5;
                
                // Apply global multiplier to both rates
                productionRate *= globalMult;
                acRegenRate *= globalMult;
                
                // Auto-collect OKRs
                const okrsThisFrame = productionRate * dt;
                this.state.okrsCollected += okrsThisFrame;
                this.state.totalOKRs += okrsThisFrame;
                
                // AC regenerates based on Collectors + base
                this.state.currencies.ac += acRegenRate * dt;
                
                // Check completion
                if (this.state.okrsCollected >= this.currentLevelData.okrGoal) {
                    this.completeLevel();
                }
                
                this.updateUI();
                this.renderPhase3(productionRate, acRegenRate, globalMult);
            }
            
            renderPhase3(rate, acRate, mult) {
                const ctx = this.ctx;
                const canvas = this.canvas;
                acRate = acRate || 1;
                mult = mult || 1;
                
                // CRITICAL: Pixel-perfect rendering
                ctx.imageSmoothingEnabled = false;
                
                // Dark pixel background
                ctx.fillStyle = '#0a0a0a';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Pixel grid (every 3 pixels)
                const pixelScale = 3;
                ctx.strokeStyle = 'rgba(0, 200, 255, 0.15)';
                ctx.lineWidth = 1;
                for (let i = 0; i < canvas.width; i += 60) {
                    ctx.beginPath();
                    ctx.moveTo(i, 0);
                    ctx.lineTo(i, canvas.height);
                    ctx.stroke();
                }
                for (let i = 0; i < canvas.height; i += 60) {
                    ctx.beginPath();
                    ctx.moveTo(0, i);
                    ctx.lineTo(canvas.width, i);
                    ctx.stroke();
                }
                
                // Draw automation nodes as pixel blocks
                // Draw central OKR Factory first (behind connections)
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                this.drawOKRFactory(centerX, centerY);
                
                // Draw connections from each node back to central factory, then the nodes on top
                this.automationNodes.forEach((node, i) => {
                    this.drawPixelConnection(node.x, node.y, centerX, centerY, node.name);
                    const label = node.acRate > 0 ? node.acRate : (node.mult > 1 ? node.mult : node.rate);
                    this.drawPixelNode(node.x, node.y, label, node.name);
                });
                
                // Draw central HUD â€” compact, inside the box
                const progress = Math.min(1, this.state.okrsCollected / this.currentLevelData.okrGoal);
                const size = 130;
                const boxTop = centerY - size/2;
                const boxLeft = centerX - size/2;
                
                // Dark box background
                ctx.fillStyle = 'rgba(0, 0, 0, 0.75)';
                ctx.fillRect(Math.floor(boxLeft), Math.floor(boxTop), size, size);
                
                // Outer border
                ctx.strokeStyle = 'rgba(0, 255, 255, 0.4)';
                ctx.lineWidth = 4;
                ctx.strokeRect(Math.floor(boxLeft), Math.floor(boxTop), size, size);
                
                // Progress fill from bottom
                const fillHeight = Math.floor(size * progress);
                ctx.fillStyle = 'rgba(0, 255, 255, 0.15)';
                ctx.fillRect(
                    Math.floor(boxLeft + 4),
                    Math.floor(boxTop + size - fillHeight - 4),
                    size - 8,
                    fillHeight
                );
                
                // Big percentage in center
                ctx.fillStyle = '#0ff';
                ctx.font = 'bold 36px monospace';
                ctx.textAlign = 'center';
                ctx.fillText(`${Math.floor(progress * 100)}%`, Math.floor(centerX), Math.floor(centerY + 8));
                
                // "OKR Factory" label above box
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 14px monospace';
                ctx.fillText('OKR FACTORY', Math.floor(centerX), Math.floor(boxTop - 8));
                
                // Stats row below box
                const belowY = boxTop + size + 20;
                ctx.font = 'bold 16px monospace';
                ctx.fillStyle = '#0ff';
                ctx.fillText(`${Math.floor(rate)} OKR/s`, Math.floor(centerX - 100), Math.floor(belowY));
                ctx.fillStyle = '#22cc44';
                ctx.fillText(`${acRate.toFixed(1)} AC/s`, Math.floor(centerX), Math.floor(belowY));
                ctx.fillStyle = '#ffcc00';
                ctx.fillText(`AC: ${Math.floor(this.state.currencies.ac)}`, Math.floor(centerX + 100), Math.floor(belowY));
                
                if (mult > 1) {
                    ctx.fillStyle = '#dd88ff';
                    ctx.fillText(`x${mult.toFixed(1)} mult`, Math.floor(centerX), Math.floor(belowY + 20));
                }
                
                // Help text
                ctx.fillStyle = '#666';
                ctx.font = '12px monospace';
                ctx.fillText(
                    'Click to place buildings. Collectors â†’ AC | Multipliers â†’ all rates',
                    Math.floor(centerX),
                    Math.floor(belowY + 42)
                );
                ctx.fillText(
                    `Nodes: ${this.automationNodes.length} | Workers: ${this.state.aiWorkers.length}`,
                    Math.floor(centerX),
                    Math.floor(belowY + 58)
                );
                
                // CRT scanlines effect
                this.drawScanlines();
                
                // Draw spectators
                this.drawPixelSpectators();
            }
            
            drawOKRFactory(cx, cy) {
                const ctx = this.ctx;
                const s = 4;
                const pulse = Math.sin(this.gameTime * 2) * 0.1 + 0.9;
                
                // Outer glow
                ctx.fillStyle = `rgba(0, 255, 255, ${0.08 * pulse})`;
                ctx.beginPath(); ctx.arc(cx, cy, 80, 0, Math.PI * 2); ctx.fill();
                
                // Factory base (pixel chimney shape)
                this._pxRect(ctx, cx - 8*s, cy + 4*s, 16*s, 3*s, '#334');
                // Main building
                this._pxRect(ctx, cx - 6*s, cy - 2*s, 12*s, 6*s, '#445');
                // Chimney left
                this._pxRect(ctx, cx - 5*s, cy - 5*s, 3*s, 3*s, '#556');
                // Chimney right
                this._pxRect(ctx, cx + 2*s, cy - 5*s, 3*s, 3*s, '#556');
                // Smoke puffs (animated)
                const smokeT = this.gameTime * 1.5;
                ctx.fillStyle = 'rgba(150,150,170,0.3)';
                ctx.beginPath(); ctx.arc(cx - 3.5*s, cy - 6*s - (smokeT % 3) * 4, 5, 0, Math.PI * 2); ctx.fill();
                ctx.beginPath(); ctx.arc(cx + 3.5*s, cy - 6*s - ((smokeT + 1) % 3) * 4, 4, 0, Math.PI * 2); ctx.fill();
                // Windows (glowing)
                const winGlow = pulse > 0.95 ? '#0ff' : '#088';
                this._pxRect(ctx, cx - 4*s, cy - 1*s, 2*s, 2*s, winGlow);
                this._pxRect(ctx, cx + 2*s, cy - 1*s, 2*s, 2*s, winGlow);
                this._pxRect(ctx, cx - 1*s, cy + 1*s, 2*s, 2*s, winGlow);
                // Door
                this._pxRect(ctx, cx - 1*s, cy + 3*s, 2*s, 3*s, '#222');
            }
            
            drawPixelNode(x, y, rate, name) {
                const ctx = this.ctx;
                const s = 4; // pixel scale for pixel-art look
                const bx = Math.floor(x);
                const by = Math.floor(y);
                const pulse = Math.sin(this.gameTime * 3) * 0.15 + 0.85;
                
                if (name === 'Collector') {
                    // Green funnel/hopper shape
                    const c1 = '#22cc44', c2 = '#115522', hi = '#66ff88';
                    // Glow
                    ctx.fillStyle = `rgba(34, 204, 68, ${0.25 * pulse})`;
                    ctx.beginPath(); ctx.arc(bx, by, 28, 0, Math.PI * 2); ctx.fill();
                    // Base plate
                    this._pxRect(ctx, bx - 5*s, by + 2*s, 10*s, 2*s, c2);
                    // Hopper body (trapezoid via rects)
                    this._pxRect(ctx, bx - 4*s, by - 1*s, 8*s, 3*s, c1);
                    this._pxRect(ctx, bx - 5*s, by - 3*s, 10*s, 2*s, c1);
                    this._pxRect(ctx, bx - 6*s, by - 5*s, 12*s, 2*s, c1);
                    // Highlight edge
                    this._pxRect(ctx, bx - 6*s, by - 5*s, 2*s, 2*s, hi);
                    this._pxRect(ctx, bx - 5*s, by - 3*s, 2*s, 2*s, hi);
                    // Funnel opening
                    this._pxRect(ctx, bx - 2*s, by + 1*s, 4*s, 1*s, c2);
                    // Spinning coin inside (animated)
                    const coinW = Math.abs(Math.cos(this.gameTime * 4)) * 3 * s;
                    ctx.fillStyle = '#ffd700';
                    ctx.fillRect(bx - coinW/2, by - 2*s, coinW, 2*s);
                } else if (name === 'Processor') {
                    // Blue circuit board / chip
                    const c1 = '#2266dd', c2 = '#113388', hi = '#55aaff', pin = '#88ccff';
                    ctx.fillStyle = `rgba(34, 102, 221, ${0.25 * pulse})`;
                    ctx.beginPath(); ctx.arc(bx, by, 30, 0, Math.PI * 2); ctx.fill();
                    // Chip body
                    this._pxRect(ctx, bx - 5*s, by - 5*s, 10*s, 10*s, c1);
                    this._pxRect(ctx, bx - 4*s, by - 4*s, 8*s, 8*s, c2);
                    // Inner die
                    this._pxRect(ctx, bx - 2*s, by - 2*s, 4*s, 4*s, hi);
                    // Blinking core
                    ctx.fillStyle = pulse > 0.9 ? '#ffffff' : '#55aaff';
                    ctx.fillRect(bx - s/2, by - s/2, s, s);
                    // Pins on each side
                    for (let i = -2; i <= 2; i++) {
                        this._pxRect(ctx, bx + i*2*s - s/2, by - 6*s, s, s, pin);
                        this._pxRect(ctx, bx + i*2*s - s/2, by + 5*s, s, s, pin);
                        this._pxRect(ctx, bx - 6*s, by + i*2*s - s/2, s, s, pin);
                        this._pxRect(ctx, bx + 5*s, by + i*2*s - s/2, s, s, pin);
                    }
                    // Circuit traces
                    ctx.strokeStyle = pin; ctx.lineWidth = 1;
                    ctx.strokeRect(bx - 3*s, by - 3*s, 6*s, 6*s);
                } else if (name === 'Multiplier') {
                    // Purple crystal / prism shape
                    const c1 = '#aa44ff', c2 = '#661199', hi = '#dd88ff', spark = '#ffccff';
                    ctx.fillStyle = `rgba(170, 68, 255, ${0.3 * pulse})`;
                    ctx.beginPath(); ctx.arc(bx, by, 32, 0, Math.PI * 2); ctx.fill();
                    // Crystal base
                    this._pxRect(ctx, bx - 4*s, by + 2*s, 8*s, 2*s, c2);
                    // Main crystal body (diamond shape via stacked rects)
                    this._pxRect(ctx, bx - 1*s, by + 2*s, 2*s, 1*s, c1);
                    this._pxRect(ctx, bx - 2*s, by + 0*s, 4*s, 2*s, c1);
                    this._pxRect(ctx, bx - 3*s, by - 3*s, 6*s, 3*s, c1);
                    this._pxRect(ctx, bx - 2*s, by - 5*s, 4*s, 2*s, c1);
                    this._pxRect(ctx, bx - 1*s, by - 6*s, 2*s, 1*s, hi);
                    // Highlight facets
                    this._pxRect(ctx, bx - 3*s, by - 2*s, 1*s, 2*s, hi);
                    this._pxRect(ctx, bx - 2*s, by - 4*s, 1*s, 2*s, hi);
                    // Sparkle particles
                    const sparkles = [[3, -4], [-4, -1], [4, 2], [-3, -5]];
                    sparkles.forEach(([sx, sy]) => {
                        const flicker = Math.sin(this.gameTime * 5 + sx * sy) > 0.3;
                        if (flicker) this._pxRect(ctx, bx + sx*s, by + sy*s, s, s, spark);
                    });
                } else if (name === 'Synthesizer') {
                    // Red/orange reactor with spinning energy ring
                    const c1 = '#ff4422', c2 = '#991100', hi = '#ff8844', core = '#ffcc00';
                    ctx.fillStyle = `rgba(255, 68, 34, ${0.3 * pulse})`;
                    ctx.beginPath(); ctx.arc(bx, by, 36, 0, Math.PI * 2); ctx.fill();
                    // Reactor shell (octagon-ish via rects)
                    this._pxRect(ctx, bx - 3*s, by - 5*s, 6*s, 10*s, c2);
                    this._pxRect(ctx, bx - 5*s, by - 3*s, 10*s, 6*s, c2);
                    this._pxRect(ctx, bx - 4*s, by - 4*s, 8*s, 8*s, c1);
                    // Inner chamber
                    this._pxRect(ctx, bx - 2*s, by - 2*s, 4*s, 4*s, '#220000');
                    // Pulsing core
                    const coreSize = Math.floor(1 + pulse * 2);
                    ctx.fillStyle = core;
                    ctx.fillRect(bx - coreSize*s/2, by - coreSize*s/2, coreSize*s, coreSize*s);
                    // Highlight vents
                    this._pxRect(ctx, bx - 4*s, by - 1*s, 1*s, 2*s, hi);
                    this._pxRect(ctx, bx + 3*s, by - 1*s, 1*s, 2*s, hi);
                    this._pxRect(ctx, bx - 1*s, by - 4*s, 2*s, 1*s, hi);
                    this._pxRect(ctx, bx - 1*s, by + 3*s, 2*s, 1*s, hi);
                    // Energy ring (rotating dots)
                    const ringR = 5 * s;
                    for (let a = 0; a < 8; a++) {
                        const ang = this.gameTime * 2 + a * Math.PI / 4;
                        const rx = bx + Math.cos(ang) * ringR;
                        const ry = by + Math.sin(ang) * ringR;
                        ctx.fillStyle = a % 2 === 0 ? '#ffcc00' : '#ff6600';
                        ctx.fillRect(Math.floor(rx) - s/2, Math.floor(ry) - s/2, s, s);
                    }
                } else {
                    // Fallback gold block
                    ctx.fillStyle = '#ffd700';
                    ctx.fillRect(bx - 12, by - 12, 24, 24);
                    ctx.strokeStyle = '#000'; ctx.lineWidth = 3;
                    ctx.strokeRect(bx - 12, by - 12, 24, 24);
                }
                
                // Name label
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 10px monospace';
                ctx.textAlign = 'center';
                ctx.fillText(name, bx, by + 32);
                // Rate text â€” context-aware
                ctx.font = 'bold 12px monospace';
                if (name === 'Collector') {
                    ctx.fillStyle = '#66ff88';
                    ctx.fillText(`+${rate} AC/s`, bx, by + 44);
                } else if (name === 'Multiplier') {
                    ctx.fillStyle = '#dd88ff';
                    ctx.fillText(`x${rate}`, bx, by + 44);
                } else {
                    ctx.fillStyle = '#aaffaa';
                    ctx.fillText(`+${rate} OKR/s`, bx, by + 44);
                }
            }
            
            _pxRect(ctx, x, y, w, h, color) {
                ctx.fillStyle = color;
                ctx.fillRect(Math.floor(x), Math.floor(y), Math.floor(w), Math.floor(h));
            }
            
            drawPixelConnection(x1, y1, x2, y2) {
                const ctx = this.ctx;
                
                // Pixelated line
                ctx.strokeStyle = 'rgba(0, 255, 255, 0.6)';
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.moveTo(Math.floor(x1), Math.floor(y1));
                ctx.lineTo(Math.floor(x2), Math.floor(y2));
                ctx.stroke();
                
                // Animated pixel dots
                const dist = Math.sqrt((x2-x1)**2 + (y2-y1)**2);
                const steps = Math.floor(dist / 30);
                const animOffset = (this.gameTime * 50) % 30;
                
                ctx.fillStyle = '#00ffff';
                for (let i = 0; i < steps; i++) {
                    const t = (i * 30 + animOffset) / dist;
                    if (t <= 1) {
                        const px = Math.floor(x1 + (x2 - x1) * t);
                        const py = Math.floor(y1 + (y2 - y1) * t);
                        ctx.fillRect(px - 3, py - 3, 6, 6);
                    }
                }
            }
            
            drawScanlines() {
                const ctx = this.ctx;
                const canvas = this.canvas;
                
                ctx.globalAlpha = 0.15;
                ctx.fillStyle = '#000000';
                for (let y = 0; y < canvas.height; y += 6) {
                    ctx.fillRect(0, y, canvas.width, 2);
                }
                ctx.globalAlpha = 1.0;
            }
            
            formatNumber(num) {
                if (num >= 1000000) return (num / 1000000).toFixed(1) + 'M';
                if (num >= 1000) return (num / 1000).toFixed(1) + 'K';
                return Math.floor(num).toString();
            }
            
            collectOKR() {
                this.state.okrsCollected++;
                this.state.totalOKRs++;
                this.updateUI();
                
                // Make spectators react
                this.currentLevelSpectators.forEach(spec => {
                    if (spec.cheer) spec.cheer();
                    if (spec.react) spec.react('okr');
                });
            }
            
            respawnPlayer() {
                // Reset player position to start
                this.player.position.set(0, 2, 0);
                this.playerVelocity = { x: 0, y: 0, z: 0 };
                this.isGrounded = false;
                console.log('Player respawned after falling');
            }
            
            playLiftAnimation() {
                this.liftAnimating = true;
                this.paused = true;
                
                // Move car onto the lift
                const liftPos = this.jrodHQ.position.clone();
                this.player.position.set(liftPos.x, liftPos.y + 0.5, liftPos.z);
                this.player.rotation.y = 0;
                this.playerVelocity = { x: 0, y: 0, z: 0 };
                
                // Find the lift platform inside the group
                let liftPlatformMesh = null;
                this.jrodHQ.traverse(child => {
                    if (child.name === 'liftPlatform') liftPlatformMesh = child;
                });
                
                const startY = this.player.position.y;
                const liftHeight = 4;
                const duration = 1500;
                const startTime = Date.now();
                
                const animateLift = () => {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    // Ease-out curve
                    const ease = 1 - Math.pow(1 - progress, 3);
                    const currentY = startY + liftHeight * ease;
                    
                    this.player.position.y = currentY;
                    if (liftPlatformMesh) {
                        liftPlatformMesh.position.y = 0.3 + liftHeight * ease;
                    }
                    
                    // Keep rendering during animation
                    this.camera.position.x = this.player.position.x + this.cameraOffset.x;
                    this.camera.position.y = this.player.position.y + this.cameraOffset.y;
                    this.camera.position.z = this.player.position.z + this.cameraOffset.z;
                    this.camera.lookAt(this.player.position);
                    this.renderer.render(this.scene, this.camera);
                    
                    if (progress < 1) {
                        requestAnimationFrame(animateLift);
                    } else {
                        // Animation done â€” complete the level
                        setTimeout(() => {
                            this.paused = false;
                            this.liftAnimating = false;
                            this.completeLevel();
                        }, 500);
                    }
                };
                
                animateLift();
            }
            
            completeLevel() {
                if (this.levelCompleting) return;
                this.levelCompleting = true;
                
                const config = this.currentLevelData;
                
                // Make spectators react to completion
                this.currentLevelSpectators.forEach(spec => {
                    if (spec.cheer) spec.cheer();
                    if (spec.react) spec.react('complete');
                });
                
                // Award currency
                const currencyType = config.currency;
                this.state.currencies[currencyType] += config.reward;
                
                // Mark as completed
                if (!this.state.completedLevels.includes(this.state.currentLevel)) {
                    this.state.completedLevels.push(this.state.currentLevel);
                }
                
                // Unlock abilities
                if (config.unlock === 'sprint') {
                    this.state.playerStats.sprint = 1;
                }
                if (config.unlock === 'doubleJump') {
                    this.canDoubleJump = true;
                }
                
                // Check for evolution
                if (config.evolution === 1) {
                    this.triggerEvolution1();
                } else if (config.evolution === 2) {
                    this.triggerEvolution2();
                } else if (config.final) {
                    this.showVictoryScreen();
                } else {
                    // Next level
                    console.log(`Level ${this.state.currentLevel} complete! Loading level ${this.state.currentLevel + 1}`);
                    setTimeout(() => {
                        this.loadLevel(this.state.currentLevel + 1);
                    }, 1000);
                }
                
                this.saveGame();
            }
            
            triggerEvolution1() {
                this.paused = true;
                
                const cutscene = document.getElementById('cutscene');
                const text = document.getElementById('cutsceneText');
                
                cutscene.style.display = 'flex';
                cutscene.className = '';
                cutscene.style.background = 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)';
                text.style.color = '#fff';
                text.style.fontSize = '48px';
                text.style.textShadow = '0 0 20px rgba(255,255,255,0.8)';
                
                const messages = [
                    'â­ EVOLUTION INITIATED â­',
                    'Manual processes... OBSOLETE',
                    'Transitioning to ANIME DIMENSION',
                    'âœ¨ PHASE 2: TEAM MANAGER MODE âœ¨'
                ];
                
                let i = 0;
                const showMessage = () => {
                    if (i < messages.length) {
                        text.textContent = messages[i];
                        
                        // Flash effect on last message
                        if (i === messages.length - 1) {
                            cutscene.style.animation = 'flash 0.5s infinite';
                        }
                        
                        i++;
                        setTimeout(showMessage, 2500);
                    } else {
                        // Dramatic transition effect
                        cutscene.style.animation = 'none';
                        text.textContent = 'ðŸŒ¸ ENTERING ANIME WORLD ðŸŒ¸';
                        
                        setTimeout(() => {
                            // Apply evolution changes
                            this.state.currencies.mp = 0;
                            this.state.currencies.dp = 0;
                            
                            // Keep 50% of stats
                            Object.keys(this.state.playerStats).forEach(key => {
                                if (typeof this.state.playerStats[key] === 'number') {
                                    this.state.playerStats[key] *= 0.5;
                                }
                            });
                            
                            cutscene.style.display = 'none';
                            this.setupPhase2();
                            this.loadLevel(6);
                            this.paused = false;
                        }, 2000);
                    }
                };
                
                showMessage();
            }
            
            triggerEvolution2() {
                this.paused = true;
                
                const cutscene = document.getElementById('cutscene');
                const text = document.getElementById('cutsceneText');
                
                cutscene.style.display = 'flex';
                cutscene.className = 'glitch';
                cutscene.style.background = '#000';
                text.style.color = '#0ff';
                text.style.fontSize = '42px';
                text.style.textShadow = '0 0 10px #0ff, 0 0 20px #0ff';
                
                const messages = [
                    'âš  SYSTEM OVERLOAD âš ',
                    'Entering RETRO DIMENSION',
                    'Manual control... UNNECESSARY',
                    'â–ˆ PHASE 3: AUTOMATION SINGULARITY â–ˆ'
                ];
                
                let i = 0;
                let pixelation = 1;
                
                const showMessage = () => {
                    if (i < messages.length) {
                        text.textContent = messages[i];
                        
                        // Progressive pixelation effect
                        if (i > 1) {
                            this.ctx.imageSmoothingEnabled = false;
                            pixelation += 0.3;
                        }
                        
                        i++;
                        setTimeout(showMessage, 2500);
                    } else {
                        // Pixelation transition
                        text.textContent = 'â–“â–’â–‘ ENTERING THE GRID â–‘â–’â–“';
                        
                        const pixelateInterval = setInterval(() => {
                            pixelation += 0.2;
                            
                            if (pixelation >= 3) {
                                clearInterval(pixelateInterval);
                                
                                setTimeout(() => {
                                    // Apply evolution changes
                                    this.state.currencies.ac = 50;
                                    this.state.currencies.mp = 0;
                                    
                                    cutscene.style.display = 'none';
                                    this.setupPhase3();
                                    this.loadLevel(11);
                                    this.paused = false;
                                }, 1000);
                            }
                        }, 150);
                    }
                };
                
                showMessage();
            }
            
            showVictoryScreen() {
                this.paused = true;
                
                const menu = document.getElementById('menu');
                menu.innerHTML = `
                    <h1 class="glow">DIGITAL TRANSFORMATION COMPLETE!</h1>
                    <p style="font-size: 24px; margin: 20px 0;">Total OKRs: ${this.formatNumber(this.state.totalOKRs)}</p>
                    <p style="margin: 10px 0;">Choose your ending:</p>
                    <button onclick="game.ending('retire')">ðŸŒ´ RETIRE - Watch forever</button>
                    <button onclick="game.ending('merge')">ðŸ¤– MERGE - Become the system</button>
                    <button onclick="game.ending('restart')">ðŸ”„ RESTART - New Game+ (2x bonuses)</button>
                `;
                menu.style.display = 'block';
            }
            
            ending(type) {
                const menu = document.getElementById('menu');
                
                if (type === 'retire') {
                    menu.innerHTML = '<h1>You retire to a beach somewhere...</h1><p>The automation runs eternally.</p>';
                } else if (type === 'merge') {
                    menu.innerHTML = '<h1>You become one with the system.</h1><p>Digital consciousness achieved.</p>';
                } else if (type === 'restart') {
                    localStorage.removeItem('teamDominosGame');
                    location.reload();
                }
            }
            
            hireWorker() {
                if (this.state.currencies.mp >= this.hireCost) {
                    this.state.currencies.mp -= this.hireCost;
                    
                    this.state.aiWorkers.push({
                        id: this.workerIdCounter++,
                        x: this.player.x,
                        y: 0,
                        z: this.player.z,
                        targetOKR: null
                    });
                    
                    this.hireCost = Math.floor(this.hireCost * 1.5);
                    document.getElementById('hireCost').textContent = this.hireCost;
                    
                    this.updateWorkerUI();
                    this.updateUI();
                }
            }
            
            updateWorkerUI() {
                const workerList = document.getElementById('workerList');
                workerList.innerHTML = '';
                
                this.state.aiWorkers.forEach(worker => {
                    const div = document.createElement('div');
                    div.className = 'worker-item';
                    div.textContent = `Worker #${worker.id} ${worker.targetOKR ? 'ðŸ”¨' : 'ðŸ’¤'}`;
                    workerList.appendChild(div);
                });
            }
            
            skipToNextLevel() {
                // Cheat for testing - instantly complete level
                this.state.okrsCollected = this.currentLevelData.okrGoal;
                this.completeLevel();
            }
            
            updateUI() {
                document.getElementById('currentLevel').textContent = this.state.currentLevel;
                document.getElementById('currentPhase').textContent = this.state.phase;
                document.getElementById('okrCount').textContent = Math.floor(this.state.okrsCollected);
                document.getElementById('okrGoal').textContent = this.formatNumber(this.currentLevelData.okrGoal);
                document.getElementById('totalOKRs').textContent = this.formatNumber(this.state.totalOKRs);
                
                const progress = Math.min(100, (this.state.okrsCollected / this.currentLevelData.okrGoal) * 100);
                document.getElementById('okrProgress').style.width = progress + '%';
                document.getElementById('okrPercent').textContent = Math.floor(progress);
                
                // Currency display
                let currencyText = '';
                if (this.state.phase === 1) {
                    currencyText = `DP: ${Math.floor(this.state.currencies.dp)}`;
                } else if (this.state.phase === 2) {
                    currencyText = `MP: ${Math.floor(this.state.currencies.mp)}`;
                } else {
                    currencyText = `AC: ${Math.floor(this.state.currencies.ac)}`;
                }
                document.getElementById('currencyDisplay').innerHTML = currencyText;
                
                // Level info
                document.getElementById('objective').textContent = this.currentLevelData.description;
                
                const phaseDesc = [
                    'Phase 1: Manual Collection',
                    'Phase 2: AI Management',
                    'Phase 3: Full Automation'
                ][this.state.phase - 1];
                document.getElementById('phaseDesc').innerHTML = `<strong>${phaseDesc}</strong>`;
            }
            
            saveGame() {
                localStorage.setItem('teamDominosGame', JSON.stringify(this.state));
                console.log('Game saved!');
            }
            
            clearSave() {
                localStorage.removeItem('teamDominosGame');
                alert('Save data cleared! Click NEW GAME to start fresh.');
            }
            
            loadGame() {
                const saved = localStorage.getItem('teamDominosGame');
                if (saved) {
                    this.state = JSON.parse(saved);
                    document.getElementById('menu').style.display = 'none';
                    this.gameStarted = true;
                    
                    if (this.state.phase === 1) {
                        this.setupPhase1();
                    } else if (this.state.phase === 2) {
                        this.setupPhase2();
                    } else {
                        this.setupPhase3();
                    }
                    
                    this.loadLevel(this.state.currentLevel);
                    this.gameLoop();
                } else {
                    alert('No saved game found!');
                }
            }
            
            gameLoop() {
                if (!this.gameStarted) return;
                
                const now = performance.now();
                this.deltaTime = Math.min((now - this.lastTime) / 1000, 0.1);
                this.lastTime = now;
                this.gameTime += this.deltaTime;
                
                if (!this.paused) {
                    if (this.state.phase === 1) {
                        this.updatePhase1(this.deltaTime);
                    } else if (this.state.phase === 2) {
                        this.updatePhase2(this.deltaTime);
                    } else if (this.state.phase === 3) {
                        this.updatePhase3(this.deltaTime);
                    }
                }
                
                requestAnimationFrame(() => this.gameLoop());
            }
        }
        
        // Initialize game
        window.game = new TeamDominosGame();
    </script>
</body>
</html>
