<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Team Dominos - Digital Transformation Journey</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Courier New', monospace;
            background: #000;
            color: #fff;
            overflow: hidden;
        }
        
        #gameCanvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
        
        #ui {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            padding: 20px;
            pointer-events: none;
            z-index: 100;
        }
        
        #stats {
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border: 2px solid #0ff;
            border-radius: 5px;
            display: inline-block;
            pointer-events: auto;
        }
        
        #levelInfo {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border: 2px solid #ff0;
            border-radius: 5px;
            pointer-events: auto;
        }
        
        #controls {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border: 2px solid #0f0;
            border-radius: 5px;
            pointer-events: auto;
            max-width: 300px;
        }
        
        .stat-bar {
            height: 20px;
            background: #222;
            border: 1px solid #fff;
            margin: 5px 0;
            position: relative;
            overflow: hidden;
        }
        
        .stat-fill {
            height: 100%;
            background: linear-gradient(90deg, #0ff, #00f);
            transition: width 0.3s;
        }
        
        .stat-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 12px;
            font-weight: bold;
            text-shadow: 1px 1px 2px #000;
        }
        
        button {
            background: #0ff;
            color: #000;
            border: none;
            padding: 10px 20px;
            margin: 5px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            border-radius: 3px;
            pointer-events: auto;
        }
        
        button:hover {
            background: #0dd;
            transform: scale(1.05);
        }
        
        button:disabled {
            background: #444;
            color: #666;
            cursor: not-allowed;
        }
        
        #cutscene {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #fff;
            z-index: 1000;
            display: none;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            animation: fadeIn 1s;
        }
        
        #cutscene.glitch {
            animation: glitchEffect 0.5s;
            background: #000;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        @keyframes glitchEffect {
            0%, 100% { transform: translate(0); }
            20% { transform: translate(-5px, 5px); }
            40% { transform: translate(-5px, -5px); }
            60% { transform: translate(5px, 5px); }
            80% { transform: translate(5px, -5px); }
        }
        
        .cutscene-text {
            font-size: 48px;
            font-weight: bold;
            margin: 20px;
            text-align: center;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        @keyframes flash {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }
        
        #menu {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            padding: 40px;
            border: 3px solid #0ff;
            border-radius: 10px;
            z-index: 500;
            display: none;
            text-align: center;
        }
        
        #menu h1 {
            color: #0ff;
            margin-bottom: 20px;
            font-size: 36px;
        }
        
        #menu p {
            margin: 10px 0;
            font-size: 14px;
        }
        
        .glow {
            text-shadow: 0 0 10px currentColor;
        }
        
        #workers {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border: 2px solid #f0f;
            border-radius: 5px;
            max-width: 300px;
            max-height: 300px;
            overflow-y: auto;
            pointer-events: auto;
        }
        
        .worker-item {
            background: rgba(255, 0, 255, 0.2);
            padding: 8px;
            margin: 5px 0;
            border-radius: 3px;
            font-size: 12px;
        }
        
        #buildings {
            position: fixed;
            top: 50%;
            right: 20px;
            transform: translateY(-50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border: 2px solid #fa0;
            border-radius: 5px;
            max-width: 250px;
            pointer-events: auto;
        }
        
        .building-btn {
            width: 100%;
            margin: 3px 0;
            background: #fa0;
            font-size: 11px;
            padding: 8px;
        }
        
        .building-btn:hover {
            background: #fc0;
        }
        
        .building-btn.selected {
            background: #f00;
            box-shadow: 0 0 10px #f00;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
    <div id="ui">
        <div id="stats">
            <div><strong class="glow">Level <span id="currentLevel">1</span></strong> - Phase <span id="currentPhase">1</span></div>
            <div>OKRs: <span id="okrCount">0</span> / <span id="okrGoal">3</span></div>
            <div class="stat-bar">
                <div class="stat-fill" id="okrProgress"></div>
                <div class="stat-text"><span id="okrPercent">0</span>%</div>
            </div>
            <div style="margin-top: 10px;">
                <span id="currencyDisplay">DP: <span id="dpAmount">0</span></span>
            </div>
            <div style="margin-top: 5px; font-size: 12px;">
                Total OKRs: <span id="totalOKRs">0</span>
            </div>
        </div>
    </div>
    
    <div id="levelInfo">
        <div><strong>Objective:</strong></div>
        <div id="objective">Collect all OKRs and reach Jrod HQ!</div>
        <div style="margin-top: 10px; font-size: 12px;" id="phaseDesc">
            <strong>Phase 1:</strong> Manual Collection
        </div>
    </div>
    
    <div id="controls">
        <div><strong>Controls:</strong></div>
        <div style="font-size: 12px; margin-top: 5px;">
            <div id="controlsText">
                WASD - Move<br>
                SPACE - Jump<br>
                SHIFT - Sprint (unlocked L3)
            </div>
        </div>
        <div style="margin-top: 10px;">
            <button id="saveBtn" onclick="game.saveGame()">Save</button>
            <button id="nextBtn" onclick="game.skipToNextLevel()" style="font-size: 10px;">Skip Level</button>
        </div>
    </div>
    
    <div id="workers" style="display: none;">
        <div><strong>AI Workers:</strong></div>
        <div id="workerList"></div>
        <button onclick="game.hireWorker()" id="hireBtn">Hire Worker (Cost: <span id="hireCost">50</span> MP)</button>
    </div>
    
    <div id="buildings" style="display: none;">
        <div><strong>Automation:</strong></div>
        <div id="buildingList"></div>
    </div>
    
    <div id="menu">
        <h1>TEAM DOMINOS</h1>
        <p>A Digital Transformation Journey</p>
        <p style="margin-top: 20px;">Evolve through 3 phases of productivity:</p>
        <p>ðŸŽ® Levels 1-5: Manual Platforming</p>
        <p>ðŸ¤– Levels 6-10: AI Management</p>
        <p>âš¡ Levels 11-15: Full Automation</p>
        <button onclick="game.startGame()" style="margin-top: 20px;">NEW GAME</button>
        <button onclick="game.loadGame()">CONTINUE</button>
        <button onclick="game.clearSave()" style="font-size: 12px; background: #600; margin-top: 10px;">CLEAR SAVE DATA</button>
    </div>
    
    <div id="cutscene">
        <div class="cutscene-text" id="cutsceneText"></div>
    </div>

    <script type="module">
        import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js';
        
        class TeamDominosGame {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
                
                this.state = {
                    currentLevel: 1,
                    phase: 1,
                    renderMode: '3D',
                    currencies: { dp: 0, mp: 0, ac: 0 },
                    totalOKRs: 0,
                    playerStats: {
                        speed: 15,
                        jump: 18,
                        capacity: 1,
                        sprint: 0,
                        autoCollect: 0
                    },
                    aiWorkers: [],
                    buildings: [],
                    completedLevels: [],
                    okrsCollected: 0
                };
                
                this.keys = {};
                this.gameStarted = false;
                this.paused = false;
                
                this.levelConfigs = this.initLevelConfigs();
                this.currentLevelData = null;
                
                // Three.js objects
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.player = null;
                this.playerVelocity = { x: 0, y: 0, z: 0 };
                this.isGrounded = false;
                this.canDoubleJump = false;
                this.hasDoubleJumped = false;
                
                // 2D Canvas context
                this.ctx = null;
                
                // Camera offset for 3D
                this.cameraOffset = { x: 0, y: 5, z: 10 };
                
                // Game objects
                this.okrs = [];
                this.platforms = [];
                this.jrodHQ = null;
                
                // Time
                this.lastTime = performance.now();
                this.deltaTime = 0;
                this.gameTime = 0;
                
                // AI Workers
                this.workerIdCounter = 0;
                this.hireCost = 50;
                
                // Buildings
                this.buildingIdCounter = 0;
                this.automationNodes = [];
                this.selectedBuilding = null;
                
                // Spectators
                this.currentLevelSpectators = [];
                this.initSpectatorConfigs();
                
                this.setupEventListeners();
                this.showMenu();
            }
            
            initLevelConfigs() {
                return {
                    1: { okrGoal: 3, reward: 10, currency: 'dp', description: 'Tutorial - Learn the basics', boss: false },
                    2: { okrGoal: 5, reward: 15, currency: 'dp', description: 'Navigate gaps', boss: false },
                    3: { okrGoal: 7, reward: 20, currency: 'dp', description: 'Avoid obstacles', boss: false, unlock: 'sprint' },
                    4: { okrGoal: 10, reward: 30, currency: 'dp', description: 'Vertical challenge', boss: false, unlock: 'doubleJump' },
                    5: { okrGoal: 15, reward: 50, currency: 'dp', description: 'BOSS: The Bureaucrat', boss: true, evolution: 1 },
                    6: { okrGoal: 10, reward: 30, currency: 'mp', description: 'First AI hire', boss: false },
                    7: { okrGoal: 15, reward: 50, currency: 'mp', description: 'Manage 3 workers', boss: false },
                    8: { okrGoal: 20, reward: 75, currency: 'mp', description: 'Timed challenge', boss: false },
                    9: { okrGoal: 30, reward: 100, currency: 'mp', description: 'Optimization puzzle', boss: false },
                    10: { okrGoal: 50, reward: 150, currency: 'mp', description: 'BOSS: Scope Creep', boss: true, evolution: 2 },
                    11: { okrGoal: 100, reward: 100, currency: 'ac', description: 'First conveyor', boss: false },
                    12: { okrGoal: 500, reward: 200, currency: 'ac', description: 'Network topology', boss: false },
                    13: { okrGoal: 10000, reward: 500, currency: 'ac', description: 'Exponential growth', boss: false },
                    14: { okrGoal: 100000, reward: 1000, currency: 'ac', description: 'Singularity', boss: false },
                    15: { okrGoal: 1000000, reward: 0, currency: 'ac', description: 'FINAL: Digital Transformation', boss: true, final: true }
                };
            }
            
            initSpectatorConfigs() {
                this.levelSpectators = {
                    1: [{ name: 'Bea', color: '#4a90e2', quote: 'Welcome!' }],
                    2: [{ name: 'Francisco', color: '#e74c3c' }, { name: 'Mason', color: '#27ae60' }],
                    3: [{ name: 'Ramon', color: '#3498db', quote: 'Speed is key!' }],
                    4: [{ name: 'Erik', color: '#9b59b6', quote: 'Go vertical!' }],
                    5: [{ name: 'Murali', color: '#e67e22' }, { name: 'Stephane', color: '#1abc9c' }],
                    6: [{ name: 'Avital', color: '#f39c12', quote: "I'll help!" }],
                    7: [{ name: 'Parker', color: '#2ecc71' }, { name: 'Zaki', color: '#16a085' }],
                    8: [{ name: 'Jeff', color: '#8e44ad' }, { name: 'Lauren B.', color: '#c0392b' }],
                    9: [{ name: 'Patrick', color: '#d35400' }, { name: 'Katy', color: '#2980b9' }],
                    10: [{ name: 'Jason', color: '#27ae60' }, { name: 'Ada', color: '#e91e63' }],
                    11: [{ name: 'Josh', color: '#00bcd4', quote: 'Build it!' }],
                    12: [{ name: 'James', color: '#9c27b0', quote: 'Connect!' }],
                    13: [{ name: 'Yanan', color: '#ff9800' }, { name: 'Lauren G.', color: '#4caf50' }],
                    14: [{ name: 'ALL 20', color: '#00ffff', quote: 'Almost there!' }],
                    15: [{ name: 'Jrod', color: '#ffd700', quote: 'Choose wisely...' }]
                };
            }
            
            setupEventListeners() {
                window.addEventListener('keydown', (e) => {
                    this.keys[e.code] = true;
                    if (e.code === 'Space' && this.state.phase === 1) {
                        e.preventDefault();
                    }
                });
                
                window.addEventListener('keyup', (e) => {
                    this.keys[e.code] = false;
                });
                
                window.addEventListener('resize', () => {
                    this.canvas.width = window.innerWidth;
                    this.canvas.height = window.innerHeight;
                    if (this.state.renderMode === '3D' && this.camera) {
                        this.camera.aspect = window.innerWidth / window.innerHeight;
                        this.camera.updateProjectionMatrix();
                        this.renderer.setSize(window.innerWidth, window.innerHeight);
                    }
                });
                
                this.canvas.addEventListener('click', (e) => {
                    if (this.state.phase === 3) {
                        this.handleCanvasClick(e);
                    }
                });
            }
            
            showMenu() {
                document.getElementById('menu').style.display = 'block';
            }
            
            startGame() {
                document.getElementById('menu').style.display = 'none';
                this.gameStarted = true;
                this.setupPhase1();
                this.loadLevel(1);
                this.gameLoop();
            }
            
            setupPhase1() {
                console.log('Setting up Phase 1 - 3D mode');
                // Initialize Three.js
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x87ceeb);
                this.scene.fog = new THREE.Fog(0x87ceeb, 50, 200);
                console.log('Scene created');
                
                this.camera = new THREE.PerspectiveCamera(
                    60,
                    window.innerWidth / window.innerHeight,
                    0.1,
                    1000
                );
                this.camera.position.set(0, 5, 10);
                this.camera.lookAt(0, 0, 0);
                
                this.renderer = new THREE.WebGLRenderer({ canvas: this.canvas, antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                
                // Lighting
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                this.scene.add(ambientLight);
                
                const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
                dirLight.position.set(10, 20, 10);
                dirLight.castShadow = true;
                dirLight.shadow.camera.left = -50;
                dirLight.shadow.camera.right = 50;
                dirLight.shadow.camera.top = 50;
                dirLight.shadow.camera.bottom = -50;
                dirLight.shadow.mapSize.width = 2048;
                dirLight.shadow.mapSize.height = 2048;
                this.scene.add(dirLight);
                
                // Hemisphere light (sky/ground color blend)
                const hemiLight = new THREE.HemisphereLight(0x87ceeb, 0x228b22, 0.4);
                this.scene.add(hemiLight);
                
                // Car headlight (moves with player)
                this.playerLight = new THREE.SpotLight(0xffffcc, 1.5, 30, Math.PI / 6, 0.3);
                this.playerLight.position.set(0, 1, 2);
                this.playerLight.castShadow = true;
                
                // Warm rim light from behind
                this.rimLight = new THREE.PointLight(0xff8844, 0.6, 15);
                this.rimLight.position.set(0, 3, -5);
                
                // Create player - character in a small car
                const playerGroup = new THREE.Group();
                const carBodyMat = new THREE.MeshPhongMaterial({ color: 0x2266cc });
                const metalMat = new THREE.MeshPhongMaterial({ color: 0x888888 });
                const glassMat = new THREE.MeshPhongMaterial({ color: 0x88ccff, transparent: true, opacity: 0.6 });
                const tireMat = new THREE.MeshPhongMaterial({ color: 0x222222 });
                const skinMat = new THREE.MeshPhongMaterial({ color: 0xffcc99 });
                const hairMat = new THREE.MeshPhongMaterial({ color: 0x442200 });
                
                // Car body (lower)
                const chassis = new THREE.Mesh(new THREE.BoxGeometry(1.4, 0.4, 2.2), carBodyMat);
                chassis.position.set(0, 0.35, 0);
                playerGroup.add(chassis);
                
                // Car cabin (upper)
                const cabin = new THREE.Mesh(new THREE.BoxGeometry(1.2, 0.5, 1.2), carBodyMat);
                cabin.position.set(0, 0.75, -0.1);
                playerGroup.add(cabin);
                
                // Windshield
                const windshield = new THREE.Mesh(new THREE.BoxGeometry(1.1, 0.45, 0.05), glassMat);
                windshield.position.set(0, 0.78, 0.52);
                windshield.rotation.x = -0.2;
                playerGroup.add(windshield);
                
                // Rear window
                const rearWindow = new THREE.Mesh(new THREE.BoxGeometry(1.1, 0.4, 0.05), glassMat);
                rearWindow.position.set(0, 0.78, -0.72);
                rearWindow.rotation.x = 0.2;
                playerGroup.add(rearWindow);
                
                // Wheels
                const wheelGeo = new THREE.CylinderGeometry(0.2, 0.2, 0.15, 12);
                const hubGeo = new THREE.CylinderGeometry(0.08, 0.08, 0.16, 8);
                const hubMat = new THREE.MeshPhongMaterial({ color: 0xcccccc });
                
                const wheelPositions = [
                    [-0.7, 0.2, 0.65], [0.7, 0.2, 0.65],
                    [-0.7, 0.2, -0.65], [0.7, 0.2, -0.65]
                ];
                wheelPositions.forEach(pos => {
                    const wheel = new THREE.Mesh(wheelGeo, tireMat);
                    wheel.rotation.z = Math.PI / 2;
                    wheel.position.set(pos[0], pos[1], pos[2]);
                    playerGroup.add(wheel);
                    const hub = new THREE.Mesh(hubGeo, hubMat);
                    hub.rotation.z = Math.PI / 2;
                    hub.position.set(pos[0], pos[1], pos[2]);
                    playerGroup.add(hub);
                });
                
                // Headlights
                const headlightMat = new THREE.MeshPhongMaterial({ color: 0xffffaa, emissive: 0xffffaa, emissiveIntensity: 0.8 });
                const hlGeo = new THREE.SphereGeometry(0.1, 8, 8);
                const hl1 = new THREE.Mesh(hlGeo, headlightMat);
                hl1.position.set(-0.45, 0.4, 1.1);
                playerGroup.add(hl1);
                const hl2 = new THREE.Mesh(hlGeo, headlightMat);
                hl2.position.set(0.45, 0.4, 1.1);
                playerGroup.add(hl2);
                
                // Bumper
                const bumper = new THREE.Mesh(new THREE.BoxGeometry(1.3, 0.12, 0.1), metalMat);
                bumper.position.set(0, 0.2, 1.12);
                playerGroup.add(bumper);
                
                // Driver head (visible above cabin)
                const head = new THREE.Mesh(new THREE.SphereGeometry(0.2, 10, 10), skinMat);
                head.position.set(0, 1.15, 0);
                playerGroup.add(head);
                
                // Driver hair
                const hair = new THREE.Mesh(new THREE.SphereGeometry(0.21, 10, 10, 0, Math.PI * 2, 0, Math.PI / 2), hairMat);
                hair.position.set(0, 1.2, 0);
                playerGroup.add(hair);
                
                // Eyes
                const eyeMat = new THREE.MeshPhongMaterial({ color: 0x000000 });
                const le = new THREE.Mesh(new THREE.SphereGeometry(0.04, 6, 6), eyeMat);
                le.position.set(-0.08, 1.17, 0.18);
                playerGroup.add(le);
                const re = new THREE.Mesh(new THREE.SphereGeometry(0.04, 6, 6), eyeMat);
                re.position.set(0.08, 1.17, 0.18);
                playerGroup.add(re);
                
                playerGroup.traverse(child => { child.castShadow = true; });
                playerGroup.position.set(0, 2, 0);
                this.player = playerGroup;
                this.scene.add(this.player);
                
                // Attach lights to scene (follow player in update loop)
                this.scene.add(this.playerLight);
                this.scene.add(this.playerLight.target);
                this.scene.add(this.rimLight);
                
                console.log('Three.js setup complete', {
                    scene: this.scene,
                    camera: this.camera,
                    renderer: this.renderer,
                    player: this.player
                });
            }
            
            disposeThreeJS() {
                if (this.renderer) {
                    this.renderer.dispose();
                }
                if (this.scene) {
                    this.scene.traverse((obj) => {
                        if (obj.geometry) obj.geometry.dispose();
                        if (obj.material) {
                            if (Array.isArray(obj.material)) {
                                obj.material.forEach(m => m.dispose());
                            } else {
                                obj.material.dispose();
                            }
                        }
                    });
                }
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.player = null;
            }
            
            setupPhase2() {
                this.disposeThreeJS();
                
                // Create a fresh 2D canvas (WebGL canvas can't switch to 2D)
                const oldCanvas = this.canvas;
                const newCanvas = document.createElement('canvas');
                newCanvas.id = 'gameCanvas';
                newCanvas.width = window.innerWidth;
                newCanvas.height = window.innerHeight;
                newCanvas.style.cssText = oldCanvas.style.cssText;
                oldCanvas.parentNode.replaceChild(newCanvas, oldCanvas);
                this.canvas = newCanvas;
                
                this.ctx = this.canvas.getContext('2d');
                this.state.renderMode = 'isometric';
                
                // Re-attach click handler
                this.canvas.addEventListener('click', (e) => {
                    if (this.state.phase === 3) this.handleCanvasClick(e);
                });
                
                // Player position in 2D (car)
                this.player = { x: 10, y: 0, z: 10, vx: 0, vy: 0, vz: 0, angle: 0 };
                
                // Start with 1 AI worker
                if (this.state.aiWorkers.length === 0) {
                    this.state.aiWorkers.push({
                        id: this.workerIdCounter++,
                        x: 12,
                        y: 0,
                        z: 12,
                        targetOKR: null
                    });
                }
                
                // Update UI
                document.getElementById('controlsText').innerHTML = 
                    'WASD - Drive<br>Collect OKR coins<br>Hire more workers!';
                document.getElementById('workers').style.display = 'block';
                this.updateWorkerUI();
            }
            
            setupPhase3() {
                // If coming from Phase 2, canvas already supports 2D
                // If somehow context is lost, create fresh canvas
                if (!this.ctx) {
                    const oldCanvas = this.canvas;
                    const newCanvas = document.createElement('canvas');
                    newCanvas.id = 'gameCanvas';
                    newCanvas.width = window.innerWidth;
                    newCanvas.height = window.innerHeight;
                    newCanvas.style.cssText = oldCanvas.style.cssText;
                    oldCanvas.parentNode.replaceChild(newCanvas, oldCanvas);
                    this.canvas = newCanvas;
                    this.ctx = this.canvas.getContext('2d');
                }
                this.state.renderMode = 'abstract';
                
                // Hide workers, show buildings
                document.getElementById('workers').style.display = 'none';
                document.getElementById('buildings').style.display = 'block';
                
                // Update UI
                document.getElementById('controlsText').innerHTML = 
                    'Click - Place Automation<br>Watch - Numbers grow';
                
                this.automationNodes = [];
                this.initAutomationBuildings();
            }
            
            initAutomationBuildings() {
                const buildingList = document.getElementById('buildingList');
                buildingList.innerHTML = '';
                
                const buildings = [
                    { name: 'Collector', cost: 50, rate: 0, acRate: 2, mult: 1 },
                    { name: 'Processor', cost: 150, rate: 5, acRate: 0, mult: 1 },
                    { name: 'Multiplier', cost: 500, rate: 0, acRate: 0, mult: 1.5 },
                    { name: 'Synthesizer', cost: 2000, rate: 100, acRate: 0, mult: 1 }
                ];
                
                buildings.forEach(b => {
                    const btn = document.createElement('button');
                    btn.className = 'building-btn';
                    btn.id = 'building-' + b.name;
                    const desc = b.acRate > 0 ? `+${b.acRate} AC/s` : b.mult > 1 ? `x${b.mult} all rates` : `${b.rate} OKR/s`;
                    btn.textContent = `${b.name} (${b.cost} AC) - ${desc}`;
                    btn.onclick = () => this.selectBuilding(b, btn);
                    buildingList.appendChild(btn);
                });
            }
            
            selectBuilding(building, btn) {
                // Deselect previous
                document.querySelectorAll('.building-btn').forEach(b => b.classList.remove('selected'));
                
                this.selectedBuilding = building;
                if (btn) btn.classList.add('selected');
            }
            
            handleCanvasClick(e) {
                if (!this.selectedBuilding) return;
                
                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                if (this.state.currencies.ac >= this.selectedBuilding.cost) {
                    this.state.currencies.ac -= this.selectedBuilding.cost;
                    this.automationNodes.push({
                        x, y,
                        name: this.selectedBuilding.name,
                        rate: this.selectedBuilding.rate,
                        acRate: this.selectedBuilding.acRate || 0,
                        mult: this.selectedBuilding.mult || 1,
                        id: this.buildingIdCounter++
                    });
                    this.updateUI();
                }
            }
            
            loadLevel(levelNum) {
                this.levelCompleting = false;
                this.currentLevelData = this.levelConfigs[levelNum];
                this.state.currentLevel = levelNum;
                this.state.okrsCollected = 0;
                
                // Clear existing objects
                this.okrs = [];
                this.platforms = [];
                this.jrodHQ = null;
                
                // Determine phase
                if (levelNum <= 5) this.state.phase = 1;
                else if (levelNum <= 10) this.state.phase = 2;
                else this.state.phase = 3;
                
                // Generate level based on phase
                if (this.state.phase === 1) {
                    this.generatePhase1Level(levelNum);
                } else if (this.state.phase === 2) {
                    this.generatePhase2Level(levelNum);
                } else {
                    this.generatePhase3Level(levelNum);
                }
                
                this.updateUI();
            }
            
            generatePhase1Level(levelNum) {
                // Clear scene
                if (this.scene) {
                    const objectsToRemove = [];
                    this.scene.traverse((obj) => {
                        if (obj.userData.isLevelObject) {
                            objectsToRemove.push(obj);
                        }
                    });
                    objectsToRemove.forEach(obj => this.scene.remove(obj));
                }
                
                // Reset player
                this.player.position.set(0, 2, 0);
                this.playerVelocity = { x: 0, y: 0, z: 0 };
                
                const config = this.currentLevelData;
                
                // Create ground platform
                this.createPlatform(0, -1, 0, 20, 2, 20, 0x228b22);
                
                // Generate platforms based on level
                if (levelNum === 1) {
                    // Tutorial - flat platforms
                    this.createPlatform(10, 0, 0, 5, 1, 5, 0x8b4513);
                    this.createPlatform(20, 0, 0, 8, 1, 8, 0x8b4513);
                } else if (levelNum === 2) {
                    // Gaps
                    this.createPlatform(8, 0, 0, 4, 1, 4, 0x8b4513);
                    this.createPlatform(16, 0, 0, 4, 1, 4, 0x8b4513);
                    this.createPlatform(24, 0, 0, 4, 1, 4, 0x8b4513);
                } else if (levelNum === 3) {
                    // Obstacles
                    for (let i = 0; i < 5; i++) {
                        this.createPlatform(8 + i * 6, Math.random() * 2, 0, 3, 1, 3, 0x8b4513);
                    }
                } else if (levelNum === 4) {
                    // Vertical
                    for (let i = 0; i < 5; i++) {
                        this.createPlatform(5, i * 3 + 1, 0, 4, 1, 4, 0x8b4513);
                    }
                } else if (levelNum === 5) {
                    // Boss level - spiral staircase (tighter radius, bigger platforms)
                    for (let i = 0; i < 8; i++) {
                        const angle = (i / 8) * Math.PI * 2;
                        const x = Math.cos(angle) * 8;
                        const z = Math.sin(angle) * 8;
                        this.createPlatform(x, i * 1.5, z, 5, 1, 5, 0x8b4513);
                    }
                }
                
                // Place OKRs
                for (let i = 0; i < config.okrGoal; i++) {
                    let pos;
                    if (levelNum === 1) {
                        pos = { x: 10 + i * 5, y: 3, z: 0 };
                    } else {
                        const platform = this.platforms[Math.floor(Math.random() * this.platforms.length)];
                        if (platform) {
                            pos = {
                                x: platform.position.x + (Math.random() - 0.5) * 2,
                                y: platform.position.y + 3,
                                z: platform.position.z + (Math.random() - 0.5) * 2
                            };
                        } else {
                            pos = { x: i * 5, y: 3, z: 0 };
                        }
                    }
                    this.createOKR(pos.x, pos.y, pos.z);
                }
                
                // Create Jrod HQ - Car Lift goal
                const lastPlatform = this.platforms[this.platforms.length - 1];
                const hqX = lastPlatform ? lastPlatform.position.x + 8 : 25;
                
                const liftGroup = new THREE.Group();
                const steelMat = new THREE.MeshPhongMaterial({ color: 0x888888 });
                const baseMat = new THREE.MeshPhongMaterial({ color: 0x444444 });
                const yellowMat = new THREE.MeshPhongMaterial({ color: 0xffcc00, emissive: 0xffaa00, emissiveIntensity: 0.3 });
                
                // Base plate
                const base = new THREE.Mesh(new THREE.BoxGeometry(3, 0.2, 4), baseMat);
                base.position.set(0, 0.1, 0);
                liftGroup.add(base);
                
                // Left pillar
                const pillar = new THREE.Mesh(new THREE.BoxGeometry(0.3, 6, 0.3), steelMat);
                pillar.position.set(-1.2, 3, 0);
                liftGroup.add(pillar);
                
                // Right pillar
                const pillar2 = pillar.clone();
                pillar2.position.set(1.2, 3, 0);
                liftGroup.add(pillar2);
                
                // Cross beam at top
                const beam = new THREE.Mesh(new THREE.BoxGeometry(3, 0.2, 0.2), steelMat);
                beam.position.set(0, 6, 0);
                liftGroup.add(beam);
                
                // Lift platform (the part that goes up)
                const liftPlatform = new THREE.Mesh(new THREE.BoxGeometry(2.5, 0.15, 3.5), yellowMat);
                liftPlatform.position.set(0, 0.3, 0);
                liftPlatform.name = 'liftPlatform';
                liftGroup.add(liftPlatform);
                
                // Lift arms (scissors)
                const armMat = new THREE.MeshPhongMaterial({ color: 0xcc0000 });
                const leftArm = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.1, 3), armMat);
                leftArm.position.set(-1, 0.3, 0);
                liftGroup.add(leftArm);
                const rightArm = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.1, 3), armMat);
                rightArm.position.set(1, 0.3, 0);
                liftGroup.add(rightArm);
                
                // Warning stripes on base
                const stripeMat = new THREE.MeshPhongMaterial({ color: 0x000000 });
                for (let i = -1; i <= 1; i += 0.5) {
                    const stripe = new THREE.Mesh(new THREE.BoxGeometry(3, 0.01, 0.1), stripeMat);
                    stripe.position.set(0, 0.21, i);
                    liftGroup.add(stripe);
                }
                
                // Arrow indicator (glowing)
                const arrowMat = new THREE.MeshPhongMaterial({ color: 0x00ff00, emissive: 0x00ff00, emissiveIntensity: 0.8 });
                const arrow = new THREE.Mesh(new THREE.ConeGeometry(0.3, 0.6, 4), arrowMat);
                arrow.position.set(0, 7, 0);
                arrow.rotation.x = Math.PI;
                liftGroup.add(arrow);
                
                liftGroup.position.set(hqX, 0, 0);
                liftGroup.traverse(child => {
                    child.castShadow = true;
                    child.userData.isLevelObject = true;
                });
                
                this.jrodHQ = liftGroup;
                this.jrodHQ.userData.isLevelObject = true;
                this.scene.add(this.jrodHQ);
                
                // Platform under HQ so player can reach it
                this.createPlatform(hqX, 0, 0, 6, 1, 6, 0x228b22);
                
                // Add spectators for this level
                this.loadSpectators3D(levelNum);
            }
            
            createPlatform(x, y, z, width, height, depth, color) {
                const geometry = new THREE.BoxGeometry(width, height, depth);
                const material = new THREE.MeshPhongMaterial({ color });
                const platform = new THREE.Mesh(geometry, material);
                platform.position.set(x, y, z);
                platform.receiveShadow = true;
                platform.castShadow = true;
                platform.userData.isLevelObject = true;
                platform.userData.isPlatform = true;
                this.scene.add(platform);
                this.platforms.push(platform);
            }
            
            createOKR(x, y, z) {
                const coinGroup = new THREE.Group();
                
                // Coin disc (upright â€” rotate so flat face is toward camera)
                const geometry = new THREE.CylinderGeometry(0.5, 0.5, 0.12, 24);
                const material = new THREE.MeshPhongMaterial({
                    color: 0xffd700,
                    emissive: 0xffaa00,
                    emissiveIntensity: 0.5
                });
                const disc = new THREE.Mesh(geometry, material);
                disc.rotation.z = Math.PI / 2; // Stand upright
                coinGroup.add(disc);
                
                // "OKR" text as a flat plane on front face
                const textCanvas = document.createElement('canvas');
                textCanvas.width = 128;
                textCanvas.height = 128;
                const tCtx = textCanvas.getContext('2d');
                tCtx.clearRect(0, 0, 128, 128);
                tCtx.fillStyle = '#000000';
                tCtx.font = 'bold 52px Arial';
                tCtx.textAlign = 'center';
                tCtx.textBaseline = 'middle';
                tCtx.fillText('OKR', 64, 64);
                
                const textTexture = new THREE.CanvasTexture(textCanvas);
                const textGeo = new THREE.PlaneGeometry(0.7, 0.7);
                
                // Front text
                const frontMat = new THREE.MeshBasicMaterial({ map: textTexture, transparent: true });
                const frontText = new THREE.Mesh(textGeo, frontMat);
                frontText.position.set(0.07, 0, 0);
                frontText.rotation.y = Math.PI / 2;
                coinGroup.add(frontText);
                
                // Back text
                const backMat = new THREE.MeshBasicMaterial({ map: textTexture, transparent: true });
                const backText = new THREE.Mesh(textGeo, backMat);
                backText.position.set(-0.07, 0, 0);
                backText.rotation.y = -Math.PI / 2;
                coinGroup.add(backText);
                
                coinGroup.position.set(x, y, z);
                coinGroup.userData.isLevelObject = true;
                coinGroup.userData.isOKR = true;
                this.scene.add(coinGroup);
                this.okrs.push(coinGroup);
            }
            
            loadSpectators3D(levelNum) {
                // Clear existing spectators
                this.currentLevelSpectators.forEach(spec => {
                    if (spec.mesh && this.scene) {
                        this.scene.remove(spec.mesh);
                    }
                });
                this.currentLevelSpectators = [];
                
                const spectators = this.levelSpectators[levelNum];
                if (!spectators) return;
                
                spectators.forEach((spec, i) => {
                    const x = i === 0 ? -10 : 10;
                    const z = -8;
                    const spectator = this.createSpectator3D(spec.name, spec.color, x, z, spec.quote);
                    this.currentLevelSpectators.push(spectator);
                });
            }
            
            createSpectator3D(name, color, x, z, quote) {
                const mesh = new THREE.Group();
                const skinColor = 0xffdbac;
                
                // Legs
                const legMat = new THREE.MeshLambertMaterial({ color: 0x2244aa });
                const leftLeg = new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.7, 0.25), legMat);
                leftLeg.position.set(-0.15, -0.35, 0);
                mesh.add(leftLeg);
                const rightLeg = new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.7, 0.25), legMat);
                rightLeg.position.set(0.15, -0.35, 0);
                mesh.add(rightLeg);
                
                // Shoes
                const shoeMat = new THREE.MeshLambertMaterial({ color: 0x333333 });
                const leftShoe = new THREE.Mesh(new THREE.BoxGeometry(0.27, 0.12, 0.35), shoeMat);
                leftShoe.position.set(-0.15, -0.75, 0.05);
                mesh.add(leftShoe);
                const rightShoe = new THREE.Mesh(new THREE.BoxGeometry(0.27, 0.12, 0.35), shoeMat);
                rightShoe.position.set(0.15, -0.75, 0.05);
                mesh.add(rightShoe);
                
                // Body (shirt color = team color)
                const bodyMaterial = new THREE.MeshLambertMaterial({ color: color });
                const body = new THREE.Mesh(new THREE.BoxGeometry(0.7, 1.0, 0.45), bodyMaterial);
                body.position.set(0, 0.5, 0);
                body.castShadow = true;
                mesh.add(body);
                
                // Collar
                const collarMat = new THREE.MeshLambertMaterial({ color: 0xffffff });
                const collar = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.1, 0.3), collarMat);
                collar.position.set(0, 0.95, 0.1);
                mesh.add(collar);
                
                // Arms
                const armMat = new THREE.MeshLambertMaterial({ color: color });
                const leftArm = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.8, 0.2), armMat);
                leftArm.position.set(-0.45, 0.5, 0);
                leftArm.name = 'leftArm';
                mesh.add(leftArm);
                const rightArm = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.8, 0.2), armMat);
                rightArm.position.set(0.45, 0.5, 0);
                rightArm.name = 'rightArm';
                mesh.add(rightArm);
                
                // Hands
                const handMat = new THREE.MeshLambertMaterial({ color: skinColor });
                const leftHand = new THREE.Mesh(new THREE.SphereGeometry(0.1, 8, 8), handMat);
                leftHand.position.set(-0.45, 0.05, 0);
                mesh.add(leftHand);
                const rightHand = new THREE.Mesh(new THREE.SphereGeometry(0.1, 8, 8), handMat);
                rightHand.position.set(0.45, 0.05, 0);
                mesh.add(rightHand);
                
                // Head
                const headMaterial = new THREE.MeshLambertMaterial({ color: skinColor });
                const head = new THREE.Mesh(new THREE.SphereGeometry(0.3, 12, 12), headMaterial);
                head.position.y = 1.35;
                head.castShadow = true;
                mesh.add(head);
                
                // Hair (random style per person)
                const hairColor = [0x442200, 0x222222, 0x8B4513, 0xDAA520, 0x2F1B14][name.length % 5];
                const hairMat = new THREE.MeshLambertMaterial({ color: hairColor });
                const hair = new THREE.Mesh(
                    new THREE.SphereGeometry(0.32, 12, 12, 0, Math.PI * 2, 0, Math.PI * 0.55),
                    hairMat
                );
                hair.position.y = 1.42;
                mesh.add(hair);
                
                // Eyes
                const eyeMat = new THREE.MeshBasicMaterial({ color: 0x000000 });
                const eyeWhiteMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
                const leWhite = new THREE.Mesh(new THREE.SphereGeometry(0.06, 8, 8), eyeWhiteMat);
                leWhite.position.set(-0.1, 1.38, 0.26);
                mesh.add(leWhite);
                const reWhite = new THREE.Mesh(new THREE.SphereGeometry(0.06, 8, 8), eyeWhiteMat);
                reWhite.position.set(0.1, 1.38, 0.26);
                mesh.add(reWhite);
                const le = new THREE.Mesh(new THREE.SphereGeometry(0.035, 6, 6), eyeMat);
                le.position.set(-0.1, 1.38, 0.3);
                mesh.add(le);
                const re = new THREE.Mesh(new THREE.SphereGeometry(0.035, 6, 6), eyeMat);
                re.position.set(0.1, 1.38, 0.3);
                mesh.add(re);
                
                // Mouth (smile)
                const smileMat = new THREE.MeshBasicMaterial({ color: 0xcc6666 });
                const smile = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.03, 0.02), smileMat);
                smile.position.set(0, 1.28, 0.29);
                mesh.add(smile);
                
                // Nameplate
                const nameCanvas = document.createElement('canvas');
                nameCanvas.width = 256;
                nameCanvas.height = 64;
                const nCtx = nameCanvas.getContext('2d');
                nCtx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                nCtx.roundRect(4, 4, 248, 56, 8);
                nCtx.fill();
                nCtx.strokeStyle = color;
                nCtx.lineWidth = 2;
                nCtx.roundRect(4, 4, 248, 56, 8);
                nCtx.stroke();
                nCtx.fillStyle = '#ffffff';
                nCtx.font = 'bold 24px Arial';
                nCtx.textAlign = 'center';
                nCtx.textBaseline = 'middle';
                nCtx.fillText(name, 128, 32);
                
                const nameTexture = new THREE.CanvasTexture(nameCanvas);
                const nameMaterial = new THREE.SpriteMaterial({ map: nameTexture, transparent: true });
                const nameSprite = new THREE.Sprite(nameMaterial);
                nameSprite.position.y = 2.0;
                nameSprite.scale.set(2.5, 0.6, 1);
                mesh.add(nameSprite);
                
                mesh.position.set(x, 0.75, z);
                mesh.userData.isLevelObject = true;
                
                this.scene.add(mesh);
                
                return {
                    name: name,
                    mesh: mesh,
                    quote: quote,
                    baseY: 0.75,
                    animTime: Math.random() * Math.PI * 2,
                    cheer: function() {
                        // Jump animation using simple tween
                        const startY = this.mesh.position.y;
                        const jumpHeight = 1.5;
                        const duration = 400;
                        const startTime = Date.now();
                        
                        const jump = () => {
                            const elapsed = Date.now() - startTime;
                            const progress = elapsed / duration;
                            
                            if (progress < 0.5) {
                                this.mesh.position.y = startY + (jumpHeight * progress * 2);
                            } else if (progress < 1) {
                                this.mesh.position.y = startY + jumpHeight - (jumpHeight * (progress - 0.5) * 2);
                            } else {
                                this.mesh.position.y = startY;
                                return;
                            }
                            requestAnimationFrame(jump);
                        };
                        jump();
                    }
                };
            }
            
            loadSpectatorsAnime(levelNum) {
                this.currentLevelSpectators = [];
                
                const spectators = this.levelSpectators[levelNum];
                if (!spectators) return;
                
                spectators.forEach((spec, i) => {
                    const x = i === 0 ? 50 : this.canvas.width - 120;
                    const y = 100 + i * 80;
                    const spectator = {
                        name: spec.name,
                        color: spec.color,
                        quote: spec.quote || '',
                        x: x,
                        y: y,
                        emotion: 'neutral',
                        speechBubble: '',
                        speechTimer: 0,
                        react: function(event) {
                            if (event === 'okr') {
                                this.speechBubble = 'Nice!';
                                this.speechTimer = 60;
                            } else if (event === 'complete') {
                                this.speechBubble = this.quote || 'Great!';
                                this.speechTimer = 90;
                            }
                        }
                    };
                    this.currentLevelSpectators.push(spectator);
                });
            }
            
            loadSpectatorsPixel(levelNum) {
                this.currentLevelSpectators = [];
                
                const spectators = this.levelSpectators[levelNum];
                if (!spectators) return;
                
                // Special handling for level 14 - all 20 team members
                if (levelNum === 14) {
                    const allNames = [
                        'Bea', 'Francisco', 'Ramon', 'Erik', 'Mason', 'Stephane', 'Avital', 'Murali',
                        'Parker', 'Zaki', 'Jeff', 'Lauren B', 'Patrick', 'Katy', 'Jason', 'Ada',
                        'Josh', 'James', 'Yanan', 'Lauren G'
                    ];
                    const colors = [
                        '#4a90e2', '#e74c3c', '#3498db', '#9b59b6', '#27ae60', '#1abc9c', '#f39c12', '#e67e22',
                        '#2ecc71', '#16a085', '#8e44ad', '#c0392b', '#d35400', '#2980b9', '#27ae60', '#e91e63',
                        '#00bcd4', '#9c27b0', '#ff9800', '#4caf50'
                    ];
                    
                    allNames.forEach((name, i) => {
                        const row = Math.floor(i / 10);
                        const col = i % 10;
                        const spectator = {
                            name: name,
                            color: colors[i],
                            x: 5 + col * 8,
                            y: 5 + row * 10,
                            scale: 3
                        };
                        this.currentLevelSpectators.push(spectator);
                    });
                } else {
                    spectators.forEach((spec, i) => {
                        const x = i === 0 ? 5 : this.canvas.width / 4 - 10;
                        const y = 5 + i * 10;
                        const spectator = {
                            name: spec.name,
                            color: spec.color,
                            x: x,
                            y: y,
                            scale: 4
                        };
                        this.currentLevelSpectators.push(spectator);
                    });
                }
            }
            
            generatePhase2Level(levelNum) {
                // Reset player in 2D
                this.player = { x: 5, y: 0, z: 5, vx: 0, vy: 0, vz: 0, angle: 0 };
                
                // Larger map with random layout
                this.platforms = [];
                const size = 40;
                for (let x = 0; x < size; x++) {
                    for (let z = 0; z < size; z++) {
                        this.platforms.push({ x, y: 0, z, type: 'floor' });
                    }
                }
                
                // Scatter OKRs across the larger map
                this.okrs = [];
                for (let i = 0; i < this.currentLevelData.okrGoal; i++) {
                    this.okrs.push({
                        x: 2 + Math.random() * (size - 4),
                        y: 1,
                        z: 2 + Math.random() * (size - 4),
                        collected: false
                    });
                }
                
                // HQ at a random far corner
                this.jrodHQ = { x: size - 5, y: 1, z: size - 5 };
                
                // Add spectators for this level
                this.loadSpectatorsAnime(levelNum);
            }
            
            generatePhase3Level(levelNum) {
                // Abstract level - just needs goal
                this.okrs = [];
                this.platforms = [];
                this.jrodHQ = { active: true };
                
                // Add spectators for this level
                this.loadSpectatorsPixel(levelNum);
            }
            
            updatePhase1(dt) {
                if (!this.player) return;
                
                const speed = this.state.playerStats.speed;
                const sprint = this.keys['ShiftLeft'] && this.state.playerStats.sprint > 0 ? 1.5 : 1;
                
                // Movement
                let moveX = 0, moveZ = 0;
                if (this.keys['KeyW']) moveZ -= 1;
                if (this.keys['KeyS']) moveZ += 1;
                if (this.keys['KeyA']) moveX -= 1;
                if (this.keys['KeyD']) moveX += 1;
                
                if (moveX !== 0 || moveZ !== 0) {
                    // Normalize diagonal movement
                    const len = Math.sqrt(moveX * moveX + moveZ * moveZ);
                    moveX /= len;
                    moveZ /= len;
                    
                    this.playerVelocity.x = moveX * speed * sprint;
                    this.playerVelocity.z = moveZ * speed * sprint;
                    
                    // Rotate car to face movement direction (smooth)
                    const targetAngle = Math.atan2(moveX, moveZ);
                    let angleDiff = targetAngle - this.player.rotation.y;
                    while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                    while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                    this.player.rotation.y += angleDiff * 0.25;
                } else {
                    // Friction when not pressing keys
                    this.playerVelocity.x *= 0.85;
                    this.playerVelocity.z *= 0.85;
                }
                
                // Jump
                if (this.keys['Space'] && this.isGrounded) {
                    this.playerVelocity.y = this.state.playerStats.jump;
                    this.isGrounded = false;
                    this.hasDoubleJumped = false;
                } else if (this.keys['Space'] && this.canDoubleJump && !this.hasDoubleJumped && !this.isGrounded) {
                    this.playerVelocity.y = this.state.playerStats.jump * 0.8;
                    this.hasDoubleJumped = true;
                    this.keys['Space'] = false;
                }
                
                // Gravity (reduced for better jump feel)
                this.playerVelocity.y -= 20 * dt;
                
                // Apply velocity
                this.player.position.x += this.playerVelocity.x * dt;
                this.player.position.y += this.playerVelocity.y * dt;
                this.player.position.z += this.playerVelocity.z * dt;
                
                // Friction
                this.playerVelocity.x *= 0.9;
                this.playerVelocity.z *= 0.9;
                
                // Collision detection
                this.isGrounded = false;
                const playerBox = new THREE.Box3().setFromObject(this.player);
                const playerHeight = playerBox.max.y - playerBox.min.y;
                const playerBottomOffset = this.player.position.y - playerBox.min.y;
                
                this.platforms.forEach(platform => {
                    const platformBox = new THREE.Box3().setFromObject(platform);
                    
                    if (playerBox.intersectsBox(platformBox)) {
                        if (this.playerVelocity.y <= 0) {
                            this.player.position.y = platformBox.max.y + playerBottomOffset;
                            this.playerVelocity.y = 0;
                            this.isGrounded = true;
                        }
                    }
                });
                
                // Death check - respawn if fallen too far
                if (this.player.position.y < -20) {
                    this.respawnPlayer();
                }
                
                // OKR collection
                this.okrs = this.okrs.filter(okr => {
                    const dist = this.player.position.distanceTo(okr.position);
                    if (dist < 2) {
                        this.collectOKR();
                        this.scene.remove(okr);
                        return false;
                    }
                    return true;
                });
                
                // Rotate OKRs + glow pulse
                this.okrs.forEach(okr => {
                    okr.rotation.y += dt * 2;
                    // Pulse glow on the disc mesh (first child)
                    const disc = okr.children && okr.children[0];
                    if (disc && disc.material) {
                        disc.material.emissiveIntensity = 0.3 + Math.sin(this.gameTime * 4) * 0.3;
                    }
                });
                
                // Update lights to follow player
                if (this.playerLight) {
                    this.playerLight.position.set(
                        this.player.position.x,
                        this.player.position.y + 1.5,
                        this.player.position.z + 2
                    );
                    this.playerLight.target.position.set(
                        this.player.position.x,
                        this.player.position.y,
                        this.player.position.z + 10
                    );
                    this.rimLight.position.set(
                        this.player.position.x,
                        this.player.position.y + 3,
                        this.player.position.z - 5
                    );
                }
                
                // HQ check - car lift animation
                if (this.jrodHQ && !this.liftAnimating) {
                    const distToHQ = this.player.position.distanceTo(this.jrodHQ.position);
                    if (distToHQ < 5 && this.state.okrsCollected >= this.currentLevelData.okrGoal) {
                        this.playLiftAnimation();
                    }
                }
                
                // Camera follow
                this.camera.position.x = this.player.position.x + this.cameraOffset.x;
                this.camera.position.y = this.player.position.y + this.cameraOffset.y;
                this.camera.position.z = this.player.position.z + this.cameraOffset.z;
                this.camera.lookAt(this.player.position);
                
                // Animate spectators (idle sway + arm wave)
                this.currentLevelSpectators.forEach(spec => {
                    if (spec.mesh) {
                        spec.animTime += dt;
                        spec.mesh.rotation.z = Math.sin(spec.animTime * 0.8) * 0.05;
                        spec.mesh.position.y = spec.baseY + Math.sin(spec.animTime * 1.5) * 0.05;
                        
                        // Wave arms
                        spec.mesh.traverse(child => {
                            if (child.name === 'rightArm') {
                                child.rotation.z = Math.sin(spec.animTime * 3) * 0.4;
                            }
                            if (child.name === 'leftArm') {
                                child.rotation.z = Math.sin(spec.animTime * 3 + 1) * -0.2;
                            }
                        });
                    }
                });
                
                // Render
                this.renderer.render(this.scene, this.camera);
            }
            
            updatePhase2(dt) {
                const speed = 8;
                
                // Isometric movement: remap WASD to iso directions
                // W = up-left on screen (-x, -z in world)
                // S = down-right (+x, +z)
                // A = down-left (-x, +z) 
                // D = up-right (+x, -z)
                let moveX = 0, moveZ = 0;
                if (this.keys['KeyW']) { moveX -= 1; moveZ -= 1; }
                if (this.keys['KeyS']) { moveX += 1; moveZ += 1; }
                if (this.keys['KeyA']) { moveX -= 1; moveZ += 1; }
                if (this.keys['KeyD']) { moveX += 1; moveZ -= 1; }
                
                if (moveX !== 0 || moveZ !== 0) {
                    const len = Math.sqrt(moveX * moveX + moveZ * moveZ);
                    this.player.x += (moveX / len) * speed * dt;
                    this.player.z += (moveZ / len) * speed * dt;
                    this.player.angle = Math.atan2(moveX, moveZ);
                }
                
                // Keep in bounds
                this.player.x = Math.max(-5, Math.min(45, this.player.x));
                this.player.z = Math.max(-5, Math.min(45, this.player.z));
                
                // MP slowly regenerates
                this.state.currencies.mp += 0.5 * dt;
                
                // Update AI workers
                this.state.aiWorkers.forEach(worker => {
                    if (!worker.targetOKR) {
                        // Find nearest uncollected OKR
                        const available = this.okrs.filter(o => !o.collected && !o.claimed);
                        if (available.length > 0) {
                            worker.targetOKR = available[0];
                            worker.targetOKR.claimed = true;
                        }
                    } else {
                        // Move towards OKR
                        const dx = worker.targetOKR.x - worker.x;
                        const dz = worker.targetOKR.z - worker.z;
                        const dist = Math.sqrt(dx * dx + dz * dz);
                        
                        if (dist < 0.5) {
                            // Collect OKR
                            worker.targetOKR.collected = true;
                            this.collectOKR();
                            worker.targetOKR = null;
                        } else {
                            // Move
                            const workerSpeed = 3 * (this.state.phase === 3 ? 0.25 : 1);
                            worker.x += (dx / dist) * workerSpeed * dt;
                            worker.z += (dz / dist) * workerSpeed * dt;
                        }
                    }
                });
                
                // Player can also collect
                this.okrs.forEach(okr => {
                    if (!okr.collected) {
                        const dx = this.player.x - okr.x;
                        const dz = this.player.z - okr.z;
                        const dist = Math.sqrt(dx * dx + dz * dz);
                        if (dist < 1) {
                            okr.collected = true;
                            this.collectOKR();
                        }
                    }
                });
                
                // Check completion
                if (this.state.okrsCollected >= this.currentLevelData.okrGoal) {
                    const dx = this.player.x - this.jrodHQ.x;
                    const dz = this.player.z - this.jrodHQ.z;
                    const dist = Math.sqrt(dx * dx + dz * dz);
                    if (dist < 2) {
                        this.completeLevel();
                    }
                }
                
                this.renderPhase2();
            }
            
            renderPhase2() {
                const ctx = this.ctx;
                const canvas = this.canvas;
                if (!ctx) return;
                
                // Anime gradient sky
                const skyGrad = ctx.createLinearGradient(0, 0, 0, canvas.height);
                skyGrad.addColorStop(0, '#87CEEB');
                skyGrad.addColorStop(0.6, '#FFB6C1');
                skyGrad.addColorStop(1, '#FFA07A');
                ctx.fillStyle = skyGrad;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Clouds
                ctx.fillStyle = 'rgba(255,255,255,0.85)';
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2;
                for (let i = 0; i < 5; i++) {
                    const cx = ((this.gameTime * 15 + i * 250) % (canvas.width + 200)) - 100;
                    const cy = 40 + i * 60;
                    ctx.beginPath();
                    ctx.arc(cx, cy, 25, 0, Math.PI * 2);
                    ctx.arc(cx + 20, cy, 30, 0, Math.PI * 2);
                    ctx.arc(cx + 40, cy, 25, 0, Math.PI * 2);
                    ctx.fill(); ctx.stroke();
                }
                
                const offsetX = canvas.width / 2;
                const offsetY = canvas.height / 2;
                
                // Camera follows player smoothly
                if (!this._camX) { this._camX = this.player.x; this._camZ = this.player.z; }
                this._camX += (this.player.x - this._camX) * 0.08;
                this._camZ += (this.player.z - this._camZ) * 0.08;
                
                // Draw office floor with cubicles
                const tileSize = 32;
                const gridRange = 15;
                
                const camX = this._camX;
                const camZ = this._camZ;
                
                for (let wx = Math.floor(camX) - gridRange; wx <= Math.floor(camX) + gridRange; wx++) {
                    for (let wz = Math.floor(camZ) - gridRange; wz <= Math.floor(camZ) + gridRange; wz++) {
                        const pos = this.toIso(wx - camX, 0, wz - camZ);
                        const sx = offsetX + pos.x;
                        const sy = offsetY + pos.y;
                        
                        // Skip tiles off screen
                        if (sx < -tileSize * 2 || sx > canvas.width + tileSize * 2 || sy < -tileSize * 2 || sy > canvas.height + tileSize * 2) continue;
                        
                        // Carpet tile floor
                        const dark = (wx + wz) % 2 === 0;
                        ctx.fillStyle = dark ? '#6b7b8d' : '#7a8a9c';
                        ctx.strokeStyle = '#5a6a7a';
                        ctx.lineWidth = 0.5;
                        ctx.beginPath();
                        ctx.moveTo(sx, sy);
                        ctx.lineTo(sx + tileSize, sy + tileSize / 2);
                        ctx.lineTo(sx, sy + tileSize);
                        ctx.lineTo(sx - tileSize, sy + tileSize / 2);
                        ctx.closePath();
                        ctx.fill(); ctx.stroke();
                        
                        // Cubicle walls - use seeded random from world coords for variety
                        const seed = (wx * 7 + wz * 13) & 0xff;
                        const hasCubicle = seed < 60 && wx >= 0 && wx <= 40 && wz >= 0 && wz <= 40;
                        
                        if (hasCubicle && wx % 3 === 0) {
                            ctx.fillStyle = '#b0b8c0';
                            ctx.strokeStyle = '#000';
                            ctx.lineWidth = 2;
                            ctx.beginPath();
                            ctx.moveTo(sx - tileSize, sy + tileSize / 2);
                            ctx.lineTo(sx - tileSize, sy + tileSize / 2 - 18);
                            ctx.lineTo(sx, sy - 18);
                            ctx.lineTo(sx, sy);
                            ctx.closePath();
                            ctx.fill(); ctx.stroke();
                        }
                        
                        if (hasCubicle && wz % 3 === 0) {
                            ctx.fillStyle = '#a8b0b8';
                            ctx.strokeStyle = '#000';
                            ctx.lineWidth = 2;
                            ctx.beginPath();
                            ctx.moveTo(sx, sy);
                            ctx.lineTo(sx, sy - 18);
                            ctx.lineTo(sx + tileSize, sy + tileSize / 2 - 18);
                            ctx.lineTo(sx + tileSize, sy + tileSize / 2);
                            ctx.closePath();
                            ctx.fill(); ctx.stroke();
                        }
                        
                        // Desks + monitors scattered randomly
                        if (seed > 180 && seed < 210 && wx >= 0 && wx <= 40 && wz >= 0 && wz <= 40) {
                            ctx.fillStyle = '#8B6914';
                            ctx.strokeStyle = '#5a4510';
                            ctx.lineWidth = 1.5;
                            ctx.beginPath();
                            ctx.moveTo(sx, sy + 4);
                            ctx.lineTo(sx + 14, sy + 11);
                            ctx.lineTo(sx, sy + 18);
                            ctx.lineTo(sx - 14, sy + 11);
                            ctx.closePath();
                            ctx.fill(); ctx.stroke();
                            
                            ctx.fillStyle = '#333';
                            ctx.fillRect(sx - 4, sy + 2, 8, 6);
                            ctx.fillStyle = '#4488ff';
                            ctx.fillRect(sx - 3, sy + 3, 6, 4);
                        }
                        
                        // Potted plants
                        if (seed > 240 && wx >= 0 && wx <= 40 && wz >= 0 && wz <= 40) {
                            ctx.fillStyle = '#6b4226';
                            ctx.fillRect(sx - 3, sy + 10, 6, 6);
                            ctx.fillStyle = '#228b22';
                            ctx.beginPath();
                            ctx.arc(sx, sy + 6, 6, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }
                }
                
                // Draw OKR coins
                this.okrs.forEach(okr => {
                    if (!okr.collected) {
                        const pos = this.toIso(okr.x - camX, okr.y, okr.z - camZ);
                        const cx = offsetX + pos.x;
                        const cy = offsetY + pos.y - 10;
                        const bounce = Math.sin(this.gameTime * 3 + okr.x) * 4;
                        
                        // Coin shadow
                        ctx.fillStyle = 'rgba(0,0,0,0.2)';
                        ctx.beginPath();
                        ctx.ellipse(cx, cy + 20, 12, 6, 0, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Gold coin
                        ctx.fillStyle = '#ffd700';
                        ctx.strokeStyle = '#b8860b';
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.arc(cx, cy + bounce, 14, 0, Math.PI * 2);
                        ctx.fill(); ctx.stroke();
                        
                        // Inner ring
                        ctx.strokeStyle = '#daa520';
                        ctx.lineWidth = 1.5;
                        ctx.beginPath();
                        ctx.arc(cx, cy + bounce, 10, 0, Math.PI * 2);
                        ctx.stroke();
                        
                        // OKR text
                        ctx.fillStyle = '#000000';
                        ctx.font = 'bold 9px Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText('OKR', cx, cy + bounce);
                        
                        // Sparkle
                        const sparkle = Math.sin(this.gameTime * 5 + okr.x * 2) * 0.5 + 0.5;
                        ctx.fillStyle = `rgba(255,255,200,${sparkle})`;
                        ctx.beginPath();
                        ctx.arc(cx - 5, cy + bounce - 6, 2, 0, Math.PI * 2);
                        ctx.fill();
                    }
                });
                
                // Draw car lift goal
                if (this.jrodHQ) {
                    const hqPos = this.toIso(this.jrodHQ.x - camX, 0, this.jrodHQ.z - camZ);
                    const hx = offsetX + hqPos.x;
                    const hy = offsetY + hqPos.y;
                    
                    // Base
                    ctx.fillStyle = '#555';
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 2;
                    ctx.fillRect(hx - 25, hy - 5, 50, 10);
                    ctx.strokeRect(hx - 25, hy - 5, 50, 10);
                    
                    // Pillars
                    ctx.fillStyle = '#888';
                    ctx.fillRect(hx - 22, hy - 50, 6, 50);
                    ctx.fillRect(hx + 16, hy - 50, 6, 50);
                    ctx.strokeRect(hx - 22, hy - 50, 6, 50);
                    ctx.strokeRect(hx + 16, hy - 50, 6, 50);
                    
                    // Yellow stripes
                    ctx.fillStyle = '#ffcc00';
                    for (let i = 0; i < 3; i++) {
                        ctx.fillRect(hx - 20, hy - 10 - i * 15, 40, 4);
                    }
                    
                    // Arrow
                    const arrowBounce = Math.sin(this.gameTime * 2) * 5;
                    ctx.fillStyle = '#00ff00';
                    ctx.beginPath();
                    ctx.moveTo(hx, hy - 55 + arrowBounce);
                    ctx.lineTo(hx - 8, hy - 45 + arrowBounce);
                    ctx.lineTo(hx + 8, hy - 45 + arrowBounce);
                    ctx.fill();
                }
                
                // Draw AI workers (small robots)
                this.state.aiWorkers.forEach(worker => {
                    const wPos = this.toIso(worker.x - camX, 0, worker.z - camZ);
                    const wx = offsetX + wPos.x;
                    const wy = offsetY + wPos.y - 15;
                    
                    // Body
                    ctx.fillStyle = '#6a6aff';
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 2;
                    ctx.fillRect(wx - 8, wy - 10, 16, 20);
                    ctx.strokeRect(wx - 8, wy - 10, 16, 20);
                    
                    // Head
                    ctx.fillStyle = '#8888ff';
                    ctx.beginPath();
                    ctx.arc(wx, wy - 16, 8, 0, Math.PI * 2);
                    ctx.fill(); ctx.stroke();
                    
                    // Eyes (LEDs)
                    ctx.fillStyle = '#00ff00';
                    ctx.fillRect(wx - 4, wy - 18, 3, 3);
                    ctx.fillRect(wx + 1, wy - 18, 3, 3);
                    
                    // Antenna
                    ctx.strokeStyle = '#888';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(wx, wy - 24);
                    ctx.lineTo(wx, wy - 30);
                    ctx.stroke();
                    ctx.fillStyle = '#ff0000';
                    ctx.beginPath();
                    ctx.arc(wx, wy - 30, 2, 0, Math.PI * 2);
                    ctx.fill();
                });
                
                // Draw player car at its world position
                const carPos = this.toIso(this.player.x - camX, 0, this.player.z - camZ);
                const carScreenX = offsetX + carPos.x;
                const carScreenY = offsetY + carPos.y - 15;
                const worldAngle = this.player.angle || 0;
                const isoAngle = worldAngle + Math.PI / 4;
                ctx.save();
                ctx.translate(carScreenX, carScreenY);
                ctx.rotate(isoAngle);
                
                // Car shadow
                ctx.fillStyle = 'rgba(0,0,0,0.2)';
                ctx.beginPath();
                ctx.ellipse(0, 18, 20, 8, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Car body
                ctx.fillStyle = '#2266cc';
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.roundRect(-15, -22, 30, 44, 6);
                ctx.fill(); ctx.stroke();
                
                // Windshield
                ctx.fillStyle = '#88ccff';
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.roundRect(-10, -16, 20, 10, 3);
                ctx.fill(); ctx.stroke();
                
                // Rear window
                ctx.beginPath();
                ctx.roundRect(-8, 10, 16, 8, 3);
                ctx.fill(); ctx.stroke();
                
                // Headlights
                ctx.fillStyle = '#ffffaa';
                ctx.beginPath();
                ctx.arc(-9, -20, 3, 0, Math.PI * 2);
                ctx.arc(9, -20, 3, 0, Math.PI * 2);
                ctx.fill();
                
                // Wheels
                ctx.fillStyle = '#222';
                ctx.fillRect(-17, -12, 5, 10);
                ctx.fillRect(12, -12, 5, 10);
                ctx.fillRect(-17, 6, 5, 10);
                ctx.fillRect(12, 6, 5, 10);
                
                // Driver head
                ctx.fillStyle = '#ffcc99';
                ctx.beginPath();
                ctx.arc(0, -2, 5, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 1;
                ctx.stroke();
                
                ctx.restore();
                
                // Draw spectators
                this.drawAnimeSpectators();
            }
            
            drawAnimeBackground() {
                const ctx = this.ctx;
                const canvas = this.canvas;
                
                // Gradient sky (anime style)
                const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
                gradient.addColorStop(0, '#87CEEB');
                gradient.addColorStop(0.5, '#FFB6C1');
                gradient.addColorStop(1, '#FFA07A');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Simple puffy anime clouds
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 3;
                const cloudTime = this.gameTime * 10;
                for (let i = 0; i < 5; i++) {
                    const x = ((cloudTime + i * 200) % (canvas.width + 200)) - 100;
                    const y = 50 + i * 80;
                    this.drawCloud(x, y);
                }
            }
            
            drawCloud(x, y) {
                const ctx = this.ctx;
                ctx.beginPath();
                ctx.arc(x, y, 30, 0, Math.PI * 2);
                ctx.arc(x + 25, y, 35, 0, Math.PI * 2);
                ctx.arc(x + 50, y, 30, 0, Math.PI * 2);
                ctx.arc(x + 25, y - 20, 25, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
            }
            
            drawAnimeTile(x, y, color) {
                const ctx = this.ctx;
                
                // Draw with thick black outline
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 4;
                ctx.fillStyle = color;
                
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(x + 32, y + 16);
                ctx.lineTo(x, y + 32);
                ctx.lineTo(x - 32, y + 16);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
            }
            
            drawAnimeCharacter(x, y, keys) {
                const ctx = this.ctx;
                const charW = 48;
                const charH = 72;
                const charX = x - charW / 2;
                const charY = y - charH / 2;
                
                // Black outline
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 4;
                ctx.strokeRect(charX - 2, charY - 2, charW + 4, charH + 4);
                
                // Character body
                ctx.fillStyle = '#E21A2C';
                ctx.fillRect(charX, charY, charW, charH);
                
                // Anime eyes (large and expressive)
                ctx.fillStyle = '#FFFFFF';
                ctx.beginPath();
                ctx.arc(charX + 12, charY + 20, 8, 0, Math.PI * 2);
                ctx.arc(charX + 36, charY + 20, 8, 0, Math.PI * 2);
                ctx.fill();
                
                // Pupils
                ctx.fillStyle = '#000000';
                ctx.beginPath();
                ctx.arc(charX + 12, charY + 20, 4, 0, Math.PI * 2);
                ctx.arc(charX + 36, charY + 20, 4, 0, Math.PI * 2);
                ctx.fill();
                
                // Mouth (simple)
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(charX + 24, charY + 35, 10, 0, Math.PI);
                ctx.stroke();
            }
            
            drawAnimeWorker(x, y) {
                const ctx = this.ctx;
                const size = 32;
                
                // Outline
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 3;
                ctx.fillStyle = '#ff00ff';
                ctx.fillRect(x - size/2, y - size/2, size, size);
                ctx.strokeRect(x - size/2, y - size/2, size, size);
                
                // Simple face
                ctx.fillStyle = '#FFFFFF';
                ctx.fillRect(x - 8, y - 8, 4, 4);
                ctx.fillRect(x + 4, y - 8, 4, 4);
            }
            
            drawSpeedLines(x, y) {
                const ctx = this.ctx;
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.lineWidth = 4;
                
                for (let i = 0; i < 6; i++) {
                    const offsetX = x - 60 - (i * 20);
                    const offsetY = y - 20 + (Math.random() * 60);
                    ctx.beginPath();
                    ctx.moveTo(offsetX, offsetY);
                    ctx.lineTo(offsetX - 50, offsetY);
                    ctx.stroke();
                }
            }
            
            drawAnimeSparkles(x, y, time) {
                const ctx = this.ctx;
                ctx.fillStyle = '#FFD700';
                
                for (let i = 0; i < 4; i++) {
                    const angle = (time * 50 + i * 90) % 360;
                    const rad = angle * Math.PI / 180;
                    const dist = 25 + Math.sin(time * 3 + i) * 8;
                    const sx = x + Math.cos(rad) * dist;
                    const sy = y + Math.sin(rad) * dist;
                    
                    // 4-pointed star
                    ctx.save();
                    ctx.translate(sx, sy);
                    ctx.rotate(angle * Math.PI / 180);
                    ctx.beginPath();
                    ctx.moveTo(0, -6);
                    ctx.lineTo(1.5, -1.5);
                    ctx.lineTo(6, 0);
                    ctx.lineTo(1.5, 1.5);
                    ctx.lineTo(0, 6);
                    ctx.lineTo(-1.5, 1.5);
                    ctx.lineTo(-6, 0);
                    ctx.lineTo(-1.5, -1.5);
                    ctx.closePath();
                    ctx.fill();
                    ctx.restore();
                }
            }
            
            drawIsoTile(x, y, z, color, offsetX, offsetY) {
                const ctx = this.ctx;
                const pos = this.toIso(x - this.player.x, y, z - this.player.z);
                
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.moveTo(offsetX + pos.x, offsetY + pos.y);
                ctx.lineTo(offsetX + pos.x + 32, offsetY + pos.y + 16);
                ctx.lineTo(offsetX + pos.x, offsetY + pos.y + 32);
                ctx.lineTo(offsetX + pos.x - 32, offsetY + pos.y + 16);
                ctx.closePath();
                ctx.fill();
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 1;
                ctx.stroke();
            }
            
            toIso(x, y, z) {
                return {
                    x: (x - z) * 32,
                    y: (x + z) * 16 - y * 24
                };
            }
            
            drawAnimeSpectators() {
                const ctx = this.ctx;
                
                this.currentLevelSpectators.forEach(spectator => {
                    // Decrease speech timer
                    if (spectator.speechTimer > 0) {
                        spectator.speechTimer--;
                        if (spectator.speechTimer === 0) {
                            spectator.speechBubble = '';
                        }
                    }
                    
                    // Character body (anime style)
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 3;
                    ctx.fillStyle = spectator.color;
                    ctx.fillRect(spectator.x, spectator.y, 40, 60);
                    ctx.strokeRect(spectator.x, spectator.y, 40, 60);
                    
                    // Big anime eyes
                    ctx.fillStyle = '#FFFFFF';
                    ctx.beginPath();
                    ctx.arc(spectator.x + 12, spectator.y + 20, 6, 0, Math.PI * 2);
                    ctx.arc(spectator.x + 28, spectator.y + 20, 6, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.fillStyle = '#000';
                    ctx.beginPath();
                    ctx.arc(spectator.x + 12, spectator.y + 20, 3, 0, Math.PI * 2);
                    ctx.arc(spectator.x + 28, spectator.y + 20, 3, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Name label
                    ctx.fillStyle = '#000';
                    ctx.font = 'bold 10px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(spectator.name.split(' ')[0], spectator.x + 20, spectator.y + 75);
                    
                    // Speech bubble
                    if (spectator.speechBubble) {
                        ctx.fillStyle = '#FFF';
                        ctx.strokeStyle = '#000';
                        ctx.lineWidth = 2;
                        const bx = spectator.x + 50, by = spectator.y - 30;
                        ctx.fillRect(bx, by, 100, 30);
                        ctx.strokeRect(bx, by, 100, 30);
                        
                        // Triangle pointer
                        ctx.beginPath();
                        ctx.moveTo(bx, by + 20);
                        ctx.lineTo(bx - 10, by + 15);
                        ctx.lineTo(bx, by + 10);
                        ctx.closePath();
                        ctx.fill();
                        ctx.stroke();
                        
                        ctx.fillStyle = '#000';
                        ctx.font = '12px Arial';
                        ctx.textAlign = 'left';
                        ctx.fillText(spectator.speechBubble, bx + 5, by + 18);
                    }
                });
            }
            
            drawPixelSpectators() {
                const ctx = this.ctx;
                const canvas = this.canvas;
                const s = 5; // bigger pixel scale
                const count = this.currentLevelSpectators.length;
                if (count === 0) return;
                
                // Arrange spectators along the bottom edge
                const totalWidth = canvas.width - 40;
                const spacing = Math.min(60, totalWidth / count);
                const startX = (canvas.width - spacing * (count - 1)) / 2;
                const baseY = canvas.height - 70;
                
                this.currentLevelSpectators.forEach((spectator, i) => {
                    const cx = Math.floor(startX + i * spacing);
                    const cy = baseY;
                    const bobble = Math.sin(this.gameTime * 2 + i * 1.3) * 2;
                    const col = spectator.color || '#888';
                    
                    // Shadow
                    ctx.fillStyle = 'rgba(0,0,0,0.3)';
                    ctx.fillRect(cx - 3*s, cy + 5*s + 2, 6*s, s);
                    
                    // Legs
                    const legKick = Math.sin(this.gameTime * 3 + i) * s * 0.3;
                    ctx.fillStyle = '#334';
                    ctx.fillRect(cx - 2*s, cy + 3*s, s, 2*s + legKick);
                    ctx.fillRect(cx + 1*s, cy + 3*s, s, 2*s - legKick);
                    
                    // Shoes
                    ctx.fillStyle = '#222';
                    ctx.fillRect(cx - 2*s - 1, cy + 5*s + legKick, s + 2, s);
                    ctx.fillRect(cx + 1*s - 1, cy + 5*s - legKick, s + 2, s);
                    
                    // Body
                    ctx.fillStyle = col;
                    ctx.fillRect(cx - 2*s, cy + bobble, 4*s, 3*s);
                    // Shirt highlight
                    ctx.fillStyle = 'rgba(255,255,255,0.2)';
                    ctx.fillRect(cx - s, cy + bobble, 2*s, s);
                    
                    // Arms
                    const wave = Math.sin(this.gameTime * 4 + i * 2);
                    ctx.fillStyle = col;
                    ctx.fillRect(cx - 3*s, cy + bobble + (wave > 0.5 ? -s : 0), s, 2*s);
                    ctx.fillRect(cx + 2*s, cy + bobble, s, 2*s);
                    // Hands
                    ctx.fillStyle = '#ffcc99';
                    ctx.fillRect(cx - 3*s, cy + bobble + 2*s + (wave > 0.5 ? -s : 0), s, s);
                    ctx.fillRect(cx + 2*s, cy + bobble + 2*s, s, s);
                    
                    // Head
                    ctx.fillStyle = '#ffcc99';
                    ctx.fillRect(cx - 1.5*s, cy - 3*s + bobble, 3*s, 3*s);
                    
                    // Hair
                    const hairColors = ['#331100', '#ffdd44', '#884422', '#222', '#cc4400', '#666'];
                    ctx.fillStyle = hairColors[i % hairColors.length];
                    ctx.fillRect(cx - 1.5*s, cy - 3.5*s + bobble, 3*s, s);
                    ctx.fillRect(cx - 2*s, cy - 3*s + bobble, s*0.5, 2*s);
                    
                    // Eyes (blink)
                    const blink = Math.sin(this.gameTime * 0.8 + i * 5) > 0.95;
                    ctx.fillStyle = '#000';
                    if (!blink) {
                        ctx.fillRect(cx - s, cy - 2*s + bobble, s*0.7, s*0.7);
                        ctx.fillRect(cx + s*0.3, cy - 2*s + bobble, s*0.7, s*0.7);
                    } else {
                        ctx.fillRect(cx - s, cy - 1.5*s + bobble, s*0.7, 2);
                        ctx.fillRect(cx + s*0.3, cy - 1.5*s + bobble, s*0.7, 2);
                    }
                    
                    // Mouth
                    ctx.fillRect(cx - s*0.5, cy - 0.5*s + bobble, s, 2);
                    
                    // Name tag with background
                    const name = spectator.name || '';
                    ctx.font = 'bold 10px monospace';
                    ctx.textAlign = 'center';
                    const tw = ctx.measureText(name).width;
                    ctx.fillStyle = 'rgba(0,0,0,0.7)';
                    ctx.fillRect(cx - tw/2 - 3, cy - 5*s + bobble - 2, tw + 6, 14);
                    ctx.fillStyle = '#0ff';
                    ctx.fillText(name, cx, cy - 4*s + bobble + 6);
                });
            }
            
            updatePhase3(dt) {
                // Automation - mostly passive
                let productionRate = 1; // Base rate: 1 OKR/sec always
                
                this.automationNodes.forEach(node => {
                    productionRate += node.rate;
                });
                
                // AI workers contribute
                const workerContribution = this.state.aiWorkers.length * 0.5;
                productionRate += workerContribution;
                
                // Auto-collect OKRs
                const okrsThisFrame = productionRate * dt;
                this.state.okrsCollected += okrsThisFrame;
                this.state.totalOKRs += okrsThisFrame;
                
                // AC regenerates passively (faster with more nodes)
                this.state.currencies.ac += (1 + this.automationNodes.length * 0.5) * dt;
                
                // Check completion
                if (this.state.okrsCollected >= this.currentLevelData.okrGoal) {
                    this.completeLevel();
                }
                
                this.updateUI();
                this.renderPhase3(productionRate);
            }
            
            renderPhase3(rate) {
                const ctx = this.ctx;
                const canvas = this.canvas;
                
                // CRITICAL: Pixel-perfect rendering
                ctx.imageSmoothingEnabled = false;
                
                // Dark pixel background
                ctx.fillStyle = '#0a0a0a';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Pixel grid (every 3 pixels)
                const pixelScale = 3;
                ctx.strokeStyle = 'rgba(0, 200, 255, 0.15)';
                ctx.lineWidth = 1;
                for (let i = 0; i < canvas.width; i += 60) {
                    ctx.beginPath();
                    ctx.moveTo(i, 0);
                    ctx.lineTo(i, canvas.height);
                    ctx.stroke();
                }
                for (let i = 0; i < canvas.height; i += 60) {
                    ctx.beginPath();
                    ctx.moveTo(0, i);
                    ctx.lineTo(canvas.width, i);
                    ctx.stroke();
                }
                
                // Draw automation nodes as pixel blocks
                // Draw central OKR Factory first (behind connections)
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                this.drawOKRFactory(centerX, centerY);
                
                // Draw connections from each node back to central factory, then the nodes on top
                this.automationNodes.forEach((node, i) => {
                    this.drawPixelConnection(node.x, node.y, centerX, centerY, node.name);
                    this.drawPixelNode(node.x, node.y, node.rate, node.name);
                });
                
                // Draw central HUD overlay on top of factory
                
                // Production rate display (pixel font style)
                ctx.fillStyle = '#0ff';
                ctx.font = 'bold 48px monospace';
                ctx.textAlign = 'center';
                ctx.fillText(`${Math.floor(rate)}/s`, Math.floor(centerX), Math.floor(centerY - 100));
                
                // Pixel progress square
                const progress = this.state.okrsCollected / this.currentLevelData.okrGoal;
                const size = 120;
                
                // Outer square
                ctx.strokeStyle = 'rgba(0, 255, 255, 0.3)';
                ctx.lineWidth = 6;
                ctx.strokeRect(
                    Math.floor(centerX - size/2), 
                    Math.floor(centerY - size/2), 
                    size, 
                    size
                );
                
                // Progress fill (pixelated)
                const fillHeight = Math.floor(size * progress);
                ctx.fillStyle = '#0ff';
                ctx.fillRect(
                    Math.floor(centerX - size/2 + 6),
                    Math.floor(centerY + size/2 - fillHeight - 6),
                    size - 12,
                    fillHeight
                );
                
                // OKR count (pixel style)
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 20px monospace';
                ctx.fillText(
                    `${this.formatNumber(this.state.okrsCollected)} / ${this.formatNumber(this.currentLevelData.okrGoal)}`,
                    Math.floor(centerX),
                    Math.floor(centerY + 10)
                );
                
                // AC balance and help text
                ctx.fillStyle = '#ffcc00';
                ctx.font = 'bold 24px monospace';
                ctx.fillText(
                    `AC: ${Math.floor(this.state.currencies.ac)}`,
                    Math.floor(centerX),
                    Math.floor(centerY + size/2 + 40)
                );
                ctx.fillStyle = '#888';
                ctx.font = '14px monospace';
                ctx.fillText(
                    'AC regenerates over time. Click canvas to place automation buildings.',
                    Math.floor(centerX),
                    Math.floor(centerY + size/2 + 65)
                );
                ctx.fillText(
                    `Nodes: ${this.automationNodes.length} | Workers: ${this.state.aiWorkers.length}`,
                    Math.floor(centerX),
                    Math.floor(centerY + size/2 + 85)
                );
                
                // CRT scanlines effect
                this.drawScanlines();
                
                // Draw spectators
                this.drawPixelSpectators();
            }
            
            drawPixelNode(x, y, rate, name) {
                const ctx = this.ctx;
                const s = 4; // pixel scale for pixel-art look
                const bx = Math.floor(x);
                const by = Math.floor(y);
                const pulse = Math.sin(this.gameTime * 3) * 0.15 + 0.85;
                
                if (name === 'Collector') {
                    // Green funnel/hopper shape
                    const c1 = '#22cc44', c2 = '#115522', hi = '#66ff88';
                    // Glow
                    ctx.fillStyle = `rgba(34, 204, 68, ${0.25 * pulse})`;
                    ctx.beginPath(); ctx.arc(bx, by, 28, 0, Math.PI * 2); ctx.fill();
                    // Base plate
                    this._pxRect(ctx, bx - 5*s, by + 2*s, 10*s, 2*s, c2);
                    // Hopper body (trapezoid via rects)
                    this._pxRect(ctx, bx - 4*s, by - 1*s, 8*s, 3*s, c1);
                    this._pxRect(ctx, bx - 5*s, by - 3*s, 10*s, 2*s, c1);
                    this._pxRect(ctx, bx - 6*s, by - 5*s, 12*s, 2*s, c1);
                    // Highlight edge
                    this._pxRect(ctx, bx - 6*s, by - 5*s, 2*s, 2*s, hi);
                    this._pxRect(ctx, bx - 5*s, by - 3*s, 2*s, 2*s, hi);
                    // Funnel opening
                    this._pxRect(ctx, bx - 2*s, by + 1*s, 4*s, 1*s, c2);
                    // Spinning coin inside (animated)
                    const coinW = Math.abs(Math.cos(this.gameTime * 4)) * 3 * s;
                    ctx.fillStyle = '#ffd700';
                    ctx.fillRect(bx - coinW/2, by - 2*s, coinW, 2*s);
                } else if (name === 'Processor') {
                    // Blue circuit board / chip
                    const c1 = '#2266dd', c2 = '#113388', hi = '#55aaff', pin = '#88ccff';
                    ctx.fillStyle = `rgba(34, 102, 221, ${0.25 * pulse})`;
                    ctx.beginPath(); ctx.arc(bx, by, 30, 0, Math.PI * 2); ctx.fill();
                    // Chip body
                    this._pxRect(ctx, bx - 5*s, by - 5*s, 10*s, 10*s, c1);
                    this._pxRect(ctx, bx - 4*s, by - 4*s, 8*s, 8*s, c2);
                    // Inner die
                    this._pxRect(ctx, bx - 2*s, by - 2*s, 4*s, 4*s, hi);
                    // Blinking core
                    ctx.fillStyle = pulse > 0.9 ? '#ffffff' : '#55aaff';
                    ctx.fillRect(bx - s/2, by - s/2, s, s);
                    // Pins on each side
                    for (let i = -2; i <= 2; i++) {
                        this._pxRect(ctx, bx + i*2*s - s/2, by - 6*s, s, s, pin);
                        this._pxRect(ctx, bx + i*2*s - s/2, by + 5*s, s, s, pin);
                        this._pxRect(ctx, bx - 6*s, by + i*2*s - s/2, s, s, pin);
                        this._pxRect(ctx, bx + 5*s, by + i*2*s - s/2, s, s, pin);
                    }
                    // Circuit traces
                    ctx.strokeStyle = pin; ctx.lineWidth = 1;
                    ctx.strokeRect(bx - 3*s, by - 3*s, 6*s, 6*s);
                } else if (name === 'Multiplier') {
                    // Purple crystal / prism shape
                    const c1 = '#aa44ff', c2 = '#661199', hi = '#dd88ff', spark = '#ffccff';
                    ctx.fillStyle = `rgba(170, 68, 255, ${0.3 * pulse})`;
                    ctx.beginPath(); ctx.arc(bx, by, 32, 0, Math.PI * 2); ctx.fill();
                    // Crystal base
                    this._pxRect(ctx, bx - 4*s, by + 2*s, 8*s, 2*s, c2);
                    // Main crystal body (diamond shape via stacked rects)
                    this._pxRect(ctx, bx - 1*s, by + 2*s, 2*s, 1*s, c1);
                    this._pxRect(ctx, bx - 2*s, by + 0*s, 4*s, 2*s, c1);
                    this._pxRect(ctx, bx - 3*s, by - 3*s, 6*s, 3*s, c1);
                    this._pxRect(ctx, bx - 2*s, by - 5*s, 4*s, 2*s, c1);
                    this._pxRect(ctx, bx - 1*s, by - 6*s, 2*s, 1*s, hi);
                    // Highlight facets
                    this._pxRect(ctx, bx - 3*s, by - 2*s, 1*s, 2*s, hi);
                    this._pxRect(ctx, bx - 2*s, by - 4*s, 1*s, 2*s, hi);
                    // Sparkle particles
                    const sparkles = [[3, -4], [-4, -1], [4, 2], [-3, -5]];
                    sparkles.forEach(([sx, sy]) => {
                        const flicker = Math.sin(this.gameTime * 5 + sx * sy) > 0.3;
                        if (flicker) this._pxRect(ctx, bx + sx*s, by + sy*s, s, s, spark);
                    });
                } else if (name === 'Synthesizer') {
                    // Red/orange reactor with spinning energy ring
                    const c1 = '#ff4422', c2 = '#991100', hi = '#ff8844', core = '#ffcc00';
                    ctx.fillStyle = `rgba(255, 68, 34, ${0.3 * pulse})`;
                    ctx.beginPath(); ctx.arc(bx, by, 36, 0, Math.PI * 2); ctx.fill();
                    // Reactor shell (octagon-ish via rects)
                    this._pxRect(ctx, bx - 3*s, by - 5*s, 6*s, 10*s, c2);
                    this._pxRect(ctx, bx - 5*s, by - 3*s, 10*s, 6*s, c2);
                    this._pxRect(ctx, bx - 4*s, by - 4*s, 8*s, 8*s, c1);
                    // Inner chamber
                    this._pxRect(ctx, bx - 2*s, by - 2*s, 4*s, 4*s, '#220000');
                    // Pulsing core
                    const coreSize = Math.floor(1 + pulse * 2);
                    ctx.fillStyle = core;
                    ctx.fillRect(bx - coreSize*s/2, by - coreSize*s/2, coreSize*s, coreSize*s);
                    // Highlight vents
                    this._pxRect(ctx, bx - 4*s, by - 1*s, 1*s, 2*s, hi);
                    this._pxRect(ctx, bx + 3*s, by - 1*s, 1*s, 2*s, hi);
                    this._pxRect(ctx, bx - 1*s, by - 4*s, 2*s, 1*s, hi);
                    this._pxRect(ctx, bx - 1*s, by + 3*s, 2*s, 1*s, hi);
                    // Energy ring (rotating dots)
                    const ringR = 5 * s;
                    for (let a = 0; a < 8; a++) {
                        const ang = this.gameTime * 2 + a * Math.PI / 4;
                        const rx = bx + Math.cos(ang) * ringR;
                        const ry = by + Math.sin(ang) * ringR;
                        ctx.fillStyle = a % 2 === 0 ? '#ffcc00' : '#ff6600';
                        ctx.fillRect(Math.floor(rx) - s/2, Math.floor(ry) - s/2, s, s);
                    }
                } else {
                    // Fallback gold block
                    ctx.fillStyle = '#ffd700';
                    ctx.fillRect(bx - 12, by - 12, 24, 24);
                    ctx.strokeStyle = '#000'; ctx.lineWidth = 3;
                    ctx.strokeRect(bx - 12, by - 12, 24, 24);
                }
                
                // Name label
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 10px monospace';
                ctx.textAlign = 'center';
                ctx.fillText(name, bx, by + 32);
                // Rate text
                ctx.fillStyle = '#aaffaa';
                ctx.font = 'bold 12px monospace';
                ctx.fillText(`+${rate}/s`, bx, by + 44);
            }
            
            _pxRect(ctx, x, y, w, h, color) {
                ctx.fillStyle = color;
                ctx.fillRect(Math.floor(x), Math.floor(y), Math.floor(w), Math.floor(h));
            }
            
            drawPixelConnection(x1, y1, x2, y2) {
                const ctx = this.ctx;
                
                // Pixelated line
                ctx.strokeStyle = 'rgba(0, 255, 255, 0.6)';
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.moveTo(Math.floor(x1), Math.floor(y1));
                ctx.lineTo(Math.floor(x2), Math.floor(y2));
                ctx.stroke();
                
                // Animated pixel dots
                const dist = Math.sqrt((x2-x1)**2 + (y2-y1)**2);
                const steps = Math.floor(dist / 30);
                const animOffset = (this.gameTime * 50) % 30;
                
                ctx.fillStyle = '#00ffff';
                for (let i = 0; i < steps; i++) {
                    const t = (i * 30 + animOffset) / dist;
                    if (t <= 1) {
                        const px = Math.floor(x1 + (x2 - x1) * t);
                        const py = Math.floor(y1 + (y2 - y1) * t);
                        ctx.fillRect(px - 3, py - 3, 6, 6);
                    }
                }
            }
            
            drawScanlines() {
                const ctx = this.ctx;
                const canvas = this.canvas;
                
                ctx.globalAlpha = 0.15;
                ctx.fillStyle = '#000000';
                for (let y = 0; y < canvas.height; y += 6) {
                    ctx.fillRect(0, y, canvas.width, 2);
                }
                ctx.globalAlpha = 1.0;
            }
            
            formatNumber(num) {
                if (num >= 1000000) return (num / 1000000).toFixed(1) + 'M';
                if (num >= 1000) return (num / 1000).toFixed(1) + 'K';
                return Math.floor(num).toString();
            }
            
            collectOKR() {
                this.state.okrsCollected++;
                this.state.totalOKRs++;
                this.updateUI();
                
                // Make spectators react
                this.currentLevelSpectators.forEach(spec => {
                    if (spec.cheer) spec.cheer();
                    if (spec.react) spec.react('okr');
                });
            }
            
            respawnPlayer() {
                // Reset player position to start
                this.player.position.set(0, 2, 0);
                this.playerVelocity = { x: 0, y: 0, z: 0 };
                this.isGrounded = false;
                console.log('Player respawned after falling');
            }
            
            playLiftAnimation() {
                this.liftAnimating = true;
                this.paused = true;
                
                // Move car onto the lift
                const liftPos = this.jrodHQ.position.clone();
                this.player.position.set(liftPos.x, liftPos.y + 0.5, liftPos.z);
                this.player.rotation.y = 0;
                this.playerVelocity = { x: 0, y: 0, z: 0 };
                
                // Find the lift platform inside the group
                let liftPlatformMesh = null;
                this.jrodHQ.traverse(child => {
                    if (child.name === 'liftPlatform') liftPlatformMesh = child;
                });
                
                const startY = this.player.position.y;
                const liftHeight = 4;
                const duration = 1500;
                const startTime = Date.now();
                
                const animateLift = () => {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    // Ease-out curve
                    const ease = 1 - Math.pow(1 - progress, 3);
                    const currentY = startY + liftHeight * ease;
                    
                    this.player.position.y = currentY;
                    if (liftPlatformMesh) {
                        liftPlatformMesh.position.y = 0.3 + liftHeight * ease;
                    }
                    
                    // Keep rendering during animation
                    this.camera.position.x = this.player.position.x + this.cameraOffset.x;
                    this.camera.position.y = this.player.position.y + this.cameraOffset.y;
                    this.camera.position.z = this.player.position.z + this.cameraOffset.z;
                    this.camera.lookAt(this.player.position);
                    this.renderer.render(this.scene, this.camera);
                    
                    if (progress < 1) {
                        requestAnimationFrame(animateLift);
                    } else {
                        // Animation done â€” complete the level
                        setTimeout(() => {
                            this.paused = false;
                            this.completeLevel();
                            // Reset liftAnimating AFTER loadLevel runs
                            setTimeout(() => { this.liftAnimating = false; }, 500);
                        }, 500);
                    }
                };
                
                animateLift();
            }
            
            completeLevel() {
                if (this.levelCompleting) return;
                this.levelCompleting = true;
                
                const config = this.currentLevelData;
                
                // Make spectators react to completion
                this.currentLevelSpectators.forEach(spec => {
                    if (spec.cheer) spec.cheer();
                    if (spec.react) spec.react('complete');
                });
                
                // Award currency
                const currencyType = config.currency;
                this.state.currencies[currencyType] += config.reward;
                
                // Mark as completed
                if (!this.state.completedLevels.includes(this.state.currentLevel)) {
                    this.state.completedLevels.push(this.state.currentLevel);
                }
                
                // Unlock abilities
                if (config.unlock === 'sprint') {
                    this.state.playerStats.sprint = 1;
                }
                if (config.unlock === 'doubleJump') {
                    this.canDoubleJump = true;
                }
                
                // Check for evolution
                if (config.evolution === 1) {
                    this.triggerEvolution1();
                } else if (config.evolution === 2) {
                    this.triggerEvolution2();
                } else if (config.final) {
                    this.showVictoryScreen();
                } else {
                    // Next level
                    console.log(`Level ${this.state.currentLevel} complete! Loading level ${this.state.currentLevel + 1}`);
                    setTimeout(() => {
                        this.loadLevel(this.state.currentLevel + 1);
                    }, 1000);
                }
                
                this.saveGame();
            }
            
            triggerEvolution1() {
                this.paused = true;
                
                const cutscene = document.getElementById('cutscene');
                const text = document.getElementById('cutsceneText');
                
                cutscene.style.display = 'flex';
                cutscene.className = '';
                cutscene.style.background = 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)';
                text.style.color = '#fff';
                text.style.fontSize = '48px';
                text.style.textShadow = '0 0 20px rgba(255,255,255,0.8)';
                
                const messages = [
                    'â­ EVOLUTION INITIATED â­',
                    'Manual processes... OBSOLETE',
                    'Transitioning to ANIME DIMENSION',
                    'âœ¨ PHASE 2: TEAM MANAGER MODE âœ¨'
                ];
                
                let i = 0;
                const showMessage = () => {
                    if (i < messages.length) {
                        text.textContent = messages[i];
                        
                        // Flash effect on last message
                        if (i === messages.length - 1) {
                            cutscene.style.animation = 'flash 0.5s infinite';
                        }
                        
                        i++;
                        setTimeout(showMessage, 2500);
                    } else {
                        // Dramatic transition effect
                        cutscene.style.animation = 'none';
                        text.textContent = 'ðŸŒ¸ ENTERING ANIME WORLD ðŸŒ¸';
                        
                        setTimeout(() => {
                            // Apply evolution changes
                            this.state.currencies.mp = 0;
                            this.state.currencies.dp = 0;
                            
                            // Keep 50% of stats
                            Object.keys(this.state.playerStats).forEach(key => {
                                if (typeof this.state.playerStats[key] === 'number') {
                                    this.state.playerStats[key] *= 0.5;
                                }
                            });
                            
                            cutscene.style.display = 'none';
                            this.setupPhase2();
                            this.loadLevel(6);
                            this.paused = false;
                        }, 2000);
                    }
                };
                
                showMessage();
            }
            
            triggerEvolution2() {
                this.paused = true;
                
                const cutscene = document.getElementById('cutscene');
                const text = document.getElementById('cutsceneText');
                
                cutscene.style.display = 'flex';
                cutscene.className = 'glitch';
                cutscene.style.background = '#000';
                text.style.color = '#0ff';
                text.style.fontSize = '42px';
                text.style.textShadow = '0 0 10px #0ff, 0 0 20px #0ff';
                
                const messages = [
                    'âš  SYSTEM OVERLOAD âš ',
                    'Entering RETRO DIMENSION',
                    'Manual control... UNNECESSARY',
                    'â–ˆ PHASE 3: AUTOMATION SINGULARITY â–ˆ'
                ];
                
                let i = 0;
                let pixelation = 1;
                
                const showMessage = () => {
                    if (i < messages.length) {
                        text.textContent = messages[i];
                        
                        // Progressive pixelation effect
                        if (i > 1) {
                            this.ctx.imageSmoothingEnabled = false;
                            pixelation += 0.3;
                        }
                        
                        i++;
                        setTimeout(showMessage, 2500);
                    } else {
                        // Pixelation transition
                        text.textContent = 'â–“â–’â–‘ ENTERING THE GRID â–‘â–’â–“';
                        
                        const pixelateInterval = setInterval(() => {
                            pixelation += 0.2;
                            
                            if (pixelation >= 3) {
                                clearInterval(pixelateInterval);
                                
                                setTimeout(() => {
                                    // Apply evolution changes
                                    this.state.currencies.ac = 0;
                                    this.state.currencies.mp = 0;
                                    
                                    cutscene.style.display = 'none';
                                    this.setupPhase3();
                                    this.loadLevel(11);
                                    this.paused = false;
                                }, 1000);
                            }
                        }, 150);
                    }
                };
                
                showMessage();
            }
            
            showVictoryScreen() {
                this.paused = true;
                
                const menu = document.getElementById('menu');
                menu.innerHTML = `
                    <h1 class="glow">DIGITAL TRANSFORMATION COMPLETE!</h1>
                    <p style="font-size: 24px; margin: 20px 0;">Total OKRs: ${this.formatNumber(this.state.totalOKRs)}</p>
                    <p style="margin: 10px 0;">Choose your ending:</p>
                    <button onclick="game.ending('retire')">ðŸŒ´ RETIRE - Watch forever</button>
                    <button onclick="game.ending('merge')">ðŸ¤– MERGE - Become the system</button>
                    <button onclick="game.ending('restart')">ðŸ”„ RESTART - New Game+ (2x bonuses)</button>
                `;
                menu.style.display = 'block';
            }
            
            ending(type) {
                const menu = document.getElementById('menu');
                
                if (type === 'retire') {
                    menu.innerHTML = '<h1>You retire to a beach somewhere...</h1><p>The automation runs eternally.</p>';
                } else if (type === 'merge') {
                    menu.innerHTML = '<h1>You become one with the system.</h1><p>Digital consciousness achieved.</p>';
                } else if (type === 'restart') {
                    localStorage.removeItem('teamDominosGame');
                    location.reload();
                }
            }
            
            hireWorker() {
                if (this.state.currencies.mp >= this.hireCost) {
                    this.state.currencies.mp -= this.hireCost;
                    
                    this.state.aiWorkers.push({
                        id: this.workerIdCounter++,
                        x: this.player.x,
                        y: 0,
                        z: this.player.z,
                        targetOKR: null
                    });
                    
                    this.hireCost = Math.floor(this.hireCost * 1.5);
                    document.getElementById('hireCost').textContent = this.hireCost;
                    
                    this.updateWorkerUI();
                    this.updateUI();
                }
            }
            
            updateWorkerUI() {
                const workerList = document.getElementById('workerList');
                workerList.innerHTML = '';
                
                this.state.aiWorkers.forEach(worker => {
                    const div = document.createElement('div');
                    div.className = 'worker-item';
                    div.textContent = `Worker #${worker.id} ${worker.targetOKR ? 'ðŸ”¨' : 'ðŸ’¤'}`;
                    workerList.appendChild(div);
                });
            }
            
            skipToNextLevel() {
                // Cheat for testing - instantly complete level
                this.state.okrsCollected = this.currentLevelData.okrGoal;
                this.completeLevel();
            }
            
            updateUI() {
                document.getElementById('currentLevel').textContent = this.state.currentLevel;
                document.getElementById('currentPhase').textContent = this.state.phase;
                document.getElementById('okrCount').textContent = Math.floor(this.state.okrsCollected);
                document.getElementById('okrGoal').textContent = this.formatNumber(this.currentLevelData.okrGoal);
                document.getElementById('totalOKRs').textContent = this.formatNumber(this.state.totalOKRs);
                
                const progress = Math.min(100, (this.state.okrsCollected / this.currentLevelData.okrGoal) * 100);
                document.getElementById('okrProgress').style.width = progress + '%';
                document.getElementById('okrPercent').textContent = Math.floor(progress);
                
                // Currency display
                let currencyText = '';
                if (this.state.phase === 1) {
                    currencyText = `DP: ${Math.floor(this.state.currencies.dp)}`;
                } else if (this.state.phase === 2) {
                    currencyText = `MP: ${Math.floor(this.state.currencies.mp)}`;
                } else {
                    currencyText = `AC: ${Math.floor(this.state.currencies.ac)}`;
                }
                document.getElementById('currencyDisplay').innerHTML = currencyText;
                
                // Level info
                document.getElementById('objective').textContent = this.currentLevelData.description;
                
                const phaseDesc = [
                    'Phase 1: Manual Collection',
                    'Phase 2: AI Management',
                    'Phase 3: Full Automation'
                ][this.state.phase - 1];
                document.getElementById('phaseDesc').innerHTML = `<strong>${phaseDesc}</strong>`;
            }
            
            saveGame() {
                localStorage.setItem('teamDominosGame', JSON.stringify(this.state));
                console.log('Game saved!');
            }
            
            clearSave() {
                localStorage.removeItem('teamDominosGame');
                alert('Save data cleared! Click NEW GAME to start fresh.');
            }
            
            loadGame() {
                const saved = localStorage.getItem('teamDominosGame');
                if (saved) {
                    this.state = JSON.parse(saved);
                    document.getElementById('menu').style.display = 'none';
                    this.gameStarted = true;
                    
                    if (this.state.phase === 1) {
                        this.setupPhase1();
                    } else if (this.state.phase === 2) {
                        this.setupPhase2();
                    } else {
                        this.setupPhase3();
                    }
                    
                    this.loadLevel(this.state.currentLevel);
                    this.gameLoop();
                } else {
                    alert('No saved game found!');
                }
            }
            
            gameLoop() {
                if (!this.gameStarted) return;
                
                const now = performance.now();
                this.deltaTime = Math.min((now - this.lastTime) / 1000, 0.1);
                this.lastTime = now;
                this.gameTime += this.deltaTime;
                
                if (!this.paused) {
                    if (this.state.phase === 1) {
                        this.updatePhase1(this.deltaTime);
                    } else if (this.state.phase === 2) {
                        this.updatePhase2(this.deltaTime);
                    } else if (this.state.phase === 3) {
                        this.updatePhase3(this.deltaTime);
                    }
                }
                
                requestAnimationFrame(() => this.gameLoop());
            }
        }
        
        // Initialize game
        window.game = new TeamDominosGame();
    </script>
</body>
</html>
