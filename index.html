<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
<meta name="mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="theme-color" content="#1a1a2e">
<title>Team Dominos - Delivering OKRs Since 2024</title>
<link rel="manifest" href="manifest.json">
<style>
*{margin:0;padding:0;box-sizing:border-box;}
body{background:#1a1a2e;overflow:hidden;font-family:'Courier New',monospace;color:#fff;display:flex;justify-content:center;align-items:center;height:100vh;width:100vw;}
canvas{display:block;image-rendering:pixelated;}
#ui-overlay{position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:10;}
#ui-overlay *{pointer-events:auto;}
#hud{position:absolute;top:0;left:0;width:100%;display:flex;justify-content:space-between;align-items:center;padding:8px 16px;background:linear-gradient(180deg,rgba(0,0,0,0.8) 0%,rgba(0,0,0,0) 100%);font-size:14px;z-index:20;}
.hud-item{display:flex;align-items:center;gap:6px;background:rgba(0,0,0,0.5);padding:4px 10px;border-radius:4px;border:1px solid rgba(255,255,255,0.15);}
.hud-label{color:#aaa;font-size:11px;text-transform:uppercase;}
.hud-value{color:#fff;font-weight:bold;font-size:15px;}
.hud-value.tokens{color:#E21A2C;}
.hud-value.okrs{color:#FFD700;}
.hud-value.level{color:#006491;}
#minimap-container{position:absolute;bottom:12px;right:12px;border:2px solid rgba(255,255,255,0.3);border-radius:4px;overflow:hidden;z-index:20;background:rgba(0,0,0,0.6);}
#quote-popup{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);background:linear-gradient(135deg,#E21A2C,#b5151f);color:#fff;padding:16px 28px;border-radius:12px;font-size:18px;font-weight:bold;text-align:center;opacity:0;transition:opacity 0.3s;pointer-events:none;z-index:30;border:3px solid #FFD700;max-width:400px;box-shadow:0 8px 32px rgba(0,0,0,0.5);}
#mobile-controls{position:absolute;bottom:20px;left:20px;z-index:25;display:none;}
@media(pointer:coarse){#mobile-controls{display:block;}}
.dpad-btn{position:absolute;width:70px;height:70px;background:rgba(255,255,255,0.2);border:2px solid rgba(255,255,255,0.4);border-radius:12px;display:flex;justify-content:center;align-items:center;font-size:28px;color:#fff;user-select:none;-webkit-user-select:none;touch-action:manipulation;transition:background 0.1s, transform 0.1s;}
.dpad-btn:active{background:rgba(255,255,255,0.55);transform:scale(0.95);}
#btn-up{left:74px;top:0;}
#btn-down{left:74px;top:148px;}
#btn-left{left:0;top:74px;}
#btn-right{left:148px;top:74px;}
#action-buttons{position:absolute;bottom:20px;right:20px;z-index:25;display:none;flex-direction:column;gap:10px;}
@media(pointer:coarse){#action-buttons{display:flex;}}
.action-btn{width:60px;height:60px;background:rgba(226,26,44,0.8);border:2px solid rgba(255,255,255,0.5);border-radius:50%;display:flex;justify-content:center;align-items:center;font-size:18px;color:#fff;font-weight:bold;user-select:none;touch-action:manipulation;transition:all 0.1s;}
.action-btn:active{background:rgba(226,26,44,1);transform:scale(0.9);}
#settings-btn{position:absolute;top:12px;right:12px;z-index:30;width:40px;height:40px;background:rgba(0,0,0,0.6);border:2px solid rgba(255,255,255,0.3);border-radius:8px;display:flex;align-items:center;justify-content:center;color:#fff;font-size:20px;cursor:pointer;user-select:none;}
#settings-panel{position:absolute;top:60px;right:12px;z-index:29;background:rgba(0,0,0,0.95);border:2px solid rgba(255,255,255,0.3);border-radius:8px;padding:16px;min-width:200px;display:none;}
.quality-option{padding:8px;margin:4px 0;background:rgba(255,255,255,0.1);border-radius:4px;cursor:pointer;text-align:center;font-size:13px;}
.quality-option.active{background:rgba(226,26,44,0.8);font-weight:bold;}
#screen-overlay{position:absolute;top:0;left:0;width:100%;height:100%;z-index:50;display:flex;flex-direction:column;align-items:center;justify-content:center;}
.screen-bg{background:radial-gradient(ellipse at center,#1a1a2e 0%,#0d0d1a 100%);}
.title-logo{font-size:clamp(36px,8vw,72px);font-weight:bold;color:#E21A2C;text-shadow:3px 3px 0 #006491,6px 6px 0 rgba(0,0,0,0.3);margin-bottom:4px;letter-spacing:2px;}
.title-sub{color:#FFD700;font-size:clamp(12px,2.5vw,18px);margin-bottom:40px;letter-spacing:4px;}
.menu-btn{background:linear-gradient(135deg,#E21A2C,#b5151f);color:#fff;border:none;padding:14px 40px;font-size:18px;font-family:'Courier New',monospace;font-weight:bold;cursor:pointer;border-radius:8px;margin:8px;min-width:220px;transition:transform 0.1s,box-shadow 0.1s;box-shadow:0 4px 15px rgba(226,26,44,0.4);}
.menu-btn:hover{transform:scale(1.05);box-shadow:0 6px 20px rgba(226,26,44,0.6);}
.menu-btn.secondary{background:linear-gradient(135deg,#006491,#004a6e);}
.char-grid{display:flex;flex-wrap:wrap;justify-content:center;gap:16px;max-width:750px;margin:20px 0;}
.char-card{background:rgba(255,255,255,0.08);border:2px solid rgba(255,255,255,0.15);border-radius:12px;padding:16px;width:200px;cursor:pointer;transition:all 0.2s;text-align:center;}
.char-card:hover{border-color:#E21A2C;background:rgba(226,26,44,0.15);transform:translateY(-3px);}
.char-card.selected{border-color:#FFD700;background:rgba(255,215,0,0.15);}
.char-name{font-size:16px;font-weight:bold;margin:8px 0 4px;}
.char-desc{font-size:11px;color:#aaa;margin-bottom:8px;}
.char-stat{display:flex;justify-content:space-between;font-size:12px;margin:2px 0;}
.stat-bar{height:6px;background:rgba(255,255,255,0.1);border-radius:3px;flex:1;margin-left:8px;overflow:hidden;}
.stat-fill{height:100%;border-radius:3px;}
.stat-fill.speed{background:#00cc66;}
.stat-fill.capacity{background:#FFD700;}
.back-btn{position:absolute;top:16px;left:16px;background:rgba(255,255,255,0.1);border:1px solid rgba(255,255,255,0.2);color:#fff;padding:8px 16px;font-family:'Courier New',monospace;font-size:13px;cursor:pointer;border-radius:6px;}
.back-btn:hover{background:rgba(255,255,255,0.2);}
.leaderboard-table{background:rgba(0,0,0,0.4);border-radius:8px;padding:16px;max-width:500px;width:90%;max-height:400px;overflow-y:auto;}
.lb-row{display:flex;justify-content:space-between;padding:6px 8px;border-bottom:1px solid rgba(255,255,255,0.1);font-size:13px;}
.lb-row.header{color:#FFD700;font-weight:bold;border-bottom:2px solid rgba(255,215,0,0.3);}
.level-complete-box{background:rgba(0,0,0,0.85);border:3px solid #FFD700;border-radius:16px;padding:32px;text-align:center;max-width:420px;}
.lc-title{font-size:28px;color:#FFD700;margin-bottom:8px;}
.lc-stat{font-size:15px;margin:4px 0;color:#ccc;}
.lc-quote{font-size:16px;color:#E21A2C;font-style:italic;margin:16px 0;padding:12px;background:rgba(226,26,44,0.1);border-radius:8px;}
.name-input{background:rgba(255,255,255,0.1);border:2px solid rgba(255,255,255,0.3);color:#fff;padding:10px 16px;font-size:16px;font-family:'Courier New',monospace;border-radius:8px;text-align:center;width:250px;margin:8px 0;}
.name-input:focus{outline:none;border-color:#FFD700;}
.share-text{background:rgba(0,0,0,0.5);padding:12px;border-radius:8px;font-size:11px;white-space:pre;text-align:left;max-width:350px;margin:8px auto;border:1px solid rgba(255,255,255,0.15);}
.copied-msg{color:#00cc66;font-size:13px;margin-top:4px;}
#powerup-panel{position:absolute;top:80px;left:12px;z-index:20;display:none;flex-direction:column;gap:6px;max-width:220px;}
.powerup-active{background:rgba(0,0,0,0.75);border-radius:8px;padding:8px 10px;border-left:4px solid #00FF00;display:flex;align-items:center;gap:8px;animation:powerupSlideIn 0.3s ease-out;}
@keyframes powerupSlideIn{from{transform:translateX(-100%);opacity:0;}to{transform:translateX(0);opacity:1;}}
.powerup-active.warning{animation:powerupWarning 0.3s infinite;}
@keyframes powerupWarning{0%,100%{opacity:1;}50%{opacity:0.5;}}
.powerup-icon{width:28px;height:28px;border-radius:50%;display:flex;align-items:center;justify-content:center;font-size:16px;font-weight:bold;box-shadow:0 0 10px currentColor;flex-shrink:0;}
.powerup-info{flex:1;min-width:0;}
.powerup-name{font-size:11px;font-weight:bold;color:#fff;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;}
.powerup-timer-bar{height:4px;background:rgba(255,255,255,0.2);border-radius:2px;margin-top:3px;overflow:hidden;}
.powerup-timer-fill{height:100%;background:linear-gradient(90deg,#00FF00,#FFD700,#FF0000);border-radius:2px;transition:width 0.1s linear;}
#screen-effect{position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:5;}
#loading-screen{position:fixed;top:0;left:0;width:100%;height:100%;background:linear-gradient(135deg,#1a1a2e,#0d0d1a);z-index:1000;display:flex;flex-direction:column;align-items:center;justify-content:center;transition:opacity 0.5s;}
#loading-screen.hidden{opacity:0;pointer-events:none;}
.loading-spinner{width:60px;height:60px;border:4px solid rgba(226,26,44,0.3);border-top:4px solid #E21A2C;border-radius:50%;animation:spin 1s linear infinite;}
@keyframes spin{to{transform:rotate(360deg);}}
.loading-text{color:#FFD700;font-size:18px;margin-top:20px;font-weight:bold;}
.achievement-grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(280px,1fr));gap:16px;padding:20px;max-width:900px;max-height:70vh;overflow-y:auto;}
.achievement-card{background:rgba(0,0,0,0.4);border:2px solid rgba(255,255,255,0.15);border-radius:10px;padding:14px;transition:all 0.2s;position:relative;}
.achievement-card.unlocked{border-color:#FFD700;background:rgba(255,215,0,0.1);}
.achievement-card.unlocked .ach-icon{opacity:1;transform:scale(1);}
.ach-header{display:flex;align-items:center;gap:12px;margin-bottom:8px;}
.ach-icon{width:48px;height:48px;border-radius:8px;display:flex;align-items:center;justify-content:center;font-size:24px;border:2px solid rgba(255,255,255,0.2);background:rgba(255,255,255,0.05);opacity:0.3;transform:scale(0.9);transition:all 0.3s;}
.ach-icon.unlocked{opacity:1;transform:scale(1);background:linear-gradient(135deg,#FFD700,#FFA500);border-color:#FFD700;box-shadow:0 0 20px rgba(255,215,0,0.5);}
.ach-info{flex:1;}
.ach-title{font-size:14px;font-weight:bold;color:#fff;margin-bottom:2px;}
.ach-desc{font-size:11px;color:#999;}
.ach-progress-bar{height:6px;background:rgba(255,255,255,0.1);border-radius:3px;margin-top:8px;overflow:hidden;}
.ach-progress-fill{height:100%;background:linear-gradient(90deg,#E21A2C,#FFD700);border-radius:3px;transition:width 0.3s;}
.ach-badge{position:absolute;top:8px;right:8px;background:#FFD700;color:#000;font-size:9px;padding:2px 6px;border-radius:4px;font-weight:bold;}
.difficulty-easy{border-left:4px solid #00cc66;}
.difficulty-medium{border-left:4px solid #FFA500;}
.difficulty-hard{border-left:4px solid #E21A2C;}
.difficulty-mastery{border-left:4px solid #9370DB;}
@media(orientation:portrait) and (max-width:768px){
  #hud{flex-wrap:wrap;padding:4px 8px;}
  .hud-item{padding:2px 6px;font-size:11px;}
  .hud-value{font-size:13px;}
  #minimap-container{bottom:80px;right:8px;}
  .title-logo{font-size:clamp(28px,6vw,48px);}
  .menu-btn{min-width:180px;padding:12px 30px;font-size:16px;}
  .char-grid{grid-template-columns:1fr;}
  .char-card{width:100%;max-width:300px;}
  #mobile-controls{bottom:10px;left:10px;transform:scale(0.9);}
  #action-buttons{bottom:10px;right:10px;transform:scale(0.9);}
}
@media(max-width:480px){
  .hud-label{font-size:9px;}
  .hud-value{font-size:11px;}
  #quote-popup{max-width:90%;font-size:14px;padding:12px 20px;}
  .lc-title{font-size:22px;}
  #mobile-controls{transform:scale(0.85);}
  #action-buttons{transform:scale(0.85);}
}
#achievement-popup{position:fixed;top:80px;right:-400px;background:linear-gradient(135deg,#E21A2C,#FFD700);padding:16px 20px;border-radius:12px;border:3px solid #FFD700;box-shadow:0 8px 32px rgba(0,0,0,0.7);z-index:100;transition:right 0.5s;min-width:300px;max-width:350px;}
#achievement-popup.show{right:20px;}
.ach-popup-title{font-size:13px;color:rgba(255,255,255,0.8);margin-bottom:4px;text-transform:uppercase;letter-spacing:1px;}
.ach-popup-name{font-size:18px;font-weight:bold;color:#fff;margin-bottom:4px;}
.ach-popup-desc{font-size:12px;color:rgba(255,255,255,0.9);}
.stats-grid{display:grid;grid-template-columns:repeat(2,1fr);gap:12px;max-width:600px;margin:20px auto;}
.stat-box{background:rgba(0,0,0,0.4);border:2px solid rgba(255,255,255,0.15);border-radius:8px;padding:12px;text-align:center;}
.stat-value{font-size:24px;font-weight:bold;color:#FFD700;margin-bottom:4px;}
.stat-label{font-size:11px;color:#999;text-transform:uppercase;}
/* Enhanced Visual Feedback */
#damage-overlay{position:fixed;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:5;background:radial-gradient(ellipse at center,transparent 0%,rgba(255,0,0,0) 50%,rgba(255,0,0,0.3) 100%);opacity:0;transition:opacity 0.1s;}
#damage-overlay.active{opacity:1;}
#floating-text-container{position:fixed;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:55;}
.floating-text{position:absolute;font-weight:bold;font-size:20px;text-shadow:2px 2px 4px rgba(0,0,0,0.9);animation:floatUp 1.5s ease-out forwards;pointer-events:none;}
@keyframes floatUp{0%{transform:translateY(0) scale(0.8);opacity:0;}20%{opacity:1;}100%{transform:translateY(-70px) scale(1);opacity:0;}}
.menu-btn{transition:transform 0.2s ease,box-shadow 0.2s ease,filter 0.1s ease;}
.menu-btn:hover{transform:scale(1.08) translateY(-2px);box-shadow:0 8px 25px rgba(226,26,44,0.7);filter:brightness(1.15);}
.menu-btn:active{transform:scale(1.02);filter:brightness(0.95);}
#minimap-zoom{position:absolute;bottom:-28px;right:0;display:flex;gap:2px;background:rgba(0,0,0,0.6);border-radius:4px;padding:2px;}
.zoom-btn{width:20px;height:20px;background:rgba(255,255,255,0.2);border:1px solid rgba(255,255,255,0.3);color:#fff;font-size:12px;cursor:pointer;border-radius:3px;display:flex;align-items:center;justify-content:center;user-select:none;}
.zoom-btn:hover{background:rgba(255,255,255,0.35);}
#quote-popup.show-dramatic{animation:dramaticEntry 0.5s ease-out;}
@keyframes dramaticEntry{0%{transform:translate(-50%,-50%) scale(0.5) rotate(-5deg);opacity:0;}50%{transform:translate(-50%,-50%) scale(1.15) rotate(2deg);}100%{transform:translate(-50%,-50%) scale(1) rotate(0);opacity:1;}}
.hud-value.animating{animation:hudPulse 0.3s ease-out;}
@keyframes hudPulse{0%,100%{transform:scale(1);}50%{transform:scale(1.3);color:#FFD700;}}

.skill-tree-container{max-width:900px;margin:20px auto;overflow-y:auto;max-height:70vh;padding:20px;}
.skill-branch{background:rgba(0,0,0,0.4);border:2px solid rgba(255,255,255,0.15);border-radius:12px;padding:20px;margin-bottom:16px;}
.skill-branch.speed{border-color:rgba(0,100,255,0.5);}
.skill-branch.capacity{border-color:rgba(255,215,0,0.5);}
.skill-branch.defense{border-color:rgba(226,26,44,0.5);}
.skill-branch-title{font-size:18px;font-weight:bold;margin-bottom:4px;display:flex;align-items:center;gap:8px;}
.skill-branch-desc{font-size:11px;color:#aaa;margin-bottom:16px;}
.skill-tier{display:flex;align-items:center;gap:12px;margin-bottom:12px;padding:12px;background:rgba(0,0,0,0.3);border-radius:8px;border:2px solid rgba(255,255,255,0.1);position:relative;}
.skill-tier.unlocked{border-color:#FFD700;background:rgba(255,215,0,0.1);}
.skill-tier.locked{opacity:0.6;}
.skill-tier.available{border-color:#00cc66;animation:pulse-border 2s infinite;}
@keyframes pulse-border{0%,100%{border-color:#00cc66;}50%{border-color:#00ff88;}}
.skill-icon{width:40px;height:40px;border-radius:8px;display:flex;align-items:center;justify-content:center;font-size:20px;border:2px solid rgba(255,255,255,0.2);background:rgba(255,255,255,0.05);}
.skill-icon.unlocked{background:linear-gradient(135deg,#FFD700,#FFA500);border-color:#FFD700;box-shadow:0 0 15px rgba(255,215,0,0.5);}
.skill-info{flex:1;}
.skill-name{font-size:14px;font-weight:bold;margin-bottom:2px;}
.skill-desc{font-size:11px;color:#999;}
.skill-cost{background:rgba(226,26,44,0.2);border:1px solid #E21A2C;color:#FFD700;padding:6px 12px;border-radius:6px;font-size:12px;font-weight:bold;min-width:80px;text-align:center;cursor:pointer;transition:all 0.2s;}
.skill-cost:hover{transform:scale(1.05);}
.skill-cost.unlocked{background:rgba(0,200,100,0.2);border-color:#00cc66;color:#00cc66;cursor:default;}
.skill-cost.cant-afford{opacity:0.4;cursor:not-allowed;}
.skill-points-display{position:fixed;top:80px;right:20px;background:linear-gradient(135deg,#E21A2C,#b5151f);padding:12px 20px;border-radius:8px;border:2px solid #FFD700;font-size:16px;font-weight:bold;z-index:100;box-shadow:0 4px 16px rgba(0,0,0,0.5);}
.skill-tree-btn{background:linear-gradient(135deg,#9370DB,#8B5CF6);color:#fff;border:none;padding:8px 16px;font-size:14px;font-family:'Courier New',monospace;font-weight:bold;cursor:pointer;border-radius:6px;margin-left:8px;transition:transform 0.1s;box-shadow:0 2px 8px rgba(147,112,219,0.4);}
.skill-tree-btn:hover{transform:scale(1.05);}
.reset-skills-btn{background:linear-gradient(135deg,#E21A2C,#b5151f);margin-top:16px;width:100%;max-width:300px;}
.sp-earned{color:#FFD700;font-size:18px;margin:8px 0;font-weight:bold;}
/* COMBO SYSTEM STYLES */
#combo-counter{position:absolute;top:60px;left:50%;transform:translateX(-50%);text-align:center;z-index:25;pointer-events:none;transition:all 0.2s;}
/* TUTORIAL SYSTEM STYLES */
#tutorial-overlay{position:absolute;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.85);z-index:60;display:none;align-items:center;justify-content:center;pointer-events:none;}
#tutorial-overlay.active{display:flex;pointer-events:auto;}
.tutorial-box{background:linear-gradient(135deg,#1a1a2e,#2a2a3e);border:3px solid #FFD700;border-radius:16px;padding:24px 32px;max-width:500px;text-align:center;box-shadow:0 10px 40px rgba(0,0,0,0.8);animation:tutorialBounce 0.5s;}
@keyframes tutorialBounce{0%{transform:scale(0.8);opacity:0;}60%{transform:scale(1.05);}100%{transform:scale(1);opacity:1;}}
.tutorial-title{font-size:24px;color:#FFD700;font-weight:bold;margin-bottom:12px;text-shadow:2px 2px 0 #E21A2C;}
.tutorial-text{font-size:16px;color:#fff;line-height:1.6;margin-bottom:20px;}
.tutorial-keys{display:flex;justify-content:center;gap:12px;margin:16px 0;}
.tutorial-key{background:rgba(255,255,255,0.1);border:2px solid rgba(255,255,255,0.3);border-radius:8px;padding:12px 16px;font-size:20px;font-weight:bold;color:#FFD700;min-width:50px;}
.tutorial-arrow{position:absolute;font-size:48px;color:#FFD700;animation:tutorialArrowBounce 1s infinite;pointer-events:none;z-index:59;text-shadow:0 0 10px rgba(255,215,0,0.8),0 0 20px rgba(255,215,0,0.5);}
@keyframes tutorialArrowBounce{0%,100%{transform:translateY(0);}50%{transform:translateY(-10px);}}
.tutorial-highlight{position:absolute;border:4px solid #FFD700;border-radius:50%;box-shadow:0 0 0 4px rgba(255,215,0,0.3),0 0 20px rgba(255,215,0,0.6),inset 0 0 20px rgba(255,215,0,0.2);animation:tutorialPulse 1.5s infinite;pointer-events:none;z-index:59;}
@keyframes tutorialPulse{0%,100%{transform:scale(1);opacity:0.8;}50%{transform:scale(1.1);opacity:1;}}
.tutorial-skip-btn{position:absolute;top:20px;right:20px;background:rgba(255,255,255,0.1);border:2px solid rgba(255,255,255,0.3);color:#fff;padding:10px 20px;font-family:'Courier New',monospace;font-size:14px;cursor:pointer;border-radius:8px;transition:all 0.2s;}
.tutorial-skip-btn:hover{background:rgba(255,255,255,0.2);border-color:#FFD700;}
.tutorial-skip-btn.hidden{display:none;}
.tutorial-progress{display:flex;justify-content:center;gap:8px;margin-top:16px;}
.tutorial-dot{width:10px;height:10px;border-radius:50%;background:rgba(255,255,255,0.3);transition:all 0.3s;}
.tutorial-dot.active{background:#FFD700;transform:scale(1.3);}
.tooltip{position:absolute;background:linear-gradient(135deg,#2a2a3e,#1a1a2e);border:2px solid #FFD700;border-radius:12px;padding:12px 16px;max-width:280px;z-index:70;box-shadow:0 8px 24px rgba(0,0,0,0.6);animation:tooltipFadeIn 0.3s;pointer-events:auto;}
@keyframes tooltipFadeIn{from{opacity:0;transform:translateY(-10px);}to{opacity:1;transform:translateY(0);}}
.tooltip-title{font-size:14px;font-weight:bold;color:#FFD700;margin-bottom:6px;}
.tooltip-text{font-size:12px;color:#ccc;line-height:1.5;}
.tooltip-close{position:absolute;top:8px;right:8px;width:20px;height:20px;background:rgba(255,255,255,0.1);border:1px solid rgba(255,255,255,0.3);border-radius:50%;color:#fff;font-size:12px;display:flex;align-items:center;justify-content:center;cursor:pointer;transition:all 0.2s;}
.tooltip-close:hover{background:rgba(255,0,0,0.5);border-color:#ff0000;}
.practice-watermark{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%) rotate(-30deg);font-size:72px;color:rgba(255,215,0,0.1);font-weight:bold;pointer-events:none;z-index:3;letter-spacing:10px;text-shadow:2px 2px 0 rgba(226,26,44,0.1);}
#help-menu{position:absolute;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.95);z-index:80;display:none;overflow-y:auto;padding:40px 20px;}
#help-menu.active{display:block;}
.help-container{max-width:800px;margin:0 auto;}
.help-header{text-align:center;margin-bottom:32px;}
.help-title{font-size:36px;color:#FFD700;font-weight:bold;margin-bottom:8px;text-shadow:2px 2px 0 #E21A2C;}
.help-close-btn{position:fixed;top:20px;right:20px;background:rgba(255,255,255,0.1);border:2px solid rgba(255,255,255,0.3);color:#fff;padding:12px 24px;font-family:'Courier New',monospace;font-size:16px;cursor:pointer;border-radius:8px;transition:all 0.2s;}
.help-close-btn:hover{background:rgba(255,255,255,0.2);border-color:#FFD700;}
.help-section{background:rgba(255,255,255,0.05);border:2px solid rgba(255,255,255,0.15);border-radius:12px;padding:24px;margin-bottom:20px;}
.help-section-title{font-size:22px;color:#FFD700;font-weight:bold;margin-bottom:16px;border-bottom:2px solid rgba(255,215,0,0.3);padding-bottom:8px;}
.help-content{font-size:14px;line-height:1.8;color:#ccc;}
.help-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(200px,1fr));gap:16px;margin-top:12px;}
.help-item{background:rgba(0,0,0,0.3);border:1px solid rgba(255,255,255,0.2);border-radius:8px;padding:12px;text-align:center;}
.help-item-icon{font-size:32px;margin-bottom:8px;}
.help-item-title{font-size:14px;color:#FFD700;font-weight:bold;margin-bottom:4px;}
.help-item-desc{font-size:11px;color:#999;}
.help-controls-grid{display:grid;grid-template-columns:auto 1fr;gap:12px;align-items:center;}
.help-key{background:rgba(255,255,255,0.1);border:2px solid rgba(255,255,255,0.3);border-radius:6px;padding:8px 12px;font-weight:bold;color:#FFD700;text-align:center;min-width:60px;}
.help-key-desc{color:#ccc;font-size:14px;}
.combo-multiplier{font-size:52px;font-weight:bold;text-shadow:3px 3px 8px rgba(0,0,0,0.8);letter-spacing:2px;transition:all 0.3s;}
.combo-label{font-size:14px;text-transform:uppercase;letter-spacing:3px;opacity:0.8;margin-top:-8px;}
.combo-text{position:absolute;font-size:28px;font-weight:bold;text-shadow:2px 2px 6px rgba(0,0,0,0.9);pointer-events:none;z-index:30;animation:comboPopup 1s forwards;white-space:nowrap;text-align:center;}
@keyframes comboPopup{0%{transform:scale(0.5) translateY(0);opacity:0;}15%{transform:scale(1.3) translateY(-10px);opacity:1;}80%{transform:scale(1) translateY(-30px);opacity:1;}100%{transform:scale(0.8) translateY(-50px);opacity:0;}}
.combo-particle{position:absolute;width:6px;height:6px;border-radius:50%;pointer-events:none;z-index:29;}
#daily-challenge-hud{position:absolute;top:60px;left:50%;transform:translateX(-50%);background:rgba(226,26,44,0.9);padding:8px 16px;border-radius:8px;border:2px solid #FFD700;display:none;max-width:400px;text-align:center;z-index:21;}
.dc-title{color:#FFD700;font-size:13px;font-weight:bold;margin-bottom:4px;text-transform:uppercase;}
.dc-desc{color:#fff;font-size:11px;margin-bottom:4px;}
.dc-progress{color:#00cc66;font-size:12px;font-weight:bold;}
.streak-badge{position:absolute;top:12px;right:16px;background:linear-gradient(135deg,#FFD700,#FFA500);color:#1a1a2e;padding:6px 12px;border-radius:20px;font-size:11px;font-weight:bold;display:none;z-index:22;box-shadow:0 4px 12px rgba(255,215,0,0.5);border:2px solid #FFF;}
.streak-badge .fire{font-size:14px;margin-right:4px;}
.challenge-complete-popup{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);background:linear-gradient(135deg,#FFD700,#FFA500);color:#1a1a2e;padding:24px 32px;border-radius:16px;font-size:20px;font-weight:bold;text-align:center;opacity:0;transition:opacity 0.5s;pointer-events:none;z-index:35;border:4px solid #fff;box-shadow:0 8px 32px rgba(0,0,0,0.8);max-width:400px;}
.challenge-reward{font-size:28px;margin:8px 0;color:#E21A2C;}
.milestone-celebration{position:fixed;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:40;display:none;}
.dc-leaderboard-toggle{background:rgba(226,26,44,0.2);border:2px solid #E21A2C;color:#E21A2C;padding:8px 16px;font-size:12px;font-family:'Courier New',monospace;font-weight:bold;cursor:pointer;border-radius:6px;margin:8px;}
.dc-leaderboard-toggle.active{background:#E21A2C;color:#fff;}
.challenge-info-box{background:rgba(0,0,0,0.6);border:2px solid rgba(255,215,0,0.5);border-radius:12px;padding:16px;margin:16px 0;max-width:500px;}
.challenge-type-badge{display:inline-block;background:#006491;color:#fff;padding:4px 12px;border-radius:12px;font-size:11px;margin-bottom:8px;font-weight:bold;}
</style>
</head>
<body>
<div id="loading-screen">
  <div class="loading-spinner"></div>
  <div class="loading-text">Loading Team Dominos...</div>
</div>
<canvas id="game-canvas"></canvas>
<canvas id="screen-effect"></canvas>
<div id="ui-overlay">
  <div id="hud" style="display:none;">
    <div class="hud-item"><span class="hud-label">Tokens</span><span class="hud-value tokens" id="hud-tokens">0</span></div>
    <div class="hud-item"><span class="hud-label">OKRs</span><span class="hud-value okrs" id="hud-okrs">0/0</span></div>
    <div class="hud-item"><span class="hud-label">Level</span><span class="hud-value level" id="hud-level">1</span></div>
    <div class="hud-item"><span class="hud-label">Time</span><span class="hud-value" id="hud-time">0:00</span></div>
    <div class="hud-item"><span class="hud-label">Deliver</span><span class="hud-value" id="hud-goal" style="color:#00cc66;">0/0</span></div>
  </div>
  <div id="map-info-hud" style="position:absolute;top:50px;left:8px;background:rgba(0,0,0,0.6);padding:6px 10px;border-radius:6px;border:1px solid rgba(255,255,255,0.2);font-size:11px;display:none;z-index:20;">
    <div style="color:#FFD700;font-weight:bold;margin-bottom:2px;" id="map-theme">Theme</div>
    <div style="color:#aaa;" id="map-weather">Weather</div>
    <div style="color:#aaa;" id="map-time">Time</div>
    <div style="color:#888;margin-top:4px;font-size:9px;">Seed: <span id="map-seed">0</span></div>
  </div>
  <div id="minimap-container" style="display:none;">
    <canvas id="minimap-canvas" width="140" height="140"></canvas>
    <div id="minimap-zoom">
      <div class="zoom-btn" onclick="adjustMinimapZoom(-0.2)">-</div>
      <div class="zoom-btn" onclick="adjustMinimapZoom(0.2)">+</div>
    </div>
  </div>
  <div id="powerup-panel"></div>
  <div id="combo-counter" style="display:none;">
    <div class="combo-multiplier" id="combo-multiplier">1.0x</div>
    <div class="combo-label">COMBO</div>
  </div>
  <div id="daily-challenge-hud"></div>
  <div class="streak-badge" id="streak-badge"></div>
  <div class="challenge-complete-popup" id="challenge-complete-popup"></div>
  <div class="milestone-celebration" id="milestone-celebration"></div>
  <div id="quote-popup"></div>
  <div id="damage-overlay"></div>
  <div id="floating-text-container"></div>
  <div id="mobile-controls">
    <div class="dpad-btn" id="btn-up">^</div>
    <div class="dpad-btn" id="btn-down">v</div>
    <div class="dpad-btn" id="btn-left">&lt;</div>
    <div class="dpad-btn" id="btn-right">&gt;</div>
  </div>
  <div id="action-buttons">
    <div class="action-btn" id="btn-dash">‚ö°</div>
    <div class="action-btn" id="btn-powerup">‚òÖ</div>
  </div>
  <div id="settings-btn" onclick="toggleSettings()">‚öô</div>
  <div id="settings-panel">
    <div style="font-weight:bold;margin-bottom:8px;">Quality Settings</div>
    <div class="quality-option" data-quality="auto">Auto (Recommended)</div>
    <div class="quality-option" data-quality="high">High Quality</div>
    <div class="quality-option" data-quality="medium">Medium Quality</div>
    <div class="quality-option" data-quality="low">Low Quality</div>
    <div style="margin-top:12px;font-size:11px;color:#aaa;text-align:center;">
      <span id="fps-counter">FPS: --</span><br>
      <span id="memory-info">Memory: --</span>
    </div>
  </div>
  <div id="screen-overlay" class="screen-bg"></div>
  <div id="achievement-popup"></div>
  <div id="tutorial-overlay"></div>
  <div id="help-menu"></div>
</div>

<script>
// ============================================================
// TEAM DOMINOS - Complete Game
// ============================================================

const canvas = document.getElementById('game-canvas');
const ctx = canvas.getContext('2d');
const screenEffectCanvas = document.getElementById('screen-effect');
const screenEffectCtx = screenEffectCanvas.getContext('2d');
const minimapCanvas = document.getElementById('minimap-canvas');
const minimapCtx = minimapCanvas.getContext('2d');
const overlay = document.getElementById('screen-overlay');
const hud = document.getElementById('hud');
const minimapContainer = document.getElementById('minimap-container');
const powerupPanel = document.getElementById('powerup-panel');
const quotePopup = document.getElementById('quote-popup');

// ============================================================
// MOBILE OPTIMIZATION & QUALITY SYSTEM
// ============================================================

// Device capability detection
const DeviceCapability = {
  tier: 'high',
  memory: 8,
  cores: 4,
  isMobile: false,
  pixelRatio: 1,
  
  detect() {
    this.isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || 
                     ('ontouchstart' in window) || 
                     (window.innerWidth < 768);
    
    this.memory = navigator.deviceMemory || 8;
    this.cores = navigator.hardwareConcurrency || 4;
    this.pixelRatio = Math.min(window.devicePixelRatio || 1, 2);
    
    // Determine device tier
    const gpuInfo = this.getGPUTier();
    const memScore = this.memory >= 6 ? 2 : (this.memory >= 4 ? 1 : 0);
    const coreScore = this.cores >= 6 ? 2 : (this.cores >= 4 ? 1 : 0);
    const totalScore = gpuInfo.score + memScore + coreScore;
    
    if (this.isMobile) {
      if (totalScore >= 5) this.tier = 'high';
      else if (totalScore >= 3) this.tier = 'medium';
      else this.tier = 'low';
    } else {
      this.tier = totalScore >= 4 ? 'high' : (totalScore >= 2 ? 'medium' : 'low');
    }
    
    console.log(`Device: ${this.tier} (Memory: ${this.memory}GB, Cores: ${this.cores}, Mobile: ${this.isMobile})`);
    return this.tier;
  },
  
  getGPUTier() {
    const canvas = document.createElement('canvas');
    const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
    
    if (!gl) return { score: 0, tier: 'low' };
    
    const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
    const renderer = debugInfo ? gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL) : '';
    
    // Rough GPU classification
    if (/Apple GPU|Mali-G|Adreno (6|7)/i.test(renderer)) return { score: 2, tier: 'high' };
    if (/Adreno|Mali|PowerVR/i.test(renderer)) return { score: 1, tier: 'medium' };
    if (/NVIDIA|AMD|Intel Iris/i.test(renderer)) return { score: 2, tier: 'high' };
    
    return { score: 1, tier: 'medium' };
  }
};

// Quality settings
const QualitySettings = {
  current: 'auto',
  targetFPS: 60,
  actualFPS: 60,
  fpsHistory: [],
  
  profiles: {
    low: {
      targetFPS: 30,
      shadowQuality: 0,
      particleMultiplier: 0.3,
      maxParticles: 50,
      drawDistance: 15,
      textureQuality: 0.5,
      enableEffects: false,
      canvasScale: 0.75
    },
    medium: {
      targetFPS: 45,
      shadowQuality: 1,
      particleMultiplier: 0.6,
      maxParticles: 150,
      drawDistance: 20,
      textureQuality: 0.75,
      enableEffects: true,
      canvasScale: 0.85
    },
    high: {
      targetFPS: 60,
      shadowQuality: 2,
      particleMultiplier: 1,
      maxParticles: 300,
      drawDistance: 30,
      textureQuality: 1,
      enableEffects: true,
      canvasScale: 1
    }
  },
  
  setQuality(level) {
    if (level === 'auto') {
      level = DeviceCapability.tier;
    }
    this.current = level;
    const profile = this.profiles[level];
    this.targetFPS = profile.targetFPS;
    
    // Update UI
    document.querySelectorAll('.quality-option').forEach(opt => {
      opt.classList.toggle('active', opt.dataset.quality === this.current);
    });
    
    console.log(`Quality set to: ${level}`, profile);
    return profile;
  },
  
  getProfile() {
    return this.profiles[this.current] || this.profiles.medium;
  },
  
  updateFPS(fps) {
    this.fpsHistory.push(fps);
    if (this.fpsHistory.length > 60) this.fpsHistory.shift();
    this.actualFPS = this.fpsHistory.reduce((a,b) => a+b, 0) / this.fpsHistory.length;
    
    // Auto-downgrade if performance is poor
    if (this.current === 'auto' && this.fpsHistory.length >= 60) {
      if (this.actualFPS < 25 && DeviceCapability.tier !== 'low') {
        DeviceCapability.tier = 'low';
        this.setQuality('low');
      } else if (this.actualFPS < 40 && DeviceCapability.tier === 'high') {
        DeviceCapability.tier = 'medium';
        this.setQuality('medium');
      }
    }
  }
};

// Object pooling system
class ObjectPool {
  constructor(factory, initialSize = 20) {
    this.factory = factory;
    this.available = [];
    this.inUse = [];
    
    for (let i = 0; i < initialSize; i++) {
      this.available.push(factory());
    }
  }
  
  acquire() {
    let obj = this.available.pop();
    if (!obj) obj = this.factory();
    this.inUse.push(obj);
    return obj;
  }
  
  release(obj) {
    const idx = this.inUse.indexOf(obj);
    if (idx !== -1) {
      this.inUse.splice(idx, 1);
      this.available.push(obj);
    }
  }
  
  releaseAll() {
    this.available.push(...this.inUse);
    this.inUse = [];
  }
  
  clear() {
    this.available = [];
    this.inUse = [];
  }
}

// Initialize pools
const ParticlePool = new ObjectPool(() => ({
  x: 0, y: 0, vx: 0, vy: 0, life: 0, maxLife: 0, color: '#fff', size: 2, active: false, confetti: false
}), 100);

const ProjectilePool = new ObjectPool(() => ({
  x: 0, y: 0, vx: 0, vy: 0, active: false
}), 20);

// Memory management
const MemoryManager = {
  lastCleanup: 0,
  cleanupInterval: 5000, // 5 seconds
  
  cleanup() {
    const now = performance.now();
    if (now - this.lastCleanup < this.cleanupInterval) return;
    this.lastCleanup = now;
    
    // Limit particle arrays
    const maxParticles = QualitySettings.getProfile().maxParticles;
    if (particles.length > maxParticles) {
      particles.splice(0, particles.length - maxParticles);
    }
    
    // Clean up inactive objects
    particles = particles.filter(p => p.life > 0);
    okrs = okrs.filter(o => !o.collected || o.persistent);
    powerups = powerups.filter(p => !p.collected);
    
    if (performance.memory) {
      console.log('Memory:', (performance.memory.usedJSHeapSize / 1048576).toFixed(2), 'MB');
    }
  },
  
  getMemoryInfo() {
    if (performance.memory) {
      const used = (performance.memory.usedJSHeapSize / 1048576).toFixed(1);
      const total = (performance.memory.totalJSHeapSize / 1048576).toFixed(1);
      return `${used}/${total}MB`;
    }
    return 'N/A';
  }
};

// Touch gesture support
const GestureHandler = {
  touchStart: { x: 0, y: 0, time: 0 },
  lastTap: 0,
  pinchStart: 0,
  
  init() {
    let touchStartPos = null;
    let touchStartTime = 0;
    
    canvas.addEventListener('touchstart', (e) => {
      if (e.touches.length === 1) {
        touchStartPos = { x: e.touches[0].clientX, y: e.touches[0].clientY };
        touchStartTime = Date.now();
        this.touchStart = { x: touchStartPos.x, y: touchStartPos.y, time: touchStartTime };
      } else if (e.touches.length === 2) {
        // Pinch start
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        this.pinchStart = Math.hypot(dx, dy);
      }
    }, { passive: true });
    
    canvas.addEventListener('touchmove', (e) => {
      if (e.touches.length === 2 && this.pinchStart > 0) {
        // Pinch zoom minimap
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        const dist = Math.hypot(dx, dy);
        const scale = dist / this.pinchStart;
        
        if (scale > 1.2) {
          minimapScale = Math.min(minimapScale + 0.1, 2);
          this.pinchStart = dist;
        } else if (scale < 0.8) {
          minimapScale = Math.max(minimapScale - 0.1, 0.5);
          this.pinchStart = dist;
        }
      }
    }, { passive: true });
    
    canvas.addEventListener('touchend', (e) => {
      if (!touchStartPos) return;
      
      const touchEndPos = { x: e.changedTouches[0].clientX, y: e.changedTouches[0].clientY };
      const touchEndTime = Date.now();
      const duration = touchEndTime - touchStartTime;
      const dx = touchEndPos.x - touchStartPos.x;
      const dy = touchEndPos.y - touchStartPos.y;
      const distance = Math.hypot(dx, dy);
      
      // Double-tap detection
      if (duration < 300 && distance < 30) {
        const timeSinceLastTap = touchEndTime - this.lastTap;
        if (timeSinceLastTap < 300) {
          this.handleDoubleTap();
          this.lastTap = 0;
        } else {
          this.lastTap = touchEndTime;
        }
      }
      
      // Swipe detection
      if (distance > 50 && duration < 300) {
        this.handleSwipe(dx, dy);
      }
      
      touchStartPos = null;
      this.pinchStart = 0;
    }, { passive: true });
  },
  
  handleSwipe(dx, dy) {
    if (!player || gameState !== 'playing') return;
    
    const angle = Math.atan2(dy, dx);
    const speed = player.baseSpeed * 3;
    
    // Dash in swipe direction
    player.x += Math.cos(angle) * speed;
    player.y += Math.sin(angle) * speed;
    
    spawnParticles(player.x, player.y, 10, '#FFFF00', 100, 0.3);
    this.vibrate(30);
  },
  
  handleDoubleTap() {
    if (gameState !== 'playing') return;
    
    // Use power-up or special ability
    if (activePowerups.sprint) {
      // Boost speed temporarily
      player.baseSpeed *= 1.5;
      setTimeout(() => player.baseSpeed /= 1.5, 500);
    }
    this.vibrate(50);
  },
  
  vibrate(duration) {
    if ('vibrate' in navigator) {
      navigator.vibrate(duration);
    }
  }
};

// FPS counter and performance monitor
const PerformanceMonitor = {
  lastTime: 0,
  frames: 0,
  fps: 60,
  
  update() {
    this.frames++;
    const now = performance.now();
    
    if (now >= this.lastTime + 1000) {
      this.fps = Math.round((this.frames * 1000) / (now - this.lastTime));
      this.frames = 0;
      this.lastTime = now;
      
      QualitySettings.updateFPS(this.fps);
      
      // Update UI
      document.getElementById('fps-counter').textContent = `FPS: ${this.fps}`;
      document.getElementById('memory-info').textContent = `Memory: ${MemoryManager.getMemoryInfo()}`;
    }
  }
};

// Settings panel
function toggleSettings() {
  const panel = document.getElementById('settings-panel');
  panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
}

// Quality option handlers
document.addEventListener('DOMContentLoaded', () => {
  document.querySelectorAll('.quality-option').forEach(opt => {
    opt.addEventListener('click', () => {
      const quality = opt.dataset.quality;
      QualitySettings.setQuality(quality);
      localStorage.setItem('teamDominosQuality', quality);
    });
  });
  
  // Load saved quality setting
  const savedQuality = localStorage.getItem('teamDominosQuality') || 'auto';
  QualitySettings.setQuality(savedQuality);
});

// Initialize on load
let minimapScale = 1;
DeviceCapability.detect();
QualitySettings.setQuality('auto');

// ============================================================
// CONSTANTS
// ============================================================
const TILE = 32;
const FPS = 60;
const TOKEN_PER_SEC = 1;
const TOKEN_PER_MOVE = 0.1;
const TOKEN_PER_PICKUP = 5;
const TOKEN_PER_DELIVERY = 2;

const COLORS = {
  red: '#E21A2C',
  blue: '#006491',
  gold: '#FFD700',
  white: '#FFFFFF',
  road: '#3a3a4a',
  sidewalk: '#5a5a6a',
  grass: '#2d5a1e',
  building: '#4a4a5e',
  buildingTop: '#5a5a70',
  hq: '#E21A2C',
  meeting: '#8B4513',
  techDebt: '#4a0e4a',
  scopeCreep: '#1a4a1a'
};

// Jrod quotes on delivery
const JROD_QUOTES = [
  "These OKRs are hot and fresh!",
  "Key Results? More like Key Delicious!",
  "That's what I call delivering value!",
  "OKRs delivered on time? That's a first!",
  "Alignment achieved! Ship it!",
  "Now THAT'S velocity!",
  "You're crushing Q4 targets!",
  "This sprint is *chef's kiss*!",
  "Stakeholders are gonna LOVE this!",
  "Promoted! Just kidding. But great work!",
  "That delivery was O-K-ARRR-some!",
  "30 minutes or less, guaranteed!",
  "Exceeds expectations on the perf review!"
];

// Characters data
const CHARACTERS = [
  { id:'sally', name:'Sprint Sally', desc:'Fast but carries fewer OKRs', speed:5, capacity:2, color:'#FF69B4', hair:'#FFD700' },
  { id:'bob', name:'Backlog Bob', desc:'Slow but carries many OKRs', speed:2, capacity:5, color:'#4169E1', hair:'#8B4513' },
  { id:'alex', name:'Agile Alex', desc:'Perfectly balanced stats', speed:3, capacity:3, color:'#32CD32', hair:'#333' },
  { id:'sam', name:'Scrum Sam', desc:'Good speed, medium capacity', speed:4, capacity:3, color:'#FF8C00', hair:'#D2691E' },
  { id:'dana', name:'Deploy Dana', desc:'Medium speed, good capacity', speed:3, capacity:4, color:'#9370DB', hair:'#1a1a1a' },
  { id:'steve', name:'Standup Steve', desc:'Lightning fast, minimal carry', speed:5, capacity:1, color:'#00CED1', hair:'#FFD700' }
];

// Power-up rarities
const RARITY = {
  common: { name:'Common', color:'#00FF00', glow:'rgba(0,255,0,', spawnWeight:60 },
  rare: { name:'Rare', color:'#0099FF', glow:'rgba(0,153,255,', spawnWeight:30 },
  epic: { name:'Epic', color:'#9933FF', glow:'rgba(153,51,255,', spawnWeight:8 },
  legendary: { name:'Legendary', color:'#FFD700', glow:'rgba(255,215,0,', spawnWeight:2 }
};

// Power-up types
const POWERUP_TYPES = [
  // Existing
  { id:'sprint', name:'Sprint Planning Boost', color:'#00FF00', icon:'S', duration:5, rarity:'common', desc:'2x speed', stacksWith:['magnet','multiplier'], cancelsWith:[] },
  { id:'shield', name:'Agile Shield', color:'#00BFFF', icon:'A', duration:3, rarity:'rare', desc:'Pass through obstacles', stacksWith:['sprint','magnet','multiplier'], cancelsWith:['ghost'] },
  { id:'teleport', name:'Standup Skip', color:'#FF00FF', icon:'T', duration:0, rarity:'epic', desc:'Teleport randomly', stacksWith:[], cancelsWith:[] },
  // New power-ups
  { id:'timefreeze', name:'Time Freeze', color:'#00FFFF', icon:'‚è∏', duration:5, rarity:'epic', desc:'Freeze obstacles', stacksWith:['sprint','shield','ghost'], cancelsWith:[] },
  { id:'magnet', name:'OKR Magnet', color:'#FFAA00', icon:'M', duration:10, rarity:'common', desc:'Auto-collect OKRs', stacksWith:['sprint','shield','multiplier','dash'], cancelsWith:[] },
  { id:'ghost', name:'Ghost Mode', color:'#AA88FF', icon:'G', duration:7, rarity:'rare', desc:'Walk through everything', stacksWith:['sprint','magnet','multiplier','dash'], cancelsWith:['shield'] },
  { id:'multiplier', name:'2x Multiplier', color:'#FF0088', icon:'√ó', duration:15, rarity:'legendary', desc:'2x OKR value', stacksWith:['sprint','shield','magnet','ghost','dash'], cancelsWith:[] },
  { id:'dash', name:'Dash Charge', color:'#FFFF00', icon:'‚ö°', duration:10, rarity:'rare', desc:'Unlimited sprint', stacksWith:['shield','magnet','multiplier','ghost'], cancelsWith:['sprint'] }
];

// ============================================================
// ACHIEVEMENT SYSTEM
// ============================================================
const ACHIEVEMENTS = [
  // Tutorial achievements
  { id:'first_delivery', title:'First Delivery', desc:'Deliver your first OKR', icon:'üçï', difficulty:'tutorial', requirement:{ type:'deliveries', count:1 }},
  { id:'first_powerup', title:'Power Play', desc:'Collect your first power-up', icon:'‚ö°', difficulty:'tutorial', requirement:{ type:'powerup_collected', count:1 }},
  { id:'meet_jrod', title:'Meet the Boss', desc:'Find Jrod\'s HQ', icon:'üè¢', difficulty:'tutorial', requirement:{ type:'hq_visits', count:1 }},
  { id:'first_game', title:'Getting Started', desc:'Complete your first game session', icon:'üéÆ', difficulty:'tutorial', requirement:{ type:'games_played', count:1 }},
  { id:'first_character', title:'Team Member', desc:'Choose your first character', icon:'üë§', difficulty:'tutorial', requirement:{ type:'characters_used', count:1 }},

  // Easy achievements
  { id:'delivery_10', title:'Delivery Expert', desc:'Deliver 10 OKRs in total', icon:'üì¶', difficulty:'easy', requirement:{ type:'total_deliveries', count:10 }},
  { id:'play_5_games', title:'Regular Customer', desc:'Play 5 games', icon:'üéØ', difficulty:'easy', requirement:{ type:'games_played', count:5 }},
  { id:'all_characters', title:'Team Player', desc:'Try all 6 characters', icon:'üë•', difficulty:'easy', requirement:{ type:'all_characters', count:6 }},
  { id:'tokens_1000', title:'Token Collector', desc:'Accumulate 1000 tokens in one game', icon:'ü™ô', difficulty:'easy', requirement:{ type:'tokens_single_game', count:1000 }},
  { id:'level_2_complete', title:'Level Up', desc:'Complete level 2', icon:'üéä', difficulty:'easy', requirement:{ type:'level_completed', count:2 }},
  { id:'sprint_boost_5', title:'Speed Demon', desc:'Use Sprint Boost 5 times', icon:'üèÉ', difficulty:'easy', requirement:{ type:'powerup_sprint', count:5 }},
  { id:'teleport_5', title:'Teleporter', desc:'Use Standup Skip 5 times', icon:'‚ú®', difficulty:'easy', requirement:{ type:'powerup_teleport', count:5 }},
  { id:'shield_5', title:'Shielded', desc:'Use Agile Shield 5 times', icon:'üõ°Ô∏è', difficulty:'easy', requirement:{ type:'powerup_shield', count:5 }},
  { id:'tech_debt_survive', title:'Debt Navigator', desc:'Move through Tech Debt 10 times', icon:'üîß', difficulty:'easy', requirement:{ type:'tech_debt_crosses', count:10 }},
  { id:'enemy_dodge', title:'Smooth Moves', desc:'Avoid 20 enemies', icon:'üí®', difficulty:'easy', requirement:{ type:'enemies_dodged', count:20 }},

  // Medium achievements  
  { id:'delivery_100', title:'Century Club', desc:'Deliver 100 total OKRs', icon:'üíØ', difficulty:'medium', requirement:{ type:'total_deliveries', count:100 }},
  { id:'streak_5', title:'On a Roll', desc:'Complete 5 levels in a row', icon:'üî•', difficulty:'medium', requirement:{ type:'level_streak', count:5 }},
  { id:'tokens_5000', title:'Big Spender', desc:'Accumulate 5000 tokens in one run', icon:'üí∞', difficulty:'medium', requirement:{ type:'tokens_single_game', count:5000 }},
  { id:'fast_level', title:'Speed Runner', desc:'Complete any level in under 60 seconds', icon:'‚è±Ô∏è', difficulty:'medium', requirement:{ type:'level_under_60s', count:1 }},
  { id:'play_20_games', title:'Dedicated Driver', desc:'Play 20 games total', icon:'üöó', difficulty:'medium', requirement:{ type:'games_played', count:20 }},
  { id:'all_powerups_one_game', title:'Power User', desc:'Collect all power-up types in one game', icon:'üåü', difficulty:'medium', requirement:{ type:'all_powerups_game', count:1 }},
  { id:'full_capacity_delivery', title:'Maximum Load', desc:'Deliver at max capacity 10 times', icon:'üìö', difficulty:'medium', requirement:{ type:'full_capacity', count:10 }},
  { id:'no_damage_level', title:'Untouchable', desc:'Complete a level without hitting enemies', icon:'üëª', difficulty:'medium', requirement:{ type:'no_damage_level', count:1 }},
  { id:'explore_map', title:'Explorer', desc:'Visit all corners of a map', icon:'üó∫Ô∏è', difficulty:'medium', requirement:{ type:'explore_corners', count:1 }},
  { id:'okr_speed_pickup', title:'Quick Hands', desc:'Pick up 5 OKRs in 10 seconds', icon:'‚ö°', difficulty:'medium', requirement:{ type:'speed_pickup', count:1 }},

  // Hard achievements
  { id:'delivery_10_in_2min', title:'Lightning Delivery', desc:'Deliver 10 OKRs in under 2 minutes', icon:'‚ö°', difficulty:'hard', requirement:{ type:'delivery_speed_10', count:1 }},
  { id:'complete_all_maps', title:'World Tour', desc:'Complete all 5 levels', icon:'üåç', difficulty:'hard', requirement:{ type:'level_completed', count:5 }},
  { id:'no_damage_complete', title:'Flawless Victory', desc:'Complete an entire game without enemy hits', icon:'üèÜ', difficulty:'hard', requirement:{ type:'no_damage_game', count:1 }},
  { id:'tokens_10000', title:'Token Millionaire', desc:'Accumulate 10000 tokens in one game', icon:'üíé', difficulty:'hard', requirement:{ type:'tokens_single_game', count:10000 }},
  { id:'delivery_500', title:'Delivery Legend', desc:'Deliver 500 total OKRs', icon:'üéñÔ∏è', difficulty:'hard', requirement:{ type:'total_deliveries', count:500 }},
  { id:'fast_game_complete', title:'Speedrun Master', desc:'Complete all 5 levels in under 10 minutes', icon:'üèÅ', difficulty:'hard', requirement:{ type:'game_under_10min', count:1 }},
  { id:'no_powerups_level', title:'Purist', desc:'Complete a level without using any power-ups', icon:'üéØ', difficulty:'hard', requirement:{ type:'no_powerup_level', count:1 }},
  { id:'sally_speed_run', title:'Sally Sprint', desc:'Complete level 3 as Sprint Sally in under 90s', icon:'üëü', difficulty:'hard', requirement:{ type:'sally_level3_90s', count:1 }},
  { id:'bob_full_load', title:'Bob\'s Big Haul', desc:'Deliver 5 OKRs at once as Backlog Bob 3 times', icon:'üéí', difficulty:'hard', requirement:{ type:'bob_5_delivery', count:3 }},
  { id:'play_50_games', title:'Veteran Driver', desc:'Play 50 games total', icon:'üéÆ', difficulty:'hard', requirement:{ type:'games_played', count:50 }},

  // Mastery achievements
  { id:'delivery_1000', title:'OKR Master', desc:'Deliver 1000 total OKRs', icon:'üëë', difficulty:'mastery', requirement:{ type:'total_deliveries', count:1000 }},
  { id:'perfect_streak_10', title:'Perfection', desc:'Complete 10 games in a row without losing', icon:'‚ú®', difficulty:'mastery', requirement:{ type:'perfect_streak', count:10 }},
  { id:'all_powerups_mastered', title:'Power Master', desc:'Use each power-up 50 times', icon:'üå†', difficulty:'mastery', requirement:{ type:'all_powerups_50', count:1 }},
  { id:'all_chars_level5', title:'Universal Talent', desc:'Complete level 5 with all characters', icon:'üé≠', difficulty:'mastery', requirement:{ type:'all_chars_level5', count:6 }},
  { id:'tokens_50000', title:'Token Tycoon', desc:'Accumulate 50000 tokens total', icon:'üíµ', difficulty:'mastery', requirement:{ type:'tokens_total', count:50000 }},
  { id:'play_100_games', title:'Century Gamer', desc:'Play 100 games total', icon:'üèÖ', difficulty:'mastery', requirement:{ type:'games_played', count:100 }},
  { id:'fast_every_level', title:'Consistent Speed', desc:'Complete every level in under 2 minutes', icon:'‚è∞', difficulty:'mastery', requirement:{ type:'all_levels_under_2min', count:5 }},
  { id:'delivery_chain_20', title:'Delivery Chain', desc:'Make 20 consecutive deliveries without getting hit', icon:'üîó', difficulty:'mastery', requirement:{ type:'delivery_chain', count:20 }},
  { id:'map_master', title:'Map Master', desc:'Explore 100% of 10 different maps', icon:'üß≠', difficulty:'mastery', requirement:{ type:'maps_100_explored', count:10 }},
  { id:'time_master', title:'Time Master', desc:'Play for a total of 10 hours', icon:'‚è≥', difficulty:'mastery', requirement:{ type:'total_playtime', count:36000 }},

  // Special achievements
  { id:'night_owl', title:'Night Owl', desc:'Play between midnight and 5 AM', icon:'ü¶â', difficulty:'medium', requirement:{ type:'play_night', count:1 }},
  { id:'early_bird', title:'Early Bird', desc:'Play between 5 AM and 8 AM', icon:'üê¶', difficulty:'medium', requirement:{ type:'play_morning', count:1 }},
  { id:'weekend_warrior', title:'Weekend Warrior', desc:'Play 10 games on weekends', icon:'üéâ', difficulty:'medium', requirement:{ type:'weekend_games', count:10 }},
  { id:'daily_delivery', title:'Daily Grind', desc:'Play on 7 different days', icon:'üìÖ', difficulty:'hard', requirement:{ type:'unique_days', count:7 }},
  { id:'comeback_kid', title:'Comeback Kid', desc:'Win after being at 1 token', icon:'üí™', difficulty:'hard', requirement:{ type:'comeback', count:1 }},
  { id:'perfect_route', title:'Perfect Route', desc:'Complete a level with no backtracking', icon:'‚û°Ô∏è', difficulty:'hard', requirement:{ type:'no_backtrack', count:1 }},
  { id:'social_butterfly', title:'Social Butterfly', desc:'Share your score 5 times', icon:'üì±', difficulty:'easy', requirement:{ type:'shares', count:5 }},
  { id:'high_score', title:'High Roller', desc:'Get on the leaderboard', icon:'üèÜ', difficulty:'medium', requirement:{ type:'leaderboard', count:1 }},
];

// Achievement state
let achievementState = {
  unlocked: {},
  progress: {},
  stats: {
    total_deliveries: 0,
    games_played: 0,
    tokens_total: 0,
    total_playtime: 0,
    characters_used: [],
    powerup_sprint: 0,
    powerup_shield: 0,
    powerup_teleport: 0,
    powerup_magnet: 0,
    powerup_ghost: 0,
    powerup_dash: 0,
    powerup_multiplier: 0,
    powerup_timefreeze: 0,
    tech_debt_crosses: 0,
    enemies_dodged: 0,
    level_streak: 0,
    perfect_streak: 0,
    full_capacity: 0,
    shares: 0,
    unique_days: [],
    weekend_games: 0,
    all_chars_level5: [],
    maps_100_explored: 0,
    delivery_chain: 0,
    current_game: {
      start_time: 0,
      deliveries: 0,
      tokens: 0,
      powerups_collected: {},
      okr_pickup_times: [],
      enemy_hits: 0,
      powerups_used: 0,
      level_times: [],
      explored_corners: { tl: false, tr: false, bl: false, br: false },
      backtracking: false,
      last_position: null,
      level_start_time: 0
    }
  }
};

// Load achievement state from localStorage
function loadAchievements() {
  try {
    const saved = localStorage.getItem('teamDominosAchievements');
    if (saved) {
      const loaded = JSON.parse(saved);
      achievementState.unlocked = loaded.unlocked || {};
      achievementState.progress = loaded.progress || {};
      achievementState.stats = { ...achievementState.stats, ...loaded.stats };
      // Ensure arrays are preserved
      if (loaded.stats) {
        achievementState.stats.characters_used = loaded.stats.characters_used || [];
        achievementState.stats.unique_days = loaded.stats.unique_days || [];
        achievementState.stats.all_chars_level5 = loaded.stats.all_chars_level5 || [];
      }
    }
  } catch (e) {
    console.error('Failed to load achievements:', e);
  }
}

// Save achievement state to localStorage
function saveAchievements() {
  try {
    localStorage.setItem('teamDominosAchievements', JSON.stringify({
      unlocked: achievementState.unlocked,
      progress: achievementState.progress,
      stats: achievementState.stats
    }));
  } catch (e) {
    console.error('Failed to save achievements:', e);
  }
}

// Check if achievement is unlocked
function unlockAchievement(achievementId) {
  if (achievementState.unlocked[achievementId]) return false;
  
  achievementState.unlocked[achievementId] = {
    timestamp: Date.now(),
    unlockedAt: new Date().toISOString()
  };
  
  saveAchievements();
  showAchievementPopup(achievementId);
  playAchievementSound();
  return true;
}

// Show achievement unlock popup
function showAchievementPopup(achievementId) {
  const achievement = ACHIEVEMENTS.find(a => a.id === achievementId);
  if (!achievement) return;
  
  const popup = document.getElementById('achievement-popup');
  popup.innerHTML = `
    <div class="ach-popup-title">Achievement Unlocked!</div>
    <div class="ach-popup-name">${achievement.icon} ${achievement.title}</div>
    <div class="ach-popup-desc">${achievement.desc}</div>
  `;
  popup.className = 'show';
  
  setTimeout(() => {
    popup.className = '';
  }, 4000);
}

// Play achievement unlock sound
function playAchievementSound() {
  try {
    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
    const oscillator = audioContext.createOscillator();
    const gainNode = audioContext.createGain();
    
    oscillator.connect(gainNode);
    gainNode.connect(audioContext.destination);
    
    oscillator.frequency.setValueAtTime(523.25, audioContext.currentTime); // C5
    oscillator.frequency.setValueAtTime(659.25, audioContext.currentTime + 0.1); // E5
    oscillator.frequency.setValueAtTime(783.99, audioContext.currentTime + 0.2); // G5
    
    gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
    
    oscillator.start(audioContext.currentTime);
    oscillator.stop(audioContext.currentTime + 0.5);
  } catch (e) {
    // Silent fail if audio not supported
  }
}

// Check achievements based on current state
function checkAchievements() {
  ACHIEVEMENTS.forEach(achievement => {
    if (achievementState.unlocked[achievement.id]) return;
    
    const req = achievement.requirement;
    let progress = 0;
    let target = req.count;
    let unlocked = false;
    
    switch (req.type) {
      case 'deliveries':
      case 'total_deliveries':
        progress = achievementState.stats.total_deliveries;
        unlocked = progress >= target;
        break;
      case 'powerup_collected':
        progress = (achievementState.stats.powerup_sprint || 0) + 
                   (achievementState.stats.powerup_shield || 0) + 
                   (achievementState.stats.powerup_teleport || 0);
        unlocked = progress >= target;
        break;
      case 'hq_visits':
        progress = achievementState.stats.total_deliveries > 0 ? 1 : 0;
        unlocked = progress >= target;
        break;
      case 'games_played':
        progress = achievementState.stats.games_played;
        unlocked = progress >= target;
        break;
      case 'characters_used':
        progress = achievementState.stats.characters_used.length;
        unlocked = progress >= target;
        break;
      case 'all_characters':
        progress = achievementState.stats.characters_used.length;
        unlocked = progress >= 6;
        break;
      case 'tokens_single_game':
        progress = achievementState.stats.current_game.tokens;
        unlocked = progress >= target;
        break;
      case 'tokens_total':
        progress = achievementState.stats.tokens_total;
        unlocked = progress >= target;
        break;
      case 'level_completed':
        progress = achievementState.stats.level_streak || 0;
        unlocked = progress >= target;
        break;
      case 'level_streak':
        progress = achievementState.stats.level_streak || 0;
        unlocked = progress >= target;
        break;
      case 'powerup_sprint':
        progress = achievementState.stats.powerup_sprint || 0;
        unlocked = progress >= target;
        break;
      case 'powerup_teleport':
        progress = achievementState.stats.powerup_teleport || 0;
        unlocked = progress >= target;
        break;
      case 'powerup_shield':
        progress = achievementState.stats.powerup_shield || 0;
        unlocked = progress >= target;
        break;
      case 'tech_debt_crosses':
        progress = achievementState.stats.tech_debt_crosses || 0;
        unlocked = progress >= target;
        break;
      case 'enemies_dodged':
        progress = achievementState.stats.enemies_dodged || 0;
        unlocked = progress >= target;
        break;
      case 'full_capacity':
        progress = achievementState.stats.full_capacity || 0;
        unlocked = progress >= target;
        break;
      case 'shares':
        progress = achievementState.stats.shares || 0;
        unlocked = progress >= target;
        break;
      case 'weekend_games':
        progress = achievementState.stats.weekend_games || 0;
        unlocked = progress >= target;
        break;
      case 'unique_days':
        progress = achievementState.stats.unique_days.length || 0;
        unlocked = progress >= target;
        break;
      case 'total_playtime':
        progress = achievementState.stats.total_playtime || 0;
        unlocked = progress >= target;
        break;
      case 'all_chars_level5':
        progress = achievementState.stats.all_chars_level5.length || 0;
        unlocked = progress >= target;
        break;
      case 'maps_100_explored':
        progress = achievementState.stats.maps_100_explored || 0;
        unlocked = progress >= target;
        break;
      case 'delivery_chain':
        progress = achievementState.stats.delivery_chain || 0;
        unlocked = progress >= target;
        break;
      case 'all_powerups_game':
        const powerupsInGame = achievementState.stats.current_game.powerups_collected;
        progress = Object.keys(powerupsInGame).length;
        unlocked = progress >= 3;
        break;
      case 'level_under_60s':
        const times = achievementState.stats.current_game.level_times || [];
        unlocked = times.some(t => t < 60);
        progress = times.filter(t => t < 60).length;
        break;
      case 'no_damage_level':
        unlocked = achievementState.stats.current_game.enemy_hits === 0 && 
                   achievementState.stats.current_game.deliveries >= 3;
        progress = achievementState.stats.current_game.enemy_hits === 0 ? 1 : 0;
        break;
      case 'no_damage_game':
        unlocked = achievementState.stats.current_game.enemy_hits === 0 && 
                   achievementState.stats.current_game.deliveries >= 10;
        progress = achievementState.stats.current_game.enemy_hits === 0 ? 1 : 0;
        break;
      case 'explore_corners':
        const corners = achievementState.stats.current_game.explored_corners;
        unlocked = corners.tl && corners.tr && corners.bl && corners.br;
        progress = [corners.tl, corners.tr, corners.bl, corners.br].filter(Boolean).length;
        target = 4;
        break;
      case 'play_night':
        const hour = new Date().getHours();
        unlocked = hour >= 0 && hour < 5;
        progress = unlocked ? 1 : 0;
        break;
      case 'play_morning':
        const morningHour = new Date().getHours();
        unlocked = morningHour >= 5 && morningHour < 8;
        progress = unlocked ? 1 : 0;
        break;
      case 'leaderboard':
        const scores = getScores();
        unlocked = scores.some(s => s.name === playerName);
        progress = unlocked ? 1 : 0;
        break;
    }
    
    // Store progress
    if (progress > 0 || target > 1) {
      achievementState.progress[achievement.id] = { current: progress, target: target };
    }
    
    // Unlock if criteria met
    if (unlocked) {
      unlockAchievement(achievement.id);
    }
  });
  
  saveAchievements();
}

// Track game events
function trackEvent(eventType, data = {}) {
  const stats = achievementState.stats;
  const currentGame = stats.current_game;
  
  switch (eventType) {
    case 'game_start':
      currentGame.start_time = Date.now();
      currentGame.deliveries = 0;
      currentGame.tokens = 0;
      currentGame.powerups_collected = {};
      currentGame.okr_pickup_times = [];
      currentGame.enemy_hits = 0;
      currentGame.powerups_used = 0;
      currentGame.level_times = [];
      currentGame.explored_corners = { tl: false, tr: false, bl: false, br: false };
      currentGame.backtracking = false;
      currentGame.last_position = null;
      currentGame.level_start_time = Date.now();
      stats.games_played++;
      
      // Track unique days
      const today = new Date().toDateString();
      if (!stats.unique_days.includes(today)) {
        stats.unique_days.push(today);
      }
      
      // Track weekend games
      const day = new Date().getDay();
      if (day === 0 || day === 6) {
        stats.weekend_games++;
      }
      
      // Track character usage
      if (selectedChar && !stats.characters_used.includes(selectedChar.id)) {
        stats.characters_used.push(selectedChar.id);
      }
      break;
      
    case 'okr_delivered':
      stats.total_deliveries += data.count || 1;
      currentGame.deliveries += data.count || 1;
      stats.delivery_chain = (stats.delivery_chain || 0) + 1;
      
      // Check if full capacity
      if (data.count === selectedChar.capacity) {
        stats.full_capacity++;
      }
      break;
      
    case 'powerup_collected':
      currentGame.powerups_collected[data.type] = true;
      if (data.type === 'sprint') stats.powerup_sprint++;
      if (data.type === 'shield') stats.powerup_shield++;
      if (data.type === 'teleport') stats.powerup_teleport++;
      if (data.type === 'magnet') stats.powerup_magnet++;
      if (data.type === 'ghost') stats.powerup_ghost++;
      if (data.type === 'dash') stats.powerup_dash++;
      if (data.type === 'multiplier') stats.powerup_multiplier++;
      if (data.type === 'timefreeze') stats.powerup_timefreeze++;
      break;
      
    case 'enemy_hit':
      currentGame.enemy_hits++;
      stats.delivery_chain = 0;
      break;
      
    case 'enemy_avoided':
      stats.enemies_dodged++;
      break;
      
    case 'level_complete':
      const levelTime = (Date.now() - currentGame.level_start_time) / 1000;
      currentGame.level_times.push(levelTime);
      stats.level_streak = (stats.level_streak || 0) + 1;
      currentGame.level_start_time = Date.now();
      
      // Track level 5 completion by character
      if (data.level === 5 && selectedChar) {
        if (!stats.all_chars_level5.includes(selectedChar.id)) {
          stats.all_chars_level5.push(selectedChar.id);
        }
      }
      break;
      
    case 'game_complete':
      currentGame.tokens = data.tokens || 0;
      stats.tokens_total += data.tokens || 0;
      const gameTime = (Date.now() - currentGame.start_time) / 1000;
      stats.total_playtime += gameTime;
      
      // Check if explored all corners
      const corners = currentGame.explored_corners;
      if (corners.tl && corners.tr && corners.bl && corners.br) {
        stats.maps_100_explored++;
      }
      break;
      
    case 'share':
      stats.shares++;
      break;
      
    case 'tech_debt_cross':
      stats.tech_debt_crosses++;
      break;
      
    case 'okr_pickup':
      currentGame.okr_pickup_times.push(Date.now());
      
      // Check speed pickup (5 in 10 seconds)
      const recentPickups = currentGame.okr_pickup_times.filter(t => Date.now() - t < 10000);
      if (recentPickups.length >= 5) {
        unlockAchievement('okr_speed_pickup');
      }
      break;
      
    case 'position_update':
      if (mapData) {
        // Track corners visited
        if (data.x < mapData.w * TILE * 0.1 && data.y < mapData.h * TILE * 0.1) {
          currentGame.explored_corners.tl = true;
        }
        if (data.x > mapData.w * TILE * 0.9 && data.y < mapData.h * TILE * 0.1) {
          currentGame.explored_corners.tr = true;
        }
        if (data.x < mapData.w * TILE * 0.1 && data.y > mapData.h * TILE * 0.9) {
          currentGame.explored_corners.bl = true;
        }
        if (data.x > mapData.w * TILE * 0.9 && data.y > mapData.h * TILE * 0.9) {
          currentGame.explored_corners.br = true;
        }
      }
      break;
  }
  
  checkAchievements();
  saveAchievements();
}

// ============================================================
// ACHIEVEMENT UI
// ============================================================
function showAchievements() {
  gameState = 'achievements';
  
  const totalAchievements = ACHIEVEMENTS.length;
  const unlockedCount = Object.keys(achievementState.unlocked).length;
  const percentage = Math.floor((unlockedCount / totalAchievements) * 100);
  
  // Group by difficulty
  const grouped = {
    tutorial: ACHIEVEMENTS.filter(a => a.difficulty === 'tutorial'),
    easy: ACHIEVEMENTS.filter(a => a.difficulty === 'easy'),
    medium: ACHIEVEMENTS.filter(a => a.difficulty === 'medium'),
    hard: ACHIEVEMENTS.filter(a => a.difficulty === 'hard'),
    mastery: ACHIEVEMENTS.filter(a => a.difficulty === 'mastery')
  };
  
  let html = `
    <button class="back-btn" onclick="showTitle()">< Back</button>
    <div style="text-align:center;padding:20px;max-width:1000px;">
      <div style="font-size:28px;font-weight:bold;margin-bottom:8px;color:#FFD700;">üèÜ Achievements</div>
      <div style="color:#aaa;margin-bottom:20px;">
        ${unlockedCount} / ${totalAchievements} Unlocked (${percentage}%)
      </div>
      
      <div style="margin-bottom:20px;">
        <div style="height:20px;background:rgba(255,255,255,0.1);border-radius:10px;overflow:hidden;max-width:400px;margin:0 auto;">
          <div style="height:100%;background:linear-gradient(90deg,#E21A2C,#FFD700);width:${percentage}%;transition:width 0.5s;"></div>
        </div>
      </div>
  `;
  
  // Render each difficulty group
  Object.entries(grouped).forEach(([difficulty, achievements]) => {
    const diffColor = {
      tutorial: '#fff',
      easy: '#00cc66',
      medium: '#FFA500',
      hard: '#E21A2C',
      mastery: '#9370DB'
    }[difficulty];
    
    const groupUnlocked = achievements.filter(a => achievementState.unlocked[a.id]).length;
    
    html += `
      <div style="margin-top:24px;">
        <div style="font-size:18px;font-weight:bold;color:${diffColor};text-transform:uppercase;margin-bottom:12px;text-align:left;">
          ${difficulty} (${groupUnlocked}/${achievements.length})
        </div>
        <div class="achievement-grid">
    `;
    
    achievements.forEach(achievement => {
      const unlocked = achievementState.unlocked[achievement.id];
      const progress = achievementState.progress[achievement.id] || { current: 0, target: achievement.requirement.count };
      const progressPercent = Math.min(100, (progress.current / progress.target) * 100);
      
      html += `
        <div class="achievement-card difficulty-${difficulty} ${unlocked ? 'unlocked' : ''}">
          ${unlocked ? '<div class="ach-badge">‚úì</div>' : ''}
          <div class="ach-header">
            <div class="ach-icon ${unlocked ? 'unlocked' : ''}">${achievement.icon}</div>
            <div class="ach-info">
              <div class="ach-title">${achievement.title}</div>
              <div class="ach-desc">${achievement.desc}</div>
            </div>
          </div>
          ${!unlocked && progress.target > 1 ? `
            <div class="ach-progress-bar">
              <div class="ach-progress-fill" style="width:${progressPercent}%"></div>
            </div>
            <div style="font-size:10px;color:#666;margin-top:4px;text-align:right;">
              ${progress.current} / ${progress.target}
            </div>
          ` : ''}
          ${unlocked ? `
            <div style="font-size:10px;color:#FFD700;margin-top:4px;">
              Unlocked ${new Date(achievementState.unlocked[achievement.id].timestamp).toLocaleDateString()}
            </div>
          ` : ''}
        </div>
      `;
    });
    
    html += `</div></div>`;
  });
  
  html += `</div>`;
  
  overlay.style.display = 'flex';
  overlay.className = 'screen-bg';
  overlay.innerHTML = html;
  hud.style.display = 'none';
  minimapContainer.style.display = 'none';
  gameRunning = false;
}

function showStats() {
  gameState = 'stats';
  const stats = achievementState.stats;
  
  overlay.style.display = 'flex';
  overlay.className = 'screen-bg';
  overlay.innerHTML = `
    <button class="back-btn" onclick="showTitle()">< Back</button>
    <div style="text-align:center;padding:20px;">
      <div style="font-size:28px;font-weight:bold;margin-bottom:20px;color:#FFD700;">üìä Statistics</div>
      
      <div class="stats-grid">
        <div class="stat-box">
          <div class="stat-value">${stats.total_deliveries}</div>
          <div class="stat-label">Total Deliveries</div>
        </div>
        <div class="stat-box">
          <div class="stat-value">${stats.games_played}</div>
          <div class="stat-label">Games Played</div>
        </div>
        <div class="stat-box">
          <div class="stat-value">${Math.floor(stats.tokens_total).toLocaleString()}</div>
          <div class="stat-label">Total Tokens</div>
        </div>
        <div class="stat-box">
          <div class="stat-value">${Math.floor(stats.total_playtime / 60)}m</div>
          <div class="stat-label">Total Playtime</div>
        </div>
        <div class="stat-box">
          <div class="stat-value">${stats.powerup_sprint || 0}</div>
          <div class="stat-label">Sprint Boosts</div>
        </div>
        <div class="stat-box">
          <div class="stat-value">${stats.powerup_shield || 0}</div>
          <div class="stat-label">Shields Used</div>
        </div>
        <div class="stat-box">
          <div class="stat-value">${stats.powerup_teleport || 0}</div>
          <div class="stat-label">Teleports</div>
        </div>
        <div class="stat-box">
          <div class="stat-value">${stats.characters_used.length}/6</div>
          <div class="stat-label">Characters Used</div>
        </div>
        <div class="stat-box">
          <div class="stat-value">${stats.tech_debt_crosses || 0}</div>
          <div class="stat-label">Tech Debt Crossed</div>
        </div>
        <div class="stat-box">
          <div class="stat-value">${stats.enemies_dodged || 0}</div>
          <div class="stat-label">Enemies Dodged</div>
        </div>
        <div class="stat-box">
          <div class="stat-value">${stats.unique_days.length}</div>
          <div class="stat-label">Days Played</div>
        </div>
        <div class="stat-box">
          <div class="stat-value">${Object.keys(achievementState.unlocked).length}</div>
          <div class="stat-label">Achievements</div>
        </div>
      </div>
      
      <button class="menu-btn" style="margin-top:20px;" onclick="showAchievements()">VIEW ACHIEVEMENTS</button>
    </div>
  `;
  hud.style.display = 'none';
  minimapContainer.style.display = 'none';
  gameRunning = false;
}

// ============================================================
// GAME STATE
// ============================================================
let gameState = 'title'; // title, modeSelect, charSelect, playing, levelComplete, gameOver, leaderboard, skillTree
let gameMode = 1; // 1, 2, 3, or 4 players
let selectedChar = null;
let playerName = '';
let player = null;
let players = []; // Array for multiplayer
let cameras = []; // Camera for each player
let camera = { x:0, y:0 };
let tokens = 0;
let carriedOKRs = 0;
let deliveredOKRs = 0;
let totalDelivered = 0;
let requiredDeliveries = 0;
let currentLevel = 1;
let elapsedTime = 0;
let lastTime = 0;

// ============================================================
// SKILL TREE SYSTEM
// ============================================================
const SKILL_BRANCHES = {
  speed: {
    name: 'Speed Branch',
    icon: '‚ö°',
    color: '#0064ff',
    desc: 'Boost movement and agility',
    tiers: [
      { id: 'speed1', name: 'Swift Step', desc: '+10% base speed', cost: 100, icon: 'üëü', effect: { speedMult: 1.1 } },
      { id: 'speed2', name: 'Quick Dash', desc: 'Dash cooldown -20%', cost: 250, icon: 'üí®', effect: { dashCooldown: 0.8 } },
      { id: 'speed3', name: 'Sprint Master', desc: '+25% sprint speed', cost: 500, icon: 'üèÉ', effect: { sprintMult: 1.25 } },
      { id: 'speed4', name: 'Speed Aura', desc: 'Permanent speed boost aura', cost: 1000, icon: '‚ú®', effect: { speedAura: true, speedMult: 1.5 } }
    ]
  },
  capacity: {
    name: 'Capacity Branch',
    icon: 'üì¶',
    color: '#FFD700',
    desc: 'Increase OKR carrying capacity',
    tiers: [
      { id: 'cap1', name: 'Extra Pockets', desc: '+1 OKR carry capacity', cost: 100, icon: 'üéí', effect: { capacityBonus: 1 } },
      { id: 'cap2', name: 'Magnetic Pull', desc: 'Pickup radius +50%', cost: 250, icon: 'üß≤', effect: { pickupRadius: 1.5 } },
      { id: 'cap3', name: 'Deep Pockets', desc: '+2 OKR carry capacity', cost: 500, icon: 'üëú', effect: { capacityBonus: 2 } },
      { id: 'cap4', name: 'Auto Collect', desc: 'Auto-collect nearby OKRs', cost: 1000, icon: 'üåü', effect: { autoCollect: true, pickupRadius: 2.0 } }
    ]
  },
  defense: {
    name: 'Defense Branch',
    icon: 'üõ°Ô∏è',
    color: '#E21A2C',
    desc: 'Enhance survivability',
    tiers: [
      { id: 'def1', name: 'Extra Life', desc: '+1 extra hit point', cost: 100, icon: '‚ù§Ô∏è', effect: { maxHits: 1 } },
      { id: 'def2', name: 'Shield Regen', desc: 'Shield regeneration (5s cooldown)', cost: 250, icon: 'üîÑ', effect: { shieldRegen: true } },
      { id: 'def3', name: 'Invulnerability', desc: '0.5s invulnerability after hit', cost: 500, icon: 'üí´', effect: { invulnTime: 0.5 } },
      { id: 'def4', name: 'Starting Shield', desc: 'Damage immunity first 10 seconds', cost: 1000, icon: 'üåà', effect: { startingShield: 10 } }
    ]
  }
};

let skillPoints = 0; // Persistent skill points
let unlockedSkills = {}; // Track unlocked skills per character
let skillPointsEarnedThisRun = 0;

let mapData = null;
let currentMapSeed = null;
let currentWeather = null;
let currentTimeOfDay = null;
let currentTheme = null;
let okrs = [];
let powerups = [];
let enemies = [];
let particles = [];
let activePowerups = {};
let powerupTimers = {}; // Detailed timers for UI
let powerupParticles = []; // Particle trails for player
let playerGlow = null; // Player glow effect
let shakeTimer = 0;
let shakeIntensity = 0;
let scopeCreepCooldown = 0;
let quoteTimer = 0;
let keys = {};
let mobileDir = { x:0, y:0 };
let canvasWidth, canvasHeight;
let gameRunning = false;

// ============================================================
// COMBO SYSTEM
// ============================================================
let comboMultiplier = 1.0;
let comboTimer = 0;
const COMBO_GRACE_PERIOD = 5.0;
const COMBO_INCREMENT = 0.5;
const MAX_COMBO_MULTIPLIER = 10.0;
let comboStats = {
  nearMisses: 0,
  speedDeliveries: 0,
  perfectPickups: 0,
  chainDeliveries: 0,
  riskyMoves: 0,
  maxCombo: 1.0,
  totalComboPoints: 0
};
let lastPickupTime = 0;
let pickupChain = 0;
let deliveryStartTime = 0;
let damageTakenThisDelivery = false;
let floatingTexts = [];

// Audio context for combo sounds
let audioCtx = null;
let comboSoundEnabled = true;

// Enhanced Visual Feedback State
let minimapZoom = 1.0;
let playerTrail = [];
const MAX_TRAIL_LENGTH = 20;
let invulnerabilityTimer = 0;
let invulnFlickerPhase = 0;
let cameraZoom = 1.0;
let cameraZoomTarget = 1.0;
let rainbowTrail = [];
const MAX_RAINBOW_TRAIL = 30;
let damageOverlay = null;
let floatingTextContainer = null;
let knockbackVelocity = { x: 0, y: 0 };
let celebrationAnimPhase = 0;
let tokenDisplayValue = 0; // For smooth counting animation
const SOUND_EFFECTS = {
  damage: { freq: 100, duration: 0.15, type: 'sawtooth' },
  pickup: { freq: 600, duration: 0.1, type: 'sine' },
  powerup: { freq: 800, duration: 0.2, type: 'square' },
  delivery: { freq: 1000, duration: 0.3, type: 'triangle' }
};


// Combo trigger definitions
const COMBO_TRIGGERS = {
  nearMiss: { points: 25, text: 'NEAR MISS!', color: '#FFD700' },
  speedDelivery: { points: 50, text: 'SPEED DELIVERY!', color: '#00FF00' },
  perfectPickup: { points: 35, text: 'PERFECT PICKUP!', color: '#FF69B4' },
  chainDelivery: { points: 100, text: 'CHAIN DELIVERY!', color: '#FF0000' },
  riskyMove: { points: 75, text: 'RISKY MOVE!', color: '#FF8C00' }
};

// Multiplayer player colors
let quoteTimer = 0;
let keys = {};

// ============================================================
// DAILY CHALLENGE SYSTEM
// ============================================================
let dailyChallengeActive = false;
let currentChallenge = null;
let challengeProgress = {
  current: 0,
  required: 0,
  completed: false
};
let dailyChallengeStreak = 0;
let dailyChallengeData = null;

// Challenge type definitions
const CHALLENGE_TYPES = {
  speedRun: {
    name: 'Speed Run',
    desc: 'Deliver {target} OKRs in {time} seconds',
    icon: '‚ö°',
    color: '#00FF00',
    generate: (seed) => ({
      target: 5 + Math.floor(seed % 5),
      time: 30 + Math.floor((seed * 13) % 30)
    }),
    check: (progress, challenge) => progress.deliveries >= challenge.target && progress.time <= challenge.time
  },
  perfectRun: {
    name: 'Perfect Run',
    desc: 'Complete level without taking damage',
    icon: 'üõ°Ô∏è',
    color: '#00BFFF',
    generate: () => ({ level: 1 }),
    check: (progress) => progress.damageTaken === 0 && progress.levelComplete
  },
  collector: {
    name: 'Collector',
    desc: 'Collect {target} power-ups in one run',
    icon: 'üíé',
    color: '#FF00FF',
    generate: (seed) => ({ target: 3 + Math.floor(seed % 5) }),
    check: (progress, challenge) => progress.powerupsCollected >= challenge.target
  },
  efficiency: {
    name: 'Efficiency',
    desc: 'Deliver {target} OKRs with less than {maxTokens} tokens',
    icon: 'üí∞',
    color: '#FFD700',
    generate: (seed) => ({
      target: 5 + Math.floor(seed % 5),
      maxTokens: 100 + Math.floor((seed * 17) % 100)
    }),
    check: (progress, challenge) => progress.deliveries >= challenge.target && progress.tokensUsed < challenge.maxTokens
  },
  survivor: {
    name: 'Survivor',
    desc: 'Survive {time} seconds without dying',
    icon: '‚è±Ô∏è',
    color: '#FFA500',
    generate: (seed) => ({ time: 60 + Math.floor((seed * 11) % 60) }),
    check: (progress, challenge) => progress.time >= challenge.time && !progress.died
  },
  marathon: {
    name: 'Marathon',
    desc: 'Complete {target} deliveries in one game',
    icon: 'üèÉ',
    color: '#E21A2C',
    generate: (seed) => ({ target: 10 + Math.floor(seed % 10) }),
    check: (progress, challenge) => progress.deliveries >= challenge.target
  }
};

// Streak rewards - escalating bonuses
const STREAK_REWARDS = {
  1: 100,
  3: 200,
  7: 500,
  14: 750,
  30: 1500,
  50: 2500,
  100: 5000
};

// Milestone streak celebrations
const MILESTONE_STREAKS = [7, 30, 100];

let mobileDir = { x:0, y:0 };
let canvasWidth, canvasHeight;
let gameRunning = false;

// Multiplayer player colors
const PLAYER_COLORS = ['#E21A2C', '#006491', '#00FF00', '#FFD700']; // Red, Blue, Green, Yellow
const PLAYER_NAMES = ['P1', 'P2', 'P3', 'P4'];
const PLAYER_KEY_BINDINGS = [
  { up: 'w', down: 's', left: 'a', right: 'd' },           // Player 1: WASD
  { up: 'arrowup', down: 'arrowdown', left: 'arrowleft', right: 'arrowright' }, // Player 2: Arrows
  { up: 't', down: 'g', left: 'f', right: 'h' },           // Player 3: TFGH
  { up: 'i', down: 'k', left: 'j', right: 'l' }            // Player 4: IJKL
];

// ============================================================
// VISUAL FEEDBACK FUNCTIONS
// ============================================================
function playSound(soundType) {
  if (!audioCtx) {
    try { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); } catch(e) { return; }
  }
  const sound = SOUND_EFFECTS[soundType];
  if (!sound) return;
  
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  osc.connect(gain);
  gain.connect(audioCtx.destination);
  osc.type = sound.type;
  osc.frequency.value = sound.freq;
  gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
  gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + sound.duration);
  osc.start(audioCtx.currentTime);
  osc.stop(audioCtx.currentTime + sound.duration);
}

function triggerDamageEffect(magnitude = 5) {
  if (!damageOverlay) damageOverlay = document.getElementById('damage-overlay');
  shakeTimer = 0.3;
  shakeIntensity = magnitude;
  damageOverlay.classList.add('active');
  setTimeout(() => damageOverlay.classList.remove('active'), 100);
  playSound('damage');
  
  // Knockback
  const angle = Math.random() * Math.PI * 2;
  knockbackVelocity.x = Math.cos(angle) * 100;
  knockbackVelocity.y = Math.sin(angle) * 100;
  
  // Invulnerability frames
  invulnerabilityTimer = 1.0;
  invulnFlickerPhase = 0;
}

function createFloatingText(text, x, y, color = '#FFD700', size = 20) {
  if (!floatingTextContainer) floatingTextContainer = document.getElementById('floating-text-container');
  const div = document.createElement('div');
  div.className = 'floating-text';
  div.textContent = text;
  div.style.left = x + 'px';
  div.style.top = y + 'px';
  div.style.color = color;
  div.style.fontSize = size + 'px';
  floatingTextContainer.appendChild(div);
  setTimeout(() => div.remove(), 1500);
}

function animateTokenCount(newValue) {
  const step = () => {
    const diff = newValue - tokenDisplayValue;
    if (Math.abs(diff) < 0.5) {
      tokenDisplayValue = newValue;
      return;
    }
    tokenDisplayValue += diff * 0.15;
    requestAnimationFrame(step);
  };
  step();
}

function triggerDeliveryCelebration(hqX, hqY) {
  // Confetti burst
  spawnConfetti(hqX, hqY);
  for (let i = 0; i < 5; i++) {
    setTimeout(() => spawnConfetti(hqX + (Math.random()-0.5)*60, hqY + (Math.random()-0.5)*60), i * 100);
  }
  
  // Camera zoom effect
  cameraZoomTarget = 1.2;
  setTimeout(() => cameraZoomTarget = 1.0, 800);
  
  // Rainbow trail activation
  rainbowTrail = [];
  
  // Victory animation
  celebrationAnimPhase = 1.0;
  
  // Dramatic quote popup
  const quote = JROD_QUOTES[Math.floor(Math.random()*JROD_QUOTES.length)];
  showQuote(quote, true);
  
  playSound('delivery');
}

function showQuote(text, dramatic = false) {
  quotePopup.textContent = text;
  quotePopup.style.opacity = '1';
  if (dramatic) {
    quotePopup.classList.add('show-dramatic');
    setTimeout(() => quotePopup.classList.remove('show-dramatic'), 500);
  }
  quoteTimer = 2.5;
}

function adjustMinimapZoom(delta) {
  minimapZoom = Math.max(0.5, Math.min(2.0, minimapZoom + delta));
}

function updatePlayerTrail() {
  if (!player) return;
  playerTrail.push({ x: player.x, y: player.y, time: performance.now() });
  if (playerTrail.length > MAX_TRAIL_LENGTH) playerTrail.shift();
  
  // Update rainbow trail if delivery just happened
  if (celebrationAnimPhase > 0) {
    rainbowTrail.push({ 
      x: player.x, 
      y: player.y, 
      hue: (performance.now() / 20) % 360,
      life: 1.0
    });
    if (rainbowTrail.length > MAX_RAINBOW_TRAIL) rainbowTrail.shift();
  }
}

function animateHudValue(elementId) {
  const el = document.getElementById(elementId);
  if (!el) return;
  el.classList.add('animating');
  setTimeout(() => el.classList.remove('animating'), 300);
}

// ============================================================
// RESIZE
// ============================================================
// ============================================================
// RESIZE WITH DEBOUNCING
// ============================================================
let resizeTimeout;
function resize() {
  const profile = QualitySettings.getProfile();
  const scale = profile.canvasScale;
  
  canvasWidth = window.innerWidth;
  canvasHeight = window.innerHeight;
  canvas.width = canvasWidth * scale;
  canvas.height = canvasHeight * scale;
  canvas.style.width = canvasWidth + 'px';
  canvas.style.height = canvasHeight + 'px';
  
  // Scale context for retina displays
  if (scale !== 1) {
    ctx.scale(scale, scale);
  }
  
  if (typeof screenEffectCanvas !== 'undefined') {
    screenEffectCanvas.width = canvasWidth;
    screenEffectCanvas.height = canvasHeight;
  }
}

function debouncedResize() {
  clearTimeout(resizeTimeout);
  resizeTimeout = setTimeout(resize, 150);
}

window.addEventListener('resize', debouncedResize);
resize();

// ============================================================
// INPUT
// ============================================================
window.addEventListener('keydown', e => {
  const tag = document.activeElement.tagName;
  if (tag !== 'INPUT' && tag !== 'TEXTAREA') {
    keys[e.key.toLowerCase()] = true;
    e.preventDefault();
  }
});
window.addEventListener('keyup', e => {
  const tag = document.activeElement.tagName;
  if (tag !== 'INPUT' && tag !== 'TEXTAREA') {
    keys[e.key.toLowerCase()] = false;
  }
});

// Mobile controls
['btn-up','btn-down','btn-left','btn-right'].forEach(id => {
  const el = document.getElementById(id);
  const dir = id.split('-')[1];
  const setDir = (active) => {
    if(dir==='up') mobileDir.y = active ? -1 : 0;
    if(dir==='down') mobileDir.y = active ? 1 : 0;
    if(dir==='left') mobileDir.x = active ? -1 : 0;
    if(dir==='right') mobileDir.x = active ? 1 : 0;
    if(active && 'vibrate' in navigator) navigator.vibrate(10);
  };
  el.addEventListener('touchstart', e => { e.preventDefault(); setDir(true); });
  el.addEventListener('touchend', e => { e.preventDefault(); setDir(false); });
  el.addEventListener('mousedown', e => { setDir(true); });
  el.addEventListener('mouseup', e => { setDir(false); });
});

// Action buttons
document.getElementById('btn-dash')?.addEventListener('touchstart', (e) => {
  e.preventDefault();
  if (player && gameState === 'playing') {
    const dashSpeed = player.baseSpeed * 2.5;
    if (player.facing === 0) player.y += dashSpeed;
    else if (player.facing === 1) player.x -= dashSpeed;
    else if (player.facing === 2) player.x += dashSpeed;
    else if (player.facing === 3) player.y -= dashSpeed;
    spawnParticles(player.x, player.y, 15, '#FFFF00', 120, 0.3);
    if ('vibrate' in navigator) navigator.vibrate(30);
  }
});

document.getElementById('btn-powerup')?.addEventListener('touchstart', (e) => {
  e.preventDefault();
  if (player && gameState === 'playing') {
    // Activate the first available powerup
    const powerupKeys = Object.keys(activePowerups);
    if (powerupKeys.length > 0) {
      showQuote(`${powerupKeys[0]} activated!`);
      if ('vibrate' in navigator) navigator.vibrate([20, 10, 20]);
    }
  }
});

// ============================================================
// PROCEDURAL MAP GENERATION SYSTEM
// ============================================================
// Tile types: 0=road, 1=sidewalk, 2=grass, 3=building, 4=hq, 5=meeting, 6=techDebt, 7=office(OKR spawn)

// Seeded Random Number Generator (for reproducible maps)
class SeededRandom {
  constructor(seed) {
    this.seed = seed % 2147483647;
    if (this.seed <= 0) this.seed += 2147483646;
  }
  next() {
    this.seed = (this.seed * 16807) % 2147483647;
    return (this.seed - 1) / 2147483646;
  }
  nextInt(min, max) {
    return Math.floor(this.next() * (max - min + 1)) + min;
  }
  choice(arr) {
    return arr[Math.floor(this.next() * arr.length)];
  }
}

// Map Themes - 10 distinct visual/gameplay themes
const MAP_THEMES = [
  { id: 'downtown', name: 'Downtown District', colors: { road: '#3a3a4a', grass: '#2d5a1e', building: '#4a4a5e' }, density: 'high', weather: ['clear', 'rain'] },
  { id: 'suburban', name: 'Suburban Sprawl', colors: { road: '#4a4a5a', grass: '#3d6a2e', building: '#5a5a6e' }, density: 'medium', weather: ['clear', 'fog'] },
  { id: 'industrial', name: 'Industrial Zone', colors: { road: '#2a2a3a', grass: '#1d3a1e', building: '#3a3a4e' }, density: 'high', weather: ['fog', 'clear'] },
  { id: 'campus', name: 'Tech Campus', colors: { road: '#4a5a6a', grass: '#4d7a3e', building: '#5a6a7e' }, density: 'low', weather: ['clear', 'rain'] },
  { id: 'financial', name: 'Financial District', colors: { road: '#2a2a2a', grass: '#1d2a1e', building: '#1a1a2e' }, density: 'extreme', weather: ['clear', 'rain'] },
  { id: 'retail', name: 'Retail Row', colors: { road: '#5a4a4a', grass: '#3d5a3e', building: '#6a5a5e' }, density: 'medium', weather: ['clear', 'snow'] },
  { id: 'nightlife', name: 'Nightlife Quarter', colors: { road: '#1a1a2a', grass: '#0d1a1e', building: '#2a2a3e' }, density: 'high', weather: ['rain', 'fog'] },
  { id: 'waterfront', name: 'Waterfront', colors: { road: '#3a4a5a', grass: '#2d4a5e', building: '#4a5a6e' }, density: 'low', weather: ['clear', 'fog'] },
  { id: 'oldtown', name: 'Old Town', colors: { road: '#5a5a4a', grass: '#4d6a3e', building: '#6a6a5e' }, density: 'medium', weather: ['clear', 'rain'] },
  { id: 'future', name: 'Future City', colors: { road: '#2a3a5a', grass: '#1d3a4e', building: '#3a4a7e' }, density: 'high', weather: ['clear', 'fog'] }
];

// Environmental variations
const WEATHER_EFFECTS = {
  clear: { visibility: 1.0, speedMod: 1.0, name: 'Clear' },
  rain: { visibility: 0.85, speedMod: 0.9, name: 'Rainy' },
  snow: { visibility: 0.7, speedMod: 0.8, name: 'Snowy' },
  fog: { visibility: 0.6, speedMod: 0.95, name: 'Foggy' }
};

const TIME_OF_DAY = {
  day: { brightness: 1.0, name: 'Day' },
  sunset: { brightness: 0.85, name: 'Sunset' },
  night: { brightness: 0.7, name: 'Night' }
};

// Chunk Library - 30+ handcrafted patterns (20x20 units)
// Pattern format: array of obstacle definitions with relative coords
const CHUNK_LIBRARY = [
  // OPEN CHUNKS (20% spawn rate)
  { id: 'open_park', difficulty: 0.1, type: 'open', pattern: [
    { type: 2, x: 0, y: 0, w: 20, h: 20 }, // grass
    { type: 0, x: 9, y: 0, w: 2, h: 20 }  // vertical road
  ]},
  { id: 'open_plaza', difficulty: 0.1, type: 'open', pattern: [
    { type: 0, x: 0, y: 0, w: 20, h: 20 }, // all road
    { type: 7, x: 5, y: 5, w: 2, h: 2 },   // office
    { type: 7, x: 13, y: 13, w: 2, h: 2 }
  ]},
  { id: 'open_cross', difficulty: 0.15, type: 'open', pattern: [
    { type: 2, x: 0, y: 0, w: 20, h: 20 },
    { type: 0, x: 9, y: 0, w: 2, h: 20 },
    { type: 0, x: 0, y: 9, w: 20, h: 2 }
  ]},
  { id: 'open_wide', difficulty: 0.1, type: 'open', pattern: [
    { type: 0, x: 0, y: 0, w: 20, h: 20 }, // wide open
    { type: 5, x: 10, y: 10, w: 1, h: 1 }  // single meeting
  ]},
  { id: 'open_scattered', difficulty: 0.2, type: 'open', pattern: [
    { type: 0, x: 0, y: 0, w: 20, h: 20 },
    { type: 3, x: 3, y: 3, w: 2, h: 2 },
    { type: 3, x: 15, y: 15, w: 2, h: 2 },
    { type: 7, x: 10, y: 10, w: 2, h: 2 }
  ]},
  
  // MEDIUM CHUNKS (40% spawn rate)
  { id: 'med_zigzag', difficulty: 0.4, type: 'medium', pattern: [
    { type: 2, x: 0, y: 0, w: 20, h: 20 },
    { type: 0, x: 0, y: 5, w: 10, h: 2 },
    { type: 0, x: 10, y: 13, w: 10, h: 2 },
    { type: 0, x: 8, y: 5, w: 2, h: 10 },
    { type: 5, x: 5, y: 8, w: 1, h: 1 },
    { type: 5, x: 14, y: 11, w: 1, h: 1 }
  ]},
  { id: 'med_cluster', difficulty: 0.45, type: 'medium', pattern: [
    { type: 0, x: 0, y: 0, w: 20, h: 20 },
    { type: 3, x: 6, y: 6, w: 3, h: 3 },
    { type: 3, x: 11, y: 11, w: 3, h: 3 },
    { type: 5, x: 8, y: 3, w: 1, h: 1 },
    { type: 5, x: 3, y: 12, w: 1, h: 1 },
    { type: 7, x: 15, y: 5, w: 2, h: 2 }
  ]},
  { id: 'med_corridor', difficulty: 0.4, type: 'medium', pattern: [
    { type: 2, x: 0, y: 0, w: 20, h: 20 },
    { type: 0, x: 9, y: 0, w: 2, h: 20 },
    { type: 3, x: 4, y: 5, w: 4, h: 3 },
    { type: 3, x: 12, y: 12, w: 4, h: 3 },
    { type: 5, x: 10, y: 8, w: 1, h: 1 }
  ]},
  { id: 'med_scattered', difficulty: 0.5, type: 'medium', pattern: [
    { type: 0, x: 0, y: 0, w: 20, h: 20 },
    { type: 5, x: 3, y: 3, w: 1, h: 1 },
    { type: 5, x: 8, y: 7, w: 1, h: 1 },
    { type: 5, x: 12, y: 12, w: 1, h: 1 },
    { type: 5, x: 16, y: 5, w: 1, h: 1 },
    { type: 3, x: 10, y: 10, w: 2, h: 2 }
  ]},
  { id: 'med_loop', difficulty: 0.45, type: 'medium', pattern: [
    { type: 2, x: 0, y: 0, w: 20, h: 20 },
    { type: 0, x: 5, y: 5, w: 10, h: 2 },
    { type: 0, x: 5, y: 13, w: 10, h: 2 },
    { type: 0, x: 5, y: 5, w: 2, h: 10 },
    { type: 0, x: 13, y: 5, w: 2, h: 10 },
    { type: 3, x: 8, y: 8, w: 4, h: 4 }
  ]},
  { id: 'med_diagonal', difficulty: 0.5, type: 'medium', pattern: [
    { type: 0, x: 0, y: 0, w: 20, h: 20 },
    { type: 5, x: 2, y: 2, w: 1, h: 1 },
    { type: 5, x: 6, y: 6, w: 1, h: 1 },
    { type: 5, x: 10, y: 10, w: 1, h: 1 },
    { type: 5, x: 14, y: 14, w: 1, h: 1 },
    { type: 3, x: 4, y: 12, w: 2, h: 2 }
  ]},
  { id: 'med_offices', difficulty: 0.4, type: 'medium', pattern: [
    { type: 0, x: 0, y: 0, w: 20, h: 20 },
    { type: 7, x: 3, y: 3, w: 3, h: 3 },
    { type: 7, x: 14, y: 3, w: 3, h: 3 },
    { type: 7, x: 3, y: 14, w: 3, h: 3 },
    { type: 5, x: 10, y: 10, w: 1, h: 1 }
  ]},
  { id: 'med_streets', difficulty: 0.45, type: 'medium', pattern: [
    { type: 2, x: 0, y: 0, w: 20, h: 20 },
    { type: 0, x: 0, y: 6, w: 20, h: 2 },
    { type: 0, x: 0, y: 13, w: 20, h: 2 },
    { type: 3, x: 5, y: 9, w: 3, h: 3 },
    { type: 3, x: 12, y: 2, w: 3, h: 3 },
    { type: 5, x: 15, y: 10, w: 1, h: 1 }
  ]},

  // HARD CHUNKS (30% spawn rate)
  { id: 'hard_maze', difficulty: 0.7, type: 'hard', pattern: [
    { type: 2, x: 0, y: 0, w: 20, h: 20 },
    { type: 0, x: 2, y: 2, w: 2, h: 16 },
    { type: 0, x: 6, y: 2, w: 2, h: 12 },
    { type: 0, x: 10, y: 6, w: 2, h: 12 },
    { type: 0, x: 14, y: 2, w: 2, h: 14 },
    { type: 5, x: 4, y: 10, w: 1, h: 1 },
    { type: 5, x: 8, y: 5, w: 1, h: 1 },
    { type: 5, x: 12, y: 15, w: 1, h: 1 }
  ]},
  { id: 'hard_fortress', difficulty: 0.75, type: 'hard', pattern: [
    { type: 0, x: 0, y: 0, w: 20, h: 20 },
    { type: 3, x: 4, y: 4, w: 12, h: 12 },
    { type: 0, x: 9, y: 4, w: 2, h: 6 },
    { type: 0, x: 9, y: 14, w: 2, h: 2 },
    { type: 5, x: 10, y: 8, w: 1, h: 1 },
    { type: 7, x: 8, y: 10, w: 4, h: 4 }
  ]},
  { id: 'hard_gauntlet', difficulty: 0.8, type: 'hard', pattern: [
    { type: 2, x: 0, y: 0, w: 20, h: 20 },
    { type: 0, x: 9, y: 0, w: 2, h: 20 },
    { type: 5, x: 10, y: 3, w: 1, h: 1 },
    { type: 5, x: 10, y: 7, w: 1, h: 1 },
    { type: 5, x: 10, y: 11, w: 1, h: 1 },
    { type: 5, x: 10, y: 15, w: 1, h: 1 },
    { type: 6, x: 9, y: 5, w: 2, h: 1 }
  ]},
  { id: 'hard_techdebt', difficulty: 0.7, type: 'hard', pattern: [
    { type: 0, x: 0, y: 0, w: 20, h: 20 },
    { type: 6, x: 3, y: 3, w: 4, h: 4 },
    { type: 6, x: 13, y: 13, w: 4, h: 4 },
    { type: 6, x: 8, y: 8, w: 4, h: 4 },
    { type: 5, x: 6, y: 15, w: 1, h: 1 }
  ]},
  { id: 'hard_narrow', difficulty: 0.75, type: 'hard', pattern: [
    { type: 2, x: 0, y: 0, w: 20, h: 20 },
    { type: 0, x: 9, y: 0, w: 2, h: 8 },
    { type: 0, x: 5, y: 8, w: 10, h: 2 },
    { type: 0, x: 5, y: 10, w: 2, h: 10 },
    { type: 5, x: 10, y: 4, w: 1, h: 1 },
    { type: 5, x: 8, y: 9, w: 1, h: 1 },
    { type: 5, x: 6, y: 14, w: 1, h: 1 }
  ]},
  { id: 'hard_gridlock', difficulty: 0.7, type: 'hard', pattern: [
    { type: 0, x: 0, y: 0, w: 20, h: 20 },
    { type: 3, x: 3, y: 3, w: 2, h: 2 },
    { type: 3, x: 8, y: 3, w: 2, h: 2 },
    { type: 3, x: 13, y: 3, w: 2, h: 2 },
    { type: 3, x: 3, y: 10, w: 2, h: 2 },
    { type: 3, x: 8, y: 10, w: 2, h: 2 },
    { type: 3, x: 13, y: 10, w: 2, h: 2 },
    { type: 5, x: 6, y: 7, w: 1, h: 1 },
    { type: 5, x: 11, y: 14, w: 1, h: 1 }
  ]},
  { id: 'hard_meetings', difficulty: 0.75, type: 'hard', pattern: [
    { type: 0, x: 0, y: 0, w: 20, h: 20 },
    { type: 5, x: 4, y: 4, w: 1, h: 1 },
    { type: 5, x: 8, y: 4, w: 1, h: 1 },
    { type: 5, x: 12, y: 4, w: 1, h: 1 },
    { type: 5, x: 4, y: 10, w: 1, h: 1 },
    { type: 5, x: 8, y: 10, w: 1, h: 1 },
    { type: 5, x: 12, y: 10, w: 1, h: 1 },
    { type: 5, x: 4, y: 15, w: 1, h: 1 },
    { type: 5, x: 12, y: 15, w: 1, h: 1 }
  ]},
  { id: 'hard_spiral', difficulty: 0.8, type: 'hard', pattern: [
    { type: 2, x: 0, y: 0, w: 20, h: 20 },
    { type: 0, x: 2, y: 2, w: 16, h: 2 },
    { type: 0, x: 16, y: 2, w: 2, h: 14 },
    { type: 0, x: 4, y: 14, w: 14, h: 2 },
    { type: 0, x: 4, y: 6, w: 2, h: 10 },
    { type: 0, x: 4, y: 6, w: 10, h: 2 },
    { type: 5, x: 10, y: 10, w: 1, h: 1 }
  ]},

  // EXTREME CHUNKS (10% spawn rate)
  { id: 'extreme_chaos', difficulty: 1.0, type: 'extreme', pattern: [
    { type: 0, x: 0, y: 0, w: 20, h: 20 },
    { type: 5, x: 3, y: 3, w: 1, h: 1 },
    { type: 5, x: 6, y: 6, w: 1, h: 1 },
    { type: 5, x: 9, y: 4, w: 1, h: 1 },
    { type: 5, x: 12, y: 8, w: 1, h: 1 },
    { type: 5, x: 15, y: 5, w: 1, h: 1 },
    { type: 6, x: 4, y: 12, w: 3, h: 3 },
    { type: 6, x: 12, y: 12, w: 3, h: 3 },
    { type: 3, x: 8, y: 16, w: 4, h: 3 }
  ]},
  { id: 'extreme_minefield', difficulty: 0.95, type: 'extreme', pattern: [
    { type: 0, x: 0, y: 0, w: 20, h: 20 },
    { type: 6, x: 3, y: 3, w: 2, h: 2 },
    { type: 6, x: 8, y: 3, w: 2, h: 2 },
    { type: 6, x: 13, y: 3, w: 2, h: 2 },
    { type: 6, x: 3, y: 10, w: 2, h: 2 },
    { type: 6, x: 8, y: 10, w: 2, h: 2 },
    { type: 6, x: 13, y: 10, w: 2, h: 2 },
    { type: 6, x: 3, y: 15, w: 2, h: 2 }
  ]},
  { id: 'extreme_labyrinth', difficulty: 1.0, type: 'extreme', pattern: [
    { type: 2, x: 0, y: 0, w: 20, h: 20 },
    { type: 0, x: 2, y: 2, w: 2, h: 2 },
    { type: 0, x: 2, y: 6, w: 6, h: 2 },
    { type: 0, x: 10, y: 2, w: 2, h: 8 },
    { type: 0, x: 6, y: 10, w: 6, h: 2 },
    { type: 0, x: 14, y: 6, w: 2, h: 10 },
    { type: 5, x: 3, y: 3, w: 1, h: 1 },
    { type: 5, x: 6, y: 7, w: 1, h: 1 },
    { type: 5, x: 11, y: 5, w: 1, h: 1 },
    { type: 6, x: 8, y: 11, w: 2, h: 2 }
  ]},
  { id: 'extreme_boss', difficulty: 1.0, type: 'extreme', pattern: [
    { type: 0, x: 0, y: 0, w: 20, h: 20 },
    { type: 3, x: 2, y: 2, w: 16, h: 16 },
    { type: 0, x: 9, y: 2, w: 2, h: 8 },
    { type: 7, x: 8, y: 11, w: 4, h: 6 },
    { type: 5, x: 10, y: 5, w: 1, h: 1 },
    { type: 6, x: 9, y: 8, w: 2, h: 2 }
  ]},
];

// Adaptive Difficulty System
let playerDeaths = {};
let playerDifficultyPreference = 1.0;

function loadDifficultyPreference() {
  try {
    const saved = localStorage.getItem('teamDominosDifficulty');
    if (saved) {
      const data = JSON.parse(saved);
      playerDifficultyPreference = data.preference || 1.0;
      playerDeaths = data.deaths || {};
    }
  } catch (e) {}
}

function saveDifficultyPreference() {
  try {
    localStorage.setItem('teamDominosDifficulty', JSON.stringify({
      preference: playerDifficultyPreference,
      deaths: playerDeaths
    }));
  } catch (e) {}
}

function recordDeath(chunkId) {
  playerDeaths[chunkId] = (playerDeaths[chunkId] || 0) + 1;
  if (playerDeaths[chunkId] > 5) {
    playerDifficultyPreference = Math.max(0.5, playerDifficultyPreference - 0.05);
    saveDifficultyPreference();
  }
}

function recordSuccess() {
  playerDifficultyPreference = Math.min(1.5, playerDifficultyPreference + 0.02);
  saveDifficultyPreference();
}

// Generate seed from date + player ID
function generateDailySeed() {
  const date = new Date();
  const dayCode = date.getFullYear() * 10000 + (date.getMonth() + 1) * 100 + date.getDate();
  const playerCode = playerName.split('').reduce((acc, c) => acc + c.charCodeAt(0), 0);
  return dayCode + playerCode;
}

// Procedural map generation with chunk system
function generateMap(level, customSeed = null) {
  loadDifficultyPreference();
  
  const seed = customSeed || generateDailySeed();
  const rng = new SeededRandom(seed);
  
  // Select theme based on level (cycle through 10 themes)
  const theme = MAP_THEMES[level % MAP_THEMES.length];
  
  // Environmental conditions
  const weather = rng.choice(theme.weather);
  const timeOfDay = rng.choice(['day', 'sunset', 'night']);
  
  // Determine map size (increases with level)
  const chunksX = 3 + Math.floor(level / 2);
  const chunksY = 3 + Math.floor(level / 2);
  const chunkSize = 20;
  const w = chunksX * chunkSize;
  const h = chunksY * chunkSize;
  
  // Initialize grid
  const grid = [];
  for (let y = 0; y < h; y++) {
    grid[y] = [];
    for (let x = 0; x < w; x++) grid[y][x] = 2; // grass
  }
  
  // Difficulty-weighted chunk selection (adjusted by player preference)
  const difficultyWeights = {
    open: 0.20,
    medium: 0.40,
    hard: 0.30,
    extreme: 0.10
  };
  
  // Adjust weights based on level and player preference
  const levelFactor = Math.min(1.0, level / 10);
  difficultyWeights.extreme *= levelFactor * playerDifficultyPreference;
  difficultyWeights.hard *= (0.5 + levelFactor * 0.5) * playerDifficultyPreference;
  
  // Assemble chunks
  const placedChunks = [];
  for (let cy = 0; cy < chunksY; cy++) {
    for (let cx = 0; cx < chunksX; cx++) {
      // Select chunk based on difficulty weights
      const roll = rng.next();
      let chunkType = 'open';
      let cumulative = 0;
      for (const [type, weight] of Object.entries(difficultyWeights)) {
        cumulative += weight;
        if (roll < cumulative) {
          chunkType = type;
          break;
        }
      }
      
      // Get chunks of selected type
      const availableChunks = CHUNK_LIBRARY.filter(c => c.type === chunkType);
      const chunk = rng.choice(availableChunks);
      
      // Place chunk pattern
      const offsetX = cx * chunkSize;
      const offsetY = cy * chunkSize;
      
      for (const item of chunk.pattern) {
        for (let dy = 0; dy < item.h; dy++) {
          for (let dx = 0; dx < item.w; dx++) {
            const tx = offsetX + item.x + dx;
            const ty = offsetY + item.y + dy;
            if (tx < w && ty < h) {
              grid[ty][tx] = item.type;
            }
          }
        }
      }
      
      placedChunks.push({ chunk, x: cx, y: cy });
    }
  }
  
  // Add sidewalks next to roads
  for (let y = 0; y < h; y++) {
    for (let x = 0; x < w; x++) {
      if (grid[y][x] === 2) {
        let adjRoad = false;
        if (x > 0 && grid[y][x-1] === 0) adjRoad = true;
        if (x < w-1 && grid[y][x+1] === 0) adjRoad = true;
        if (y > 0 && grid[y-1][x] === 0) adjRoad = true;
        if (y < h-1 && grid[y+1][x] === 0) adjRoad = true;
        if (adjRoad) grid[y][x] = 1;
      }
    }
  }
  
  // Place HQ near center
  const hqX = Math.floor(w / 2);
  const hqY = Math.floor(h / 2);
  for (let dy = -1; dy <= 1; dy++) {
    for (let dx = -1; dx <= 1; dx++) {
      if (hqY+dy >= 0 && hqY+dy < h && hqX+dx >= 0 && hqX+dx < w) {
        grid[hqY+dy][hqX+dx] = 4;
      }
    }
  }
  
  // Clear road access around HQ
  for (let dy = -2; dy <= 2; dy++) {
    for (let dx = -2; dx <= 2; dx++) {
      const ty = hqY + dy, tx = hqX + dx;
      if (ty >= 0 && ty < h && tx >= 0 && tx < w && grid[ty][tx] !== 4) {
        grid[ty][tx] = 0;
      }
    }
  }
  
  // Find player start - a road tile near edge
  let startX = 2, startY = 2;
  outer: for (let y = 1; y < h; y++) {
    for (let x = 1; x < w; x++) {
      if (grid[y][x] === 0) {
        startX = x;
        startY = y;
        break outer;
      }
    }
  }
  
  // Collect buildings for reference
  const buildings = [];
  for (let y = 0; y < h - 1; y++) {
    for (let x = 0; x < w - 1; x++) {
      if ((grid[y][x] === 3 || grid[y][x] === 7) && 
          (x === 0 || grid[y][x-1] !== grid[y][x]) &&
          (y === 0 || grid[y-1][x] !== grid[y][x])) {
        let bw = 1, bh = 1;
        while (x + bw < w && grid[y][x + bw] === grid[y][x]) bw++;
        while (y + bh < h && grid[y + bh][x] === grid[y][x]) bh++;
        buildings.push({ x, y, w: bw, h: bh, isOffice: grid[y][x] === 7 });
      }
    }
  }
  
  return {
    grid, w, h, hqX, hqY, startX, startY, buildings,
    theme, weather, timeOfDay, seed, placedChunks
  };
}

// ============================================================
// SPAWN OKRs AND POWERUPS
// ============================================================
function findAdjacentRoad(tx, ty) {
  // Search for nearest road tile (type 0) adjacent to the given tile
  const dirs = [[0,-1],[0,1],[-1,0],[1,0],[-1,-1],[1,-1],[-1,1],[1,1]];
  for(let d of dirs) {
    const nx = tx+d[0], ny = ty+d[1];
    if(nx>=0 && nx<mapData.w && ny>=0 && ny<mapData.h && mapData.grid[ny][nx]===0) {
      return {x:nx, y:ny};
    }
  }
  return null; // no adjacent road found
}

function spawnOKRs(level) {
  okrs = [];
  const count = 3 + level * 2;
  requiredDeliveries = count;
  deliveredOKRs = 0;

  // Find office tiles and resolve them to adjacent road tiles
  const officeRoads = [];
  for(let y=0; y<mapData.h; y++) {
    for(let x=0; x<mapData.w; x++) {
      if(mapData.grid[y][x]===7) {
        const adj = findAdjacentRoad(x, y);
        if(adj) officeRoads.push(adj);
      }
    }
  }

  // Also allow road tiles if not enough office-adjacent roads
  const roads = [];
  for(let y=0; y<mapData.h; y++) {
    for(let x=0; x<mapData.w; x++) {
      if(mapData.grid[y][x]===0) roads.push({x,y});
    }
  }

  const spawnTiles = officeRoads.length >= count ? officeRoads : [...officeRoads, ...roads];

  for(let i=0; i<count; i++) {
    const idx = Math.floor(Math.random()*spawnTiles.length);
    const t = spawnTiles[idx];
    okrs.push({ x:t.x*TILE+TILE/2, y:t.y*TILE+TILE/2, collected:false, bobPhase:Math.random()*Math.PI*2 });
    spawnTiles.splice(idx, 1); // BUG 4 FIX: remove used tile to prevent duplicates
  }
}

function spawnPowerups(level) {
  powerups = [];
  const count = 2 + level;
  
  // Helper to select power-up type based on rarity weights
  function selectPowerupType() {
    const totalWeight = POWERUP_TYPES.reduce((sum, p) => sum + RARITY[p.rarity].spawnWeight, 0);
    let roll = Math.random() * totalWeight;
    for(let type of POWERUP_TYPES) {
      roll -= RARITY[type.rarity].spawnWeight;
      if(roll <= 0) return type;
    }
    return POWERUP_TYPES[0]; // fallback
  }
  
  for(let i=0; i<count; i++) {
    let px, py, tries=0;
    do {
      px = Math.floor(Math.random()*mapData.w);
      py = Math.floor(Math.random()*mapData.h);
      tries++;
    } while(tries<100 && mapData.grid[py][px]!==0);
    const type = selectPowerupType();
    const rarityData = RARITY[type.rarity];
    powerups.push({ 
      x:px*TILE+TILE/2, 
      y:py*TILE+TILE/2, 
      type, 
      rarity:rarityData,
      collected:false, 
      bobPhase:Math.random()*Math.PI*2,
      glowPhase:Math.random()*Math.PI*2,
      particles:[] // Local particle trail
    });
  }
}

function spawnEnemies(level) {
  enemies = [];
  const count = 1 + Math.floor(level * 1.5);
  for(let i=0; i<count; i++) {
    let ex, ey, tries=0;
    do {
      ex = Math.floor(Math.random()*mapData.w);
      ey = Math.floor(Math.random()*mapData.h);
      tries++;
    } while(tries<100 && (mapData.grid[ey][ex]!==0 || (Math.abs(ex-mapData.hqX)<5&&Math.abs(ey-mapData.hqY)<5)));
    enemies.push({
      x:ex*TILE+TILE/2, y:ey*TILE+TILE/2,
      vx:(Math.random()-0.5)*60, vy:(Math.random()-0.5)*60,
      changeTimer:Math.random()*3,
      phase:Math.random()*Math.PI*2
    });
  }
}

// ============================================================
// COLLISION
// ============================================================
function isSolid(tileX, tileY) {
  if(tileX<0||tileY<0||tileX>=mapData.w||tileY>=mapData.h) return true;
  const t = mapData.grid[tileY][tileX];
  if(activePowerups.ghost) return false; // ghost mode passes through everything
  if(activePowerups.shield) return t===3||t===7; // buildings always solid, but pass meetings/debt
  return t===3||t===5||t===7; // building, meeting, office building
}

function tileAt(px, py) {
  const tx = Math.floor(px/TILE);
  const ty = Math.floor(py/TILE);
  if(tx<0||ty<0||tx>=mapData.w||ty>=mapData.h) return -1;
  return mapData.grid[ty][tx];
}

// ============================================================
// PARTICLES
// ============================================================
function spawnParticles(x, y, count, color, spread, life) {
  const profile = QualitySettings.getProfile();
  count = Math.floor(count * profile.particleMultiplier);
  
  for(let i=0; i<count; i++) {
    const p = ParticlePool.acquire();
    p.x = x;
    p.y = y;
    p.vx = (Math.random()-0.5)*spread;
    p.vy = (Math.random()-0.5)*spread - spread*0.3;
    p.life = life || (0.5+Math.random()*0.5);
    p.maxLife = life || (0.5+Math.random()*0.5);
    p.color = color || `hsl(${Math.random()*360},80%,60%)`;
    p.size = 2+Math.random()*3;
    p.active = true;
    p.confetti = false;
    particles.push(p);
  }
}

function spawnConfetti(x, y) {
  const profile = QualitySettings.getProfile();
  const count = Math.floor(40 * profile.particleMultiplier);
  const colors = ['#E21A2C','#006491','#FFD700','#00CC66','#FF69B4','#FF8C00'];
  for(let i=0; i<count; i++) {
    const p = ParticlePool.acquire();
    p.x = x;
    p.y = y;
    p.vx = (Math.random()-0.5)*300;
    p.vy = (Math.random()-0.5)*300 - 100;
    p.life = 1+Math.random();
    p.maxLife = 1+Math.random();
    p.color = colors[Math.floor(Math.random()*colors.length)];
    p.size = 3+Math.random()*4;
    p.confetti = true;
    p.active = true;
    particles.push(p);
  }
}

// ============================================================
// SHOW QUOTE
// ============================================================
function showQuote(text, dramatic = false) {
  quotePopup.textContent = text;
  quotePopup.style.opacity = '1';
  if (dramatic) {
    quotePopup.classList.add('show-dramatic');
    setTimeout(() => quotePopup.classList.remove('show-dramatic'), 500);
  }
  quoteTimer = 2.5;
}

// ============================================================
// COMBO SYSTEM
// ============================================================
function initAudio() {
  if (!audioCtx) {
    try {
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    } catch(e) {
      comboSoundEnabled = false;
    }
  }
}

function playComboSound(frequency, duration) {
  if (!comboSoundEnabled || !audioCtx) return;
  try {
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.frequency.value = frequency;
    osc.type = 'sine';
    gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
    osc.start();
    osc.stop(audioCtx.currentTime + duration);
  } catch(e) {}
}

function triggerCombo(type, worldX, worldY) {
  const trigger = COMBO_TRIGGERS[type];
  if (!trigger) return;
  
  initAudio();
  
  // Increase combo multiplier
  comboMultiplier = Math.min(comboMultiplier + COMBO_INCREMENT, MAX_COMBO_MULTIPLIER);
  comboTimer = COMBO_GRACE_PERIOD;
  
  // Calculate points with multiplier
  const basePoints = trigger.points;
  const totalPoints = Math.floor(basePoints * comboMultiplier);
  
  // Add to tokens
  tokens += totalPoints;
  
  // Update stats
  const statKey = type + 's';
  comboStats[statKey] = (comboStats[statKey] || 0) + 1;
  comboStats.totalComboPoints += totalPoints;
  comboStats.maxCombo = Math.max(comboStats.maxCombo, comboMultiplier);
  
  // Create floating text
  createFloatingText(trigger.text, worldX, worldY, trigger.color);
  createFloatingText(`+${totalPoints}`, worldX, worldY + 30, '#FFD700');
  
  // Spawn combo particles
  spawnComboParticles(worldX, worldY, trigger.color);
  
  // Play combo sound
  const baseFreq = 440;
  const freq = baseFreq + (comboMultiplier - 1) * 100;
  playComboSound(freq, 0.15);
  
  // Milestone sounds
  if (comboMultiplier === 5.0) {
    playComboSound(880, 0.3);
    setTimeout(() => playComboSound(1100, 0.2), 100);
    shakeTimer = 0.3;
    shakeIntensity = 8;
  } else if (comboMultiplier === 8.0) {
    playComboSound(1100, 0.3);
    setTimeout(() => playComboSound(1320, 0.2), 100);
    setTimeout(() => playComboSound(1540, 0.2), 200);
    shakeTimer = 0.4;
    shakeIntensity = 10;
  } else if (comboMultiplier === 10.0) {
    for (let i = 0; i < 5; i++) {
      setTimeout(() => playComboSound(1760 + i * 100, 0.15), i * 80);
    }
    shakeTimer = 0.5;
    shakeIntensity = 15;
    createFloatingText('MAX COMBO!!!', worldX, worldY - 40, '#FF00FF', 48);
  }
  
  // Update combo UI
  updateComboUI();
}

function breakCombo() {
  if (comboMultiplier > 1.0) {
    // Play sad sound
    if (comboSoundEnabled && audioCtx) {
      playComboSound(220, 0.5);
    }
    
    // Show combo break message
    createFloatingText('COMBO BREAK', player.x, player.y - 20, '#FF0000');
  }
  
  comboMultiplier = 1.0;
  comboTimer = 0;
  updateComboUI();
}

function updateComboUI() {
  const comboCounter = document.getElementById('combo-counter');
  const comboMultiplierEl = document.getElementById('combo-multiplier');
  
  if (comboMultiplier > 1.0) {
    comboCounter.style.display = 'block';
    comboMultiplierEl.textContent = comboMultiplier.toFixed(1) + 'x';
    
    // Color based on multiplier level
    let color = '#FFFFFF';
    if (comboMultiplier >= 10) color = '#FF0000';
    else if (comboMultiplier >= 8) color = '#FF4500';
    else if (comboMultiplier >= 5) color = '#FF8C00';
    else if (comboMultiplier >= 3) color = '#FFD700';
    
    comboMultiplierEl.style.color = color;
    comboMultiplierEl.style.textShadow = `0 0 20px ${color}, 3px 3px 8px rgba(0,0,0,0.8)`;
    
    // Scale effect
    const scale = 1 + (comboMultiplier - 1) * 0.05;
    comboMultiplierEl.style.transform = `scale(${Math.min(scale, 1.5)})`;
  } else {
    comboCounter.style.display = 'none';
  }
}

function createFloatingText(text, worldX, worldY, color, size = 28) {
  // Convert world coords to screen coords
  const screenX = worldX - camera.x;
  const screenY = worldY - camera.y;
  
  const textEl = document.createElement('div');
  textEl.className = 'combo-text';
  textEl.textContent = text;
  textEl.style.left = screenX + 'px';
  textEl.style.top = screenY + 'px';
  textEl.style.color = color;
  textEl.style.fontSize = size + 'px';
  document.getElementById('ui-overlay').appendChild(textEl);
  
  floatingTexts.push({ el: textEl, life: 1.0 });
  
  setTimeout(() => {
    if (textEl.parentNode) textEl.parentNode.removeChild(textEl);
  }, 1000);
}

function spawnComboParticles(x, y, color) {
  spawnParticles(x, y, 15, color, 150, 0.8);
}

function checkNearMiss(px, py) {
  // Check distance to enemies
  for (let e of enemies) {
    const dist = Math.hypot(px - e.x, py - e.y);
    if (dist < TILE * 2 && dist > TILE * 0.7) {
      // Near miss detected
      if (!e.nearMissTriggered) {
        e.nearMissTriggered = true;
        triggerCombo('nearMiss', px, py);
        setTimeout(() => e.nearMissTriggered = false, 1000);
        return true;
      }
    }
  }
  return false;
}

function checkRiskyMove(px, py) {
  // Check if collecting OKR while sprinting near enemy
  if (activePowerups.sprint || activePowerups.dash) {
    for (let e of enemies) {
      const dist = Math.hypot(px - e.x, py - e.y);
      if (dist < TILE * 3) {
        return true;
      }
    }
  }
  return false;
}

function updateComboTimer(dt) {
  if (comboTimer > 0) {
    comboTimer -= dt;
    if (comboTimer <= 0 && comboMultiplier > 1.0) {
      // Combo expired
      comboMultiplier = Math.max(1.0, comboMultiplier - COMBO_INCREMENT);
      comboTimer = COMBO_GRACE_PERIOD;
      updateComboUI();
      
      if (comboMultiplier <= 1.0) {
        comboTimer = 0;
      }
    }
  }
}

function saveComboStats() {
  try {
    const stats = JSON.parse(localStorage.getItem('teamDominosComboStats') || '{}');
    stats.allTimeNearMisses = (stats.allTimeNearMisses || 0) + comboStats.nearMisses;
    stats.allTimeSpeedDeliveries = (stats.allTimeSpeedDeliveries || 0) + comboStats.speedDeliveries;
    stats.allTimePerfectPickups = (stats.allTimePerfectPickups || 0) + comboStats.perfectPickups;
    stats.allTimeChainDeliveries = (stats.allTimeChainDeliveries || 0) + comboStats.chainDeliveries;
    stats.allTimeRiskyMoves = (stats.allTimeRiskyMoves || 0) + comboStats.riskyMoves;
    stats.highestCombo = Math.max(stats.highestCombo || 1.0, comboStats.maxCombo);
    stats.totalComboPoints = (stats.totalComboPoints || 0) + comboStats.totalComboPoints;
    localStorage.setItem('teamDominosComboStats', JSON.stringify(stats));
  } catch(e) {}
}

function getComboStats() {
  try {
    return JSON.parse(localStorage.getItem('teamDominosComboStats') || '{}');
  } catch(e) {
    return {};
  }
}

// ============================================================
// POWER-UP UI AND EFFECTS
// ============================================================
function updatePowerupUI() {
  const active = Object.keys(powerupTimers);
  if(active.length === 0) {
    powerupPanel.style.display = 'none';
    return;
  }
  
  powerupPanel.style.display = 'flex';
  powerupPanel.innerHTML = active.map(id => {
    const timer = powerupTimers[id];
    const type = POWERUP_TYPES.find(p => p.id === id);
    const rarity = RARITY[type.rarity];
    const progress = (timer.current / timer.max) * 100;
    const isWarning = timer.current <= 3;
    
    return `
      <div class="powerup-active ${isWarning ? 'warning' : ''}" style="border-left-color: ${rarity.color}">
        <div class="powerup-icon" style="background: ${rarity.color}; color: #000;">${type.icon}</div>
        <div class="powerup-info">
          <div class="powerup-name">${type.name}</div>
          <div class="powerup-timer-bar">
            <div class="powerup-timer-fill" style="width: ${progress}%"></div>
          </div>
        </div>
      </div>
    `;
  }).join('');
}

function updateScreenEffect(dt) {
  screenEffectCtx.clearRect(0, 0, canvasWidth, canvasHeight);
  
  // Get dominant power-up color for screen tint
  const active = Object.keys(activePowerups);
  if(active.length === 0) return;
  
  // Create vignette effect with power-up color
  const type = POWERUP_TYPES.find(p => p.id === active[0]);
  if(!type) return;
  
  const rarity = RARITY[type.rarity];
  const gradient = screenEffectCtx.createRadialGradient(
    canvasWidth/2, canvasHeight/2, 0,
    canvasWidth/2, canvasHeight/2, Math.max(canvasWidth, canvasHeight)*0.7
  );
  gradient.addColorStop(0, 'rgba(0,0,0,0)');
  gradient.addColorStop(1, rarity.glow + '0.15)');
  
  screenEffectCtx.fillStyle = gradient;
  screenEffectCtx.fillRect(0, 0, canvasWidth, canvasHeight);
}

function spawnPlayerTrailParticle(x, y, color) {
  powerupParticles.push({
    x, y,
    vx:(Math.random()-0.5)*20,
    vy:(Math.random()-0.5)*20,
    life:0.5,
    maxLife:0.5,
    color,
    size:3+Math.random()*2
  });
}

function updatePlayerTrail(dt) {
  // Update and remove dead particles
  for(let i=powerupParticles.length-1; i>=0; i--) {
    const p = powerupParticles[i];
    p.life -= dt;
    p.x += p.vx * dt;
    p.y += p.vy * dt;
    p.vx *= 0.95;
    p.vy *= 0.95;
    if(p.life <= 0) powerupParticles.splice(i, 1);
  }
  
  // Spawn new trail particles if active power-ups
  if(Object.keys(activePowerups).length > 0 && player) {
    const type = POWERUP_TYPES.find(p => Object.keys(activePowerups).includes(p.id));
    if(type) {
      const rarity = RARITY[type.rarity];
      if(Math.random() < 0.3) {
        spawnPlayerTrailParticle(player.x, player.y, rarity.color);
      }
    }
  }
}

function createBurstParticles(x, y, color, count = 30) {
  for(let i=0; i<count; i++) {
    const angle = (i / count) * Math.PI * 2;
    const speed = 150 + Math.random() * 100;
    particles.push({
      x, y,
      vx:Math.cos(angle) * speed,
      vy:Math.sin(angle) * speed,
      life:0.8 + Math.random() * 0.4,
      maxLife:0.8 + Math.random() * 0.4,
      color,
      size:4 + Math.random() * 3
    });
  }
}

// Sound effect simulation
function playPowerupSound(rarity) {
  // Create simple beep effect based on rarity
  const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  const oscillator = audioCtx.createOscillator();
  const gainNode = audioCtx.createGain();
  
  oscillator.connect(gainNode);
  gainNode.connect(audioCtx.destination);
  
  // Different frequencies for different rarities
  const freqs = { common:440, rare:550, epic:660, legendary:880 };
  oscillator.frequency.value = freqs[rarity] || 440;
  
  gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime);
  gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
  
  oscillator.start();
  oscillator.stop(audioCtx.currentTime + 0.3);
}

// ============================================================
// SCREENS
// ============================================================
function showTitle() {
  gameState = 'title';
  hud.style.display = 'none';
  minimapContainer.style.display = 'none';
  gameRunning = false;
  overlay.style.display = 'flex';
  overlay.className = 'screen-bg';
  
  // Hide daily challenge UI
  document.getElementById('daily-challenge-hud').style.display = 'none';
  document.getElementById('streak-badge').style.display = 'none';
  
  overlay.innerHTML = `
    <div style="text-align:center;">
      <div class="title-logo">TEAM DOMINOS</div>
      <div class="title-sub">Delivering OKRs Since 2024</div>
      <div style="margin:20px 0;font-size:40px;">&#127829;</div>
      <button class="menu-btn" onclick="showModeSelect()">PLAY GAME</button><br>
      <button class="menu-btn" onclick="showDailyChallengeMenu()" style="background:linear-gradient(135deg,#FFD700,#FFA500);color:#1a1a2e;">‚≠ê DAILY CHALLENGE</button><br>
      ${tutorialState.practiceUnlocked ? '<button class="menu-btn" onclick="showPracticeMode()" style="background:linear-gradient(135deg,#00cc66,#008844);">üéì PRACTICE MODE</button><br>' : ''}
      <button class="menu-btn secondary" onclick="showLeaderboard()">LEADERBOARD</button>
      <button class="menu-btn secondary" onclick="showAchievements()">üèÜ ACHIEVEMENTS</button>
      <button class="menu-btn secondary" onclick="showStats()">üìä STATISTICS</button>
      <button class="menu-btn secondary" onclick="showHelpMenu()">üìñ HELP</button>
      <div style="margin-top:24px;color:#666;font-size:12px;">WASD/Arrows/TFGH/IJKL to move | Deliver OKRs to Jrod's HQ</div>
    </div>
  `;
}

function showModeSelect() {
  gameState = 'modeSelect';
  overlay.innerHTML = `
    <button class="back-btn" onclick="showTitle()">< Back</button>
    <div style="text-align:center;">
      <div style="font-size:24px;font-weight:bold;margin-bottom:4px;">Select Game Mode</div>
      <div style="color:#aaa;font-size:13px;margin-bottom:24px;">Choose number of players</div>
      <button class="menu-btn" onclick="selectMode(1)">SINGLE PLAYER</button><br>
      <button class="menu-btn" onclick="selectMode(2)">LOCAL 2-PLAYER</button><br>
      <button class="menu-btn" onclick="selectMode(3)">LOCAL 3-PLAYER</button><br>
      <button class="menu-btn" onclick="selectMode(4)">LOCAL 4-PLAYER</button>
      <div style="margin-top:24px;color:#999;font-size:11px;max-width:400px;">
        <div style="margin-bottom:8px;"><strong>Controls:</strong></div>
        <div>Player 1: WASD</div>
        <div>Player 2: Arrow Keys</div>
        <div>Player 3: TFGH</div>
        <div>Player 4: IJKL</div>
      </div>
    </div>
  `;
}

function selectMode(mode) {
  gameMode = mode;
  showCharSelect();
}

function showCharSelect() {
  gameState = 'charSelect';
  loadSkillData(); // Load skill data when entering char select
  const modeText = gameMode === 1 ? 'Single Player' : `${gameMode}-Player Local`;
  overlay.innerHTML = `
    <button class="back-btn" onclick="showModeSelect()">< Back</button>
    <div style="text-align:center;">
      <div style="font-size:24px;font-weight:bold;margin-bottom:4px;">Choose Your Character (${modeText})</div>
      <div style="color:#aaa;font-size:13px;margin-bottom:4px;">Each team member has unique abilities</div>
      <div style="color:#FFD700;font-size:14px;margin-bottom:16px;">üíé Skill Points: ${skillPoints}</div>
      <div class="char-grid" id="char-grid"></div>
      <input class="name-input" id="player-name-input" type="text" placeholder="Enter Your Name" maxlength="20" value="${playerName}">
      <br>
      <div style="margin-top:12px;color:#aaa;font-size:11px;">Optional: Custom Seed for Map Generation</div>
      <input class="name-input" id="custom-seed-input" type="text" placeholder="Leave blank for daily map" maxlength="10" style="font-size:14px;width:200px;margin-top:4px;">
      <div style="color:#666;font-size:9px;margin-top:4px;">Share seeds with friends for identical maps!</div>
      <br>
      <button class="menu-btn" id="start-btn" style="opacity:0.5;pointer-events:none;" onclick="startGame()">START DELIVERY</button>
    </div>
  `;

  const grid = document.getElementById('char-grid');
  CHARACTERS.forEach((c, i) => {
    const card = document.createElement('div');
    card.className = 'char-card';
    
    // Count unlocked skills for this character
    const charSkills = getCharacterSkills(c.id);
    const skillCount = charSkills.length;
    const totalSkills = Object.values(SKILL_BRANCHES).reduce((sum, branch) => sum + branch.tiers.length, 0);
    
    card.innerHTML = `
      <canvas width="48" height="48" id="char-preview-${i}" style="margin:0 auto;display:block;image-rendering:pixelated;"></canvas>
      <div class="char-name" style="color:${c.color}">${c.name}</div>
      <div class="char-desc">${c.desc}</div>
      <div class="char-stat">
        <span>Speed</span>
        <div class="stat-bar"><div class="stat-fill speed" style="width:${c.speed*20}%"></div></div>
      </div>
      <div class="char-stat">
        <span>Capacity</span>
        <div class="stat-bar"><div class="stat-fill capacity" style="width:${c.capacity*20}%"></div></div>
      </div>
      <div style="margin-top:8px;font-size:11px;color:#9370DB;">
        ‚≠ê ${skillCount}/${totalSkills} Skills
        <button class="skill-tree-btn" onclick="showSkillTree('${c.id}')" style="margin-left:4px;padding:4px 8px;font-size:11px;">Skills</button>
      </div>
    `;
    card.addEventListener('click', () => {
      document.querySelectorAll('.char-card').forEach(cc => cc.classList.remove('selected'));
      card.classList.add('selected');
      selectedChar = c;
      document.getElementById('start-btn').style.opacity='1';
      document.getElementById('start-btn').style.pointerEvents='auto';
    });
    grid.appendChild(card);

    // Draw small character preview
    setTimeout(() => {
      const pc = document.getElementById(`char-preview-${i}`);
      if(pc) {
        const pctx = pc.getContext('2d');
        drawCharacterSprite(pctx, 24, 24, c, 0, 1.5);
      }
    }, 0);
  });
}

function showLeaderboard() {
  gameState = 'leaderboard';
  const scores = getScores();
  overlay.innerHTML = `
    <button class="back-btn" onclick="showTitle()">< Back</button>
    <div style="text-align:center;">
      <div style="font-size:24px;font-weight:bold;margin-bottom:16px;color:#FFD700;">Leaderboard</div>
      <div class="leaderboard-table">
        <div class="lb-row header">
          <span style="width:30px">#</span>
          <span style="flex:1;text-align:left;">Player</span>
          <span style="width:80px;">Character</span>
          <span style="width:80px;">Tokens</span>
          <span style="width:60px;">Level</span>
        </div>
        ${scores.length===0 ? '<div style="color:#666;padding:20px;">No scores yet!</div>' : ''}
        ${scores.map((s,i) => `
          <div class="lb-row">
            <span style="width:30px;color:#FFD700;">${i+1}</span>
            <span style="flex:1;text-align:left;">${escHtml(s.name)}</span>
            <span style="width:80px;font-size:11px;">${escHtml(s.character)}</span>
            <span style="width:80px;color:#E21A2C;">${Math.floor(s.tokens).toLocaleString()}</span>
            <span style="width:60px;">${s.level}</span>
          </div>
        `).join('')}
      </div>
    </div>
  `;
}

function showSkillTree(charId) {
  gameState = 'skillTree';
  const char = CHARACTERS.find(c => c.id === charId);
  if(!char) return;
  
  overlay.innerHTML = `
    <button class="back-btn" onclick="showCharSelect()">< Back</button>
    <div style="text-align:center;">
      <div style="font-size:24px;font-weight:bold;margin-bottom:4px;color:${char.color};">${char.name} - Skill Tree</div>
      <div style="color:#FFD700;font-size:18px;margin-bottom:16px;">üíé Skill Points: <span id="sp-display">${skillPoints}</span></div>
      <div class="skill-tree-container" id="skill-tree-container"></div>
      <button class="menu-btn reset-skills-btn" onclick="confirmResetSkills('${charId}')">RESET SKILLS (50% REFUND)</button>
    </div>
  `;
  
  const container = document.getElementById('skill-tree-container');
  
  for(const branchKey in SKILL_BRANCHES) {
    const branch = SKILL_BRANCHES[branchKey];
    const branchDiv = document.createElement('div');
    branchDiv.className = `skill-branch ${branchKey}`;
    branchDiv.innerHTML = `
      <div class="skill-branch-title">
        <span style="font-size:24px;">${branch.icon}</span>
        <span style="color:${branch.color};">${branch.name}</span>
      </div>
      <div class="skill-branch-desc">${branch.desc}</div>
      <div id="branch-${branchKey}"></div>
    `;
    container.appendChild(branchDiv);
    
    const branchTiers = document.getElementById(`branch-${branchKey}`);
    branch.tiers.forEach((skill, tierIndex) => {
      const isUnlocked = hasSkill(charId, skill.id);
      const canUnlock = canUnlockSkill(charId, branchKey, tierIndex);
      const canAfford = skillPoints >= skill.cost;
      
      const tierDiv = document.createElement('div');
      tierDiv.className = `skill-tier ${isUnlocked ? 'unlocked' : (canUnlock ? 'available' : 'locked')}`;
      tierDiv.innerHTML = `
        <div class="skill-icon ${isUnlocked ? 'unlocked' : ''}">${skill.icon}</div>
        <div class="skill-info">
          <div class="skill-name">Tier ${tierIndex + 1}: ${skill.name}</div>
          <div class="skill-desc">${skill.desc}</div>
        </div>
        <div class="skill-cost ${isUnlocked ? 'unlocked' : (canAfford ? '' : 'cant-afford')}" 
             onclick="${isUnlocked ? '' : `unlockSkillUI('${charId}', '${branchKey}', ${tierIndex})`}">
          ${isUnlocked ? '‚úì UNLOCKED' : `${skill.cost} SP`}
        </div>
      `;
      branchTiers.appendChild(tierDiv);
    });
  }
}

function unlockSkillUI(charId, branchKey, tierIndex) {
  if(unlockSkill(charId, branchKey, tierIndex)) {
    showSkillTree(charId); // Refresh UI
  }
}

function confirmResetSkills(charId) {
  const confirmed = confirm('Reset all skills for this character? You will receive 50% of spent skill points back.');
  if(confirmed) {
    resetSkills(charId);
    showSkillTree(charId); // Refresh UI
  }
}

function showLevelComplete() {
  gameState = 'levelComplete';
  gameRunning = false;
  overlay.style.display = 'flex';
  
  // Mark challenge as level complete
  if (dailyChallengeActive) {
    challengeProgress.levelComplete = true;
    updateDailyChallengeProgress();
  }
  
  // Calculate skill points earned
  skillPointsEarnedThisRun = calculateSkillPointsEarned(totalDelivered, currentLevel);
  skillPoints += skillPointsEarnedThisRun;
  saveSkillData();
  
  const quote = JROD_QUOTES[Math.floor(Math.random()*JROD_QUOTES.length)];
  overlay.innerHTML = `
    <div class="level-complete-box">
      <div class="lc-title">Level ${currentLevel} Complete!</div>
      <div class="lc-stat">OKRs Delivered: ${deliveredOKRs}</div>
      <div class="lc-stat">Tokens Used: <span style="color:#E21A2C;">${Math.floor(tokens).toLocaleString()}</span></div>
      <div class="lc-stat">Time: ${formatTime(elapsedTime)}</div>
      ${skillPointsEarnedThisRun > 0 ? `<div class="sp-earned">+${skillPointsEarnedThisRun} Skill Points! üíé</div>` : ''}
      <div class="lc-quote">"${quote}" - Jrod</div>
      <button class="menu-btn" onclick="nextLevel()">NEXT LEVEL</button>
    </div>
  `;
}

function showGameOver() {
  gameState = 'gameOver';
  gameRunning = false;
  overlay.style.display = 'flex';

  const shareText = `\u{1F355} TEAM DOMINOS \u{1F355}\n\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\nPlayer: ${playerName} as ${selectedChar.name}\nOKRs Delivered: ${totalDelivered}\nTokens Used: ${Math.floor(tokens).toLocaleString()}\nTime: ${formatTime(elapsedTime)}\nLevel Reached: ${currentLevel}\n\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\nCan you beat my score?\nhttps://simonbourdages.github.io/team-dominos/`;

  overlay.innerHTML = `
    <div class="level-complete-box" style="max-width:460px;">
      <div class="lc-title" style="font-size:32px;">Game Complete!</div>
      <div style="font-size:40px;margin:8px 0;">\u{1F355}\u{1F3C6}\u{1F355}</div>
      <div class="lc-stat">Player: ${escHtml(playerName)} as ${selectedChar.name}</div>
      <div class="lc-stat">Total OKRs Delivered: ${totalDelivered}</div>
      <div class="lc-stat">Total Tokens: <span style="color:#E21A2C;font-size:22px;">${Math.floor(tokens).toLocaleString()}</span></div>
      <div class="lc-stat">Time: ${formatTime(elapsedTime)}</div>
      <div class="lc-stat">Level Reached: ${currentLevel}</div>
      <div class="share-text" id="share-text">${escHtml(shareText)}</div>
      <button class="menu-btn" onclick="copyShare()" id="share-btn">COPY & SHARE</button>
      <div class="copied-msg" id="copied-msg" style="display:none;">Copied to clipboard!</div>
      <br>
      <button class="menu-btn secondary" onclick="showTitle()">PLAY AGAIN</button>
    </div>
  `;

  saveScore({
    name: playerName,
    character: selectedChar.name,
    tokens: Math.floor(tokens),
    level: currentLevel,
    delivered: totalDelivered,
    time: elapsedTime
  });
}

function copyShare() {
  const text = document.getElementById('share-text').textContent;
  navigator.clipboard.writeText(text).then(() => {
    document.getElementById('copied-msg').style.display = 'block';
    document.getElementById('share-btn').textContent = 'COPIED!';
  }).catch(() => {
    // Fallback
    const ta = document.createElement('textarea');
    ta.value = text;
    document.body.appendChild(ta);
    ta.select();
    document.execCommand('copy');
    document.body.removeChild(ta);
    document.getElementById('copied-msg').style.display = 'block';
  });
}

// ============================================================
// SCORE PERSISTENCE
// ============================================================
// SKILL TREE SYSTEM FUNCTIONS
// ============================================================
function getSkillData() {
  try {
    const data = JSON.parse(localStorage.getItem('teamDominosSkills') || '{}');
    return {
      skillPoints: data.skillPoints || 0,
      unlockedSkills: data.unlockedSkills || {}
    };
  } catch(e) { return { skillPoints: 0, unlockedSkills: {} }; }
}

function saveSkillData() {
  const data = {
    skillPoints: skillPoints,
    unlockedSkills: unlockedSkills
  };
  localStorage.setItem('teamDominosSkills', JSON.stringify(data));
}

function loadSkillData() {
  const data = getSkillData();
  skillPoints = data.skillPoints;
  unlockedSkills = data.unlockedSkills;
}

function getCharacterSkills(charId) {
  if(!unlockedSkills[charId]) unlockedSkills[charId] = [];
  return unlockedSkills[charId];
}

function hasSkill(charId, skillId) {
  return getCharacterSkills(charId).includes(skillId);
}

function canUnlockSkill(charId, branchKey, tierIndex) {
  const branch = SKILL_BRANCHES[branchKey];
  const skill = branch.tiers[tierIndex];
  
  // Check if already unlocked
  if(hasSkill(charId, skill.id)) return false;
  
  // Check if can afford
  if(skillPoints < skill.cost) return false;
  
  // Check if previous tier is unlocked (except tier 0)
  if(tierIndex > 0) {
    const prevSkill = branch.tiers[tierIndex - 1];
    if(!hasSkill(charId, prevSkill.id)) return false;
  }
  
  return true;
}

function unlockSkill(charId, branchKey, tierIndex) {
  const branch = SKILL_BRANCHES[branchKey];
  const skill = branch.tiers[tierIndex];
  
  if(!canUnlockSkill(charId, branchKey, tierIndex)) return false;
  
  skillPoints -= skill.cost;
  getCharacterSkills(charId).push(skill.id);
  saveSkillData();
  
  showQuote(`Unlocked: ${skill.name}!`);
  return true;
}

function resetSkills(charId) {
  const charSkills = getCharacterSkills(charId);
  let refund = 0;
  
  // Calculate 50% refund
  for(const branchKey in SKILL_BRANCHES) {
    const branch = SKILL_BRANCHES[branchKey];
    for(const skill of branch.tiers) {
      if(hasSkill(charId, skill.id)) {
        refund += Math.floor(skill.cost * 0.5);
      }
    }
  }
  
  skillPoints += refund;
  unlockedSkills[charId] = [];
  saveSkillData();
  
  showQuote(`Skills reset! Refunded ${refund} SP`);
}

function getAppliedSkillEffects(charId) {
  const effects = {
    speedMult: 1,
    sprintMult: 1,
    dashCooldown: 1,
    speedAura: false,
    capacityBonus: 0,
    pickupRadius: 1,
    autoCollect: false,
    maxHits: 0,
    shieldRegen: false,
    invulnTime: 0,
    startingShield: 0
  };
  
  for(const branchKey in SKILL_BRANCHES) {
    const branch = SKILL_BRANCHES[branchKey];
    for(const skill of branch.tiers) {
      if(hasSkill(charId, skill.id)) {
        for(const key in skill.effect) {
          const value = skill.effect[key];
          if(typeof value === 'boolean') {
            effects[key] = value;
          } else if(key === 'capacityBonus' || key === 'maxHits') {
            effects[key] += value;
          } else if(key.includes('Mult') || key === 'pickupRadius') {
            effects[key] *= value;
          } else {
            effects[key] = Math.max(effects[key], value);
          }
        }
      }
    }
  }
  
  return effects;
}

function calculateSkillPointsEarned(deliveries, levelReached) {
  let points = 0;
  points += deliveries; // 1 SP per delivery
  points += Math.floor(levelReached / 2) * 5; // Bonus per 2 levels
  if(levelReached >= 5) points += 10; // Level 5 bonus
  if(levelReached >= 10) points += 20; // Level 10 bonus
  return points;
}

// ============================================================
function getScores() {
  try { return JSON.parse(localStorage.getItem('teamDominosScores')||'[]'); } catch(e) { return []; }
}

function saveScore(score) {
  const scores = getScores();
  scores.push(score);
  scores.sort((a,b) => a.tokens - b.tokens); // Lower is better
  localStorage.setItem('teamDominosScores', JSON.stringify(scores.slice(0,10)));
}

function escHtml(s) {
  return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;');
}

function formatTime(s) {
  const m = Math.floor(s/60);
  const sec = Math.floor(s%60);
  return `${m}:${sec.toString().padStart(2,'0')}`;
}

// ============================================================
// DAILY CHALLENGE SYSTEM
// ============================================================
function getDailySeed() {
  const now = new Date();
  const utc = Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate());
  return Math.floor(utc / 86400000); // Days since epoch
}

function seedRandom(seed) {
  const x = Math.sin(seed++) * 10000;
  return x - Math.floor(x);
}

function generateDailyChallenge() {
  const seed = getDailySeed();
  const challengeTypes = Object.keys(CHALLENGE_TYPES);
  const typeIndex = Math.floor(seedRandom(seed) * challengeTypes.length);
  const type = challengeTypes[typeIndex];
  const definition = CHALLENGE_TYPES[type];
  
  const challenge = {
    date: new Date().toISOString().split('T')[0],
    seed: seed,
    type: type,
    name: definition.name,
    icon: definition.icon,
    color: definition.color,
    params: definition.generate(seed)
  };
  
  // Generate description from template
  challenge.description = definition.desc.replace(/\{(\w+)\}/g, (_, key) => challenge.params[key]);
  
  return challenge;
}

function getDailyChallengeData() {
  try {
    const data = JSON.parse(localStorage.getItem('teamDominosDailyChallenge') || '{}');
    return data;
  } catch(e) {
    return {};
  }
}

function saveDailyChallengeData(data) {
  localStorage.setItem('teamDominosDailyChallenge', JSON.stringify(data));
}

function getTodaysChallenge() {
  const today = new Date().toISOString().split('T')[0];
  const data = getDailyChallengeData();
  
  // Generate new challenge if needed
  if (!data.lastChallenge || data.lastChallenge.date !== today) {
    data.lastChallenge = generateDailyChallenge();
    data.completedToday = false;
    saveDailyChallengeData(data);
  }
  
  return data.lastChallenge;
}

function getDailyChallengeStreak() {
  const data = getDailyChallengeData();
  return data.streak || 0;
}

function startDailyChallenge() {
  dailyChallengeActive = true;
  currentChallenge = getTodaysChallenge();
  dailyChallengeStreak = getDailyChallengeStreak();
  dailyChallengeData = getDailyChallengeData();
  
  // Initialize progress tracking
  challengeProgress = {
    deliveries: 0,
    powerupsCollected: 0,
    tokensUsed: 0,
    time: 0,
    damageTaken: 0,
    levelComplete: false,
    died: false,
    current: 0,
    required: 0,
    completed: false
  };
  
  // Set required based on challenge type
  const def = CHALLENGE_TYPES[currentChallenge.type];
  if (currentChallenge.type === 'speedRun') {
    challengeProgress.required = currentChallenge.params.target;
  } else if (currentChallenge.type === 'collector') {
    challengeProgress.required = currentChallenge.params.target;
  } else if (currentChallenge.type === 'efficiency') {
    challengeProgress.required = currentChallenge.params.target;
  } else if (currentChallenge.type === 'marathon') {
    challengeProgress.required = currentChallenge.params.target;
  }
  
  updateDailyChallengeHUD();
  showStreakBadge();
}

function updateDailyChallengeProgress() {
  if (!dailyChallengeActive || challengeProgress.completed) return;
  
  // Update progress based on challenge type
  const type = currentChallenge.type;
  
  if (type === 'speedRun') {
    challengeProgress.current = deliveredOKRs;
    challengeProgress.time = elapsedTime;
  } else if (type === 'collector') {
    challengeProgress.current = challengeProgress.powerupsCollected;
  } else if (type === 'efficiency') {
    challengeProgress.current = deliveredOKRs;
    challengeProgress.tokensUsed = tokens;
  } else if (type === 'survivor') {
    challengeProgress.time = elapsedTime;
  } else if (type === 'marathon') {
    challengeProgress.current = deliveredOKRs;
  } else if (type === 'perfectRun') {
    challengeProgress.levelComplete = (gameState === 'levelComplete');
  }
  
  // Check if challenge is complete
  const def = CHALLENGE_TYPES[type];
  if (def.check(challengeProgress, currentChallenge.params)) {
    completeDailyChallenge();
  }
  
  updateDailyChallengeHUD();
}

function completeDailyChallenge() {
  if (challengeProgress.completed) return;
  
  challengeProgress.completed = true;
  const data = getDailyChallengeData();
  
  // Check if already completed today
  if (data.completedToday) return;
  
  // Update streak
  const yesterday = new Date();
  yesterday.setDate(yesterday.getDate() - 1);
  const yesterdayStr = yesterday.toISOString().split('T')[0];
  
  if (data.lastCompletedDate === yesterdayStr) {
    data.streak = (data.streak || 0) + 1;
  } else if (data.lastCompletedDate !== new Date().toISOString().split('T')[0]) {
    data.streak = 1;
  }
  
  data.lastCompletedDate = new Date().toISOString().split('T')[0];
  data.completedToday = true;
  saveDailyChallengeData(data);
  
  // Calculate reward
  const streak = data.streak;
  let reward = STREAK_REWARDS[1]; // Base reward
  for (let days in STREAK_REWARDS) {
    if (streak >= parseInt(days)) {
      reward = STREAK_REWARDS[days];
    }
  }
  
  // Award tokens
  tokens += reward;
  
  // Show celebration
  showChallengeComplete(reward, streak);
  
  // Check for milestone
  if (MILESTONE_STREAKS.includes(streak)) {
    setTimeout(() => showMilestoneCelebration(streak), 2000);
  }
  
  // Save to daily challenge leaderboard
  saveDailyChallengeScore({
    name: playerName,
    character: selectedChar.name,
    time: elapsedTime,
    date: data.lastCompletedDate,
    challenge: currentChallenge.name,
    streak: streak
  });
}

function showChallengeComplete(reward, streak) {
  const popup = document.getElementById('challenge-complete-popup');
  popup.innerHTML = `
    <div>üéâ CHALLENGE COMPLETE! üéâ</div>
    <div class="challenge-reward">+${reward.toLocaleString()} Tokens</div>
    <div style="font-size:16px;">Streak: ${streak} Day${streak > 1 ? 's' : ''}! üî•</div>
  `;
  popup.style.opacity = '1';
  
  setTimeout(() => {
    popup.style.opacity = '0';
  }, 3000);
}

function showMilestoneCelebration(streak) {
  const celebration = document.getElementById('milestone-celebration');
  celebration.style.display = 'block';
  
  // Create confetti explosion
  for (let i = 0; i < 100; i++) {
    const confetti = document.createElement('div');
    confetti.style.position = 'absolute';
    confetti.style.left = '50%';
    confetti.style.top = '50%';
    confetti.style.width = '10px';
    confetti.style.height = '10px';
    confetti.style.backgroundColor = ['#FFD700', '#E21A2C', '#006491', '#00FF00'][i % 4];
    confetti.style.transform = `translate(-50%, -50%)`;
    celebration.appendChild(confetti);
    
    const angle = (i / 100) * Math.PI * 2;
    const velocity = 200 + Math.random() * 200;
    const vx = Math.cos(angle) * velocity;
    const vy = Math.sin(angle) * velocity;
    
    let x = window.innerWidth / 2;
    let y = window.innerHeight / 2;
    let life = 2000;
    
    const animate = () => {
      x += vx * 0.016;
      y += vy * 0.016 + life * 0.0001;
      life -= 16;
      
      if (life > 0) {
        confetti.style.left = x + 'px';
        confetti.style.top = y + 'px';
        confetti.style.opacity = life / 2000;
        requestAnimationFrame(animate);
      } else {
        confetti.remove();
      }
    };
    animate();
  }
  
  // Show milestone message
  const msg = document.createElement('div');
  msg.style.position = 'absolute';
  msg.style.top = '40%';
  msg.style.left = '50%';
  msg.style.transform = 'translate(-50%, -50%)';
  msg.style.fontSize = '48px';
  msg.style.fontWeight = 'bold';
  msg.style.color = '#FFD700';
  msg.style.textShadow = '4px 4px 8px rgba(0,0,0,0.8)';
  msg.style.zIndex = '50';
  msg.textContent = `${streak} DAY STREAK! üèÜ`;
  celebration.appendChild(msg);
  
  setTimeout(() => {
    celebration.style.display = 'none';
    celebration.innerHTML = '';
  }, 4000);
}

function updateDailyChallengeHUD() {
  if (!dailyChallengeActive) return;
  
  const hud = document.getElementById('daily-challenge-hud');
  const type = currentChallenge.type;
  let progressText = '';
  
  if (type === 'speedRun') {
    progressText = `${challengeProgress.current}/${challengeProgress.required} OKRs in ${Math.floor(challengeProgress.time)}/${currentChallenge.params.time}s`;
  } else if (type === 'collector') {
    progressText = `${challengeProgress.current}/${challengeProgress.required} Power-ups`;
  } else if (type === 'efficiency') {
    progressText = `${challengeProgress.current}/${challengeProgress.required} OKRs | ${Math.floor(challengeProgress.tokensUsed)}/${currentChallenge.params.maxTokens} Tokens`;
  } else if (type === 'survivor') {
    progressText = `${Math.floor(challengeProgress.time)}/${currentChallenge.params.time}s`;
  } else if (type === 'marathon') {
    progressText = `${challengeProgress.current}/${challengeProgress.required} Deliveries`;
  } else if (type === 'perfectRun') {
    progressText = `Damage: ${challengeProgress.damageTaken} | Level Complete: ${challengeProgress.levelComplete ? 'Yes' : 'No'}`;
  }
  
  hud.innerHTML = `
    <div class="dc-title">${currentChallenge.icon} ${currentChallenge.name}</div>
    <div class="dc-desc">${currentChallenge.description}</div>
    <div class="dc-progress">${progressText}</div>
  `;
  hud.style.display = 'block';
}

function showStreakBadge() {
  const badge = document.getElementById('streak-badge');
  const streak = getDailyChallengeStreak();
  badge.innerHTML = `<span class="fire">üî•</span> ${streak} Day Streak`;
  badge.style.display = 'block';
}

function getDailyChallengeScores() {
  try {
    return JSON.parse(localStorage.getItem('teamDominosDailyChallengeScores') || '[]');
  } catch(e) {
    return [];
  }
}

function saveDailyChallengeScore(score) {
  const scores = getDailyChallengeScores();
  scores.push(score);
  scores.sort((a,b) => a.time - b.time); // Faster is better
  localStorage.setItem('teamDominosDailyChallengeScores', JSON.stringify(scores.slice(0,20)));
}

function showDailyChallengeMenu() {
  gameState = 'dailyChallenge';
  const challenge = getTodaysChallenge();
  const data = getDailyChallengeData();
  const completed = data.completedToday || false;
  const streak = data.streak || 0;
  
  overlay.style.display = 'flex';
  overlay.innerHTML = `
    <button class="back-btn" onclick="showTitle()">< Back</button>
    <div style="text-align:center;">
      <div style="font-size:28px;font-weight:bold;margin-bottom:8px;color:#FFD700;">Daily Challenge</div>
      <div style="color:#aaa;font-size:13px;margin-bottom:16px;">Complete today's challenge to build your streak!</div>
      
      <div class="challenge-info-box">
        <div class="challenge-type-badge">${challenge.icon} ${challenge.name}</div>
        <div style="font-size:18px;margin:12px 0;color:#fff;">${challenge.description}</div>
        <div style="font-size:13px;color:#aaa;margin-top:8px;">
          ${completed ? '‚úÖ Completed Today!' : '‚è≥ Not Yet Completed'}
        </div>
      </div>
      
      <div style="display:flex;gap:16px;justify-content:center;margin:20px 0;">
        <div class="stat-box">
          <div class="stat-value">${streak}</div>
          <div class="stat-label">Current Streak</div>
        </div>
        <div class="stat-box">
          <div class="stat-value">${STREAK_REWARDS[Math.min(streak + 1, 100)] || STREAK_REWARDS[1]}</div>
          <div class="stat-label">Next Reward</div>
        </div>
      </div>
      
      <button class="menu-btn" onclick="startDailyChallengeGame()" ${completed ? 'style="opacity:0.5;"' : ''}>
        ${completed ? 'PLAY AGAIN (No Rewards)' : 'START CHALLENGE'}
      </button><br>
      <button class="menu-btn secondary" onclick="showDailyChallengeLeaderboard()">VIEW LEADERBOARD</button>
    </div>
  `;
}

function startDailyChallengeGame() {
  gameMode = 1;
  showCharSelect();
  // Set flag to start challenge after character selection
  window.startingDailyChallenge = true;
}

function showDailyChallengeLeaderboard() {
  const scores = getDailyChallengeScores();
  overlay.innerHTML = `
    <button class="back-btn" onclick="showDailyChallengeMenu()">< Back</button>
    <div style="text-align:center;">
      <div style="font-size:24px;font-weight:bold;margin-bottom:16px;color:#FFD700;">Daily Challenge Leaderboard</div>
      <div class="leaderboard-table">
        <div class="lb-row header">
          <span style="width:30px">#</span>
          <span style="flex:1;text-align:left;">Player</span>
          <span style="width:100px;">Challenge</span>
          <span style="width:80px;">Time</span>
          <span style="width:60px;">Streak</span>
        </div>
        ${scores.length===0 ? '<div style="color:#666;padding:20px;">No scores yet!</div>' : ''}
        ${scores.map((s,i) => `
          <div class="lb-row">
            <span style="width:30px;color:#FFD700;">${i+1}</span>
            <span style="flex:1;text-align:left;">${escHtml(s.name)}</span>
            <span style="width:100px;font-size:10px;">${escHtml(s.challenge)}</span>
            <span style="width:80px;color:#00cc66;">${formatTime(s.time)}</span>
            <span style="width:60px;">üî• ${s.streak}</span>
          </div>
        `).join('')}
      </div>
    </div>
  `;
}


// ============================================================
// GAME START / LEVEL
// ============================================================
function startGame() {
  playerName = document.getElementById('player-name-input')?.value.trim() || 'Anonymous';
  if(!selectedChar) return;

  tokens = 0;
  totalDelivered = 0;
  elapsedTime = 0;
  currentLevel = 1;
  activePowerups = {};
  
  // Reset combo stats for new game
  comboStats = {
    nearMisses: 0,
    speedDeliveries: 0,
    perfectPickups: 0,
    chainDeliveries: 0,
    riskyMoves: 0,
    maxCombo: 1.0,
    totalComboPoints: 0
  };

  // Check if starting daily challenge
  if (window.startingDailyChallenge) {
    startDailyChallenge();
    window.startingDailyChallenge = false;
  } else {
    dailyChallengeActive = false;
  }

  // Track game start
  trackEvent('game_start');

  // Tutorial check
  tutorialState = getTutorialState();
  if(!tutorialState.completed && !isPracticeMode && !dailyChallengeActive) {
    // Force tutorial on first play
    setTimeout(() => {
      startTutorial();
    }, 1000);
  }

  // Show character tooltip on first selection
  if(!isPracticeMode && tutorialState.runsCompleted < 3 && !dailyChallengeActive) {
    setTimeout(() => {
      showCharacterTooltip(selectedChar);
    }, 500);
  }

  initLevel(1);
}

function nextLevel() {
  currentLevel++;
  if(currentLevel > 5) {
    showGameOver();
    return;
  }
  initLevel(currentLevel);
}

function initLevel(level) {
  mapData = generateMap(level);
  
  // Store map metadata
  currentMapSeed = mapData.seed;
  currentWeather = mapData.weather;
  currentTimeOfDay = mapData.timeOfDay;
  currentTheme = mapData.theme;
  
  // Update map info HUD
  document.getElementById('map-theme').textContent = currentTheme.name;
  document.getElementById('map-weather').textContent = `Weather: ${WEATHER_EFFECTS[currentWeather].name}`;
  document.getElementById('map-time').textContent = `Time: ${TIME_OF_DAY[currentTimeOfDay].name}`;
  document.getElementById('map-seed').textContent = currentMapSeed;
  document.getElementById('map-info-hud').style.display = 'block';
  
  spawnOKRs(level);
  spawnPowerups(level);
  spawnEnemies(level);
  particles = [];
  powerupParticles = [];
  carriedOKRs = 0;
  activePowerups = {};
  powerupTimers = {};
  scopeCreepCooldown = 0;
  powerupPanel.style.display = 'none';
  
  // Reset combo system
  comboMultiplier = 1.0;
  comboTimer = 0;
  lastPickupTime = 0;
  pickupChain = 0;
  deliveryStartTime = 0;
  damageTakenThisDelivery = false;
  floatingTexts = [];
  updateComboUI();

  // Apply skill effects to selected character
  const skillEffects = getAppliedSkillEffects(selectedChar.id);

  // Initialize players based on game mode
  players = [];
  cameras = [];
  
  for (let i = 0; i < gameMode; i++) {
    const spawnOffset = i * 3; // Offset spawn positions for each player
    const px = (mapData.startX + spawnOffset) * TILE + TILE/2;
    const py = (mapData.startY + spawnOffset) * TILE + TILE/2;
    
    players.push({
      id: i,
      x: px,
      y: py,
      vx: 0, vy: 0,
      facing: 0,
      animTimer: 0,
      moving: false,
      baseSpeed: (selectedChar.speed * 40 + 40) * skillEffects.speedMult,
      carriedOKRs: 0,
      deliveredOKRs: 0,
      tokens: 0,
      color: PLAYER_COLORS[i],
      name: PLAYER_NAMES[i],
      activePowerups: {},
      // Skill effects
      maxCapacity: selectedChar.capacity + skillEffects.capacityBonus,
      pickupRadius: skillEffects.pickupRadius,
      autoCollect: skillEffects.autoCollect,
      maxHits: 1 + skillEffects.maxHits,
      currentHits: 0,
      invulnTime: skillEffects.invulnTime,
      invulnTimer: 0,
      shieldRegen: skillEffects.shieldRegen,
      shieldRegenTimer: 0,
      startingShieldTimer: skillEffects.startingShield,
      speedAura: skillEffects.speedAura,
      sprintMult: skillEffects.sprintMult,
      dashCooldownMult: skillEffects.dashCooldown
    });
    
    cameras.push({ x: 0, y: 0 });
  }

  // For single player, keep old player reference for compatibility
  if (gameMode === 1) {
    player = players[0];
    camera = cameras[0];
    tokens = player.tokens;
    carriedOKRs = player.carriedOKRs;
    deliveredOKRs = player.deliveredOKRs;
  }

  gameState = 'playing';
  gameRunning = true;
  overlay.style.display = 'none';
  hud.style.display = 'flex';
  minimapContainer.style.display = 'block';
  lastTime = performance.now();
}

// ============================================================
// UPDATE
// ============================================================
function update(dt) {
  if(!gameRunning) return;

  elapsedTime += dt;

  const hqCenterX = mapData.hqX * TILE + TILE/2;
  const hqCenterY = mapData.hqY * TILE + TILE/2;

  // Update each player
  for (let pidx = 0; pidx < gameMode; pidx++) {
    const p = players[pidx];
    const keyBindings = PLAYER_KEY_BINDINGS[pidx];
    
    p.tokens += TOKEN_PER_SEC * dt;

    // Player input
    let dx = 0, dy = 0;
    if(pidx === 0) { // Player 1 also gets mobile controls
      dx += mobileDir.x;
      dy += mobileDir.y;
    }
    if(keys[keyBindings.left]) dx -= 1;
    if(keys[keyBindings.right]) dx += 1;
    if(keys[keyBindings.up]) dy -= 1;
    if(keys[keyBindings.down]) dy += 1;

    // Normalize diagonal
    if(dx!==0 && dy!==0) { dx *= 0.707; dy *= 0.707; }

    let speed = p.baseSpeed;
    if(p.activePowerups.sprint || p.activePowerups.dash) speed *= 2;
    
    // Apply weather effects
    if(currentWeather) speed *= WEATHER_EFFECTS[currentWeather].speedMod;

    // Check tech debt slow (unless ghost mode)
    const ptile = tileAt(p.x, p.y);
    if(ptile === 6 && !p.activePowerups.shield && !p.activePowerups.ghost) speed *= 0.4;

    p.moving = dx!==0||dy!==0;
    if(p.moving) {
      p.animTimer += dt * 8;
      p.tokens += TOKEN_PER_MOVE * dt * 10;

      if(dy<0) p.facing=3;
      else if(dy>0) p.facing=0;
      if(dx<0) p.facing=1;
      else if(dx>0) p.facing=2;
    }

    // Movement with collision
    const newX = p.x + dx * speed * dt;
    const newY = p.y + dy * speed * dt;
    const r = 6;

    // Check X movement
    if(!isSolid(Math.floor((newX-r)/TILE), Math.floor((p.y-r)/TILE)) &&
       !isSolid(Math.floor((newX+r)/TILE), Math.floor((p.y-r)/TILE)) &&
       !isSolid(Math.floor((newX-r)/TILE), Math.floor((p.y+r)/TILE)) &&
       !isSolid(Math.floor((newX+r)/TILE), Math.floor((p.y+r)/TILE))) {
      p.x = newX;
    }

    // Check Y movement
    if(!isSolid(Math.floor((p.x-r)/TILE), Math.floor((newY-r)/TILE)) &&
       !isSolid(Math.floor((p.x+r)/TILE), Math.floor((newY-r)/TILE)) &&
       !isSolid(Math.floor((p.x-r)/TILE), Math.floor((newY+r)/TILE)) &&
       !isSolid(Math.floor((p.x+r)/TILE), Math.floor((newY+r)/TILE))) {
      p.y = newY;
    }

    // Clamp to map
    p.x = Math.max(r, Math.min(mapData.w*TILE-r, p.x));
    p.y = Math.max(r, Math.min(mapData.h*TILE-r, p.y));

    // Pick up OKRs
    for(let o of okrs) {
      if(o.collected) continue;
      
      // Magnet effect - auto-collect from distance
      const pickupRadius = p.activePowerups.magnet ? TILE * 4 : TILE * 0.8;
      const dist = Math.hypot(p.x-o.x, p.y-o.y);
      
      if(dist < pickupRadius && p.carriedOKRs < selectedChar.capacity) {
        o.collected = true;
        p.carriedOKRs++;
        p.tokens += TOKEN_PER_PICKUP;
        
        // Enhanced pickup feedback
        spawnParticles(o.x, o.y, 25, COLORS.gold, 120, 0.8);
        for (let i = 0; i < 8; i++) {
          const angle = (i / 8) * Math.PI * 2;
          particles.push({
            x: o.x, y: o.y,
            vx: Math.cos(angle) * 80,
            vy: Math.sin(angle) * 80,
            life: 0.5, maxLife: 0.5,
            color: COLORS.gold,
            size: 4,
            active: true
          });
        }
        
        playSound('pickup');
        
        // COMBO: Check for perfect pickup (3+ OKRs within 2 seconds)
        if (gameMode === 1) {
          const now = performance.now() / 1000;
          if (now - lastPickupTime < 2.0) {
            pickupChain++;
            if (pickupChain >= 3) {
              triggerCombo('perfectPickup', o.x, o.y);
              pickupChain = 0;
            }
          } else {
            pickupChain = 1;
          }
          lastPickupTime = now;
          
          // COMBO: Check for risky move
          if (checkRiskyMove(p.x, p.y)) {
            triggerCombo('riskyMove', o.x, o.y);
          }
        }
        
        // Floating text at world position
        if (gameMode === 1) {
          const screenX = o.x - camera.x;
          const screenY = o.y - camera.y;
          if (screenX > 0 && screenX < canvasWidth && screenY > 0 && screenY < canvasHeight) {
            createFloatingText('+' + TOKEN_PER_PICKUP, screenX, screenY, COLORS.gold, 18);
          }
        }
        
        animateHudValue('hud-okrs');
        animateHudValue('hud-tokens');
      }
    }

    // Pick up powerups
    for(let pw of powerups) {
      if(pw.collected) continue;
      
      // Magnet effect - auto-collect from distance
      const magnetRadius = p.activePowerups.magnet ? TILE * 3 : TILE * 0.8;
      const dist = Math.hypot(p.x-pw.x, p.y-pw.y);
      
      if(dist < magnetRadius) {
        pw.collected = true;
        
        // Track powerup collection
        trackEvent('powerup_collected', { type: pw.type.id });
        
        // Enhanced pickup animation
        createBurstParticles(pw.x, pw.y, pw.rarity.color, 30);
        spawnParticles(pw.x, pw.y, 20, pw.type.color, 100, 0.5);
        playPowerupSound(pw.type.rarity);
        
        // Handle stacking and canceling
        const newType = pw.type;
        let shouldActivate = true;
        
        // Check for canceling power-ups
        for(let cancelId of newType.cancelsWith) {
          if(p.activePowerups[cancelId]) {
            delete p.activePowerups[cancelId];
            delete powerupTimers[cancelId];
            showQuote(`${newType.name} replaced ${POWERUP_TYPES.find(t => t.id === cancelId).name}!`);
          }
        }
        
        // Check if already active (refresh timer)
        if(p.activePowerups[newType.id]) {
          showQuote(`${newType.name} refreshed!`);
        } else {
          showQuote(`${newType.name}! ${newType.desc}!`);
        }
        
        // Activate power-up (instant effects)
        if(newType.id === 'teleport') {
          let tx, ty, tries=0;
          do {
            tx = Math.floor(Math.random()*mapData.w);
            ty = Math.floor(Math.random()*mapData.h);
            tries++;
          } while(tries<200 && mapData.grid[ty][tx]!==0);
          p.x = tx*TILE+TILE/2;
          p.y = ty*TILE+TILE/2;
          spawnConfetti(p.x, p.y);
        } else if(newType.duration > 0) {
          // Timed power-ups
          p.activePowerups[newType.id] = newType.duration;
          powerupTimers[newType.id] = { current: newType.duration, max: newType.duration };
        }
        
        // Show power-up tooltip (first time only)
        if(!isPracticeMode && tutorialState.runsCompleted < 3) {
          setTimeout(() => {
            showPowerupTooltip(newType);
          }, 100);
        }
        
        // Track for challenges
        if(dailyChallengeActive) {
          challengeProgress.powerupsCollected++;
        }
      }
    }

    // Update active powerups with warning flash
    for(let key in p.activePowerups) {
      p.activePowerups[key] -= dt;
      if(powerupTimers[key]) {
        powerupTimers[key].current = p.activePowerups[key];
      }
      if(p.activePowerups[key] <= 0) {
        delete p.activePowerups[key];
        delete powerupTimers[key];
      }
    }

    // Deliver OKRs to HQ
    const distToHQ = Math.hypot(p.x-hqCenterX, p.y-hqCenterY);
    if(distToHQ < TILE*2 && p.carriedOKRs > 0) {
      const multiplier = p.activePowerups.multiplier ? 2 : 1;
      const deliveredCount = p.carriedOKRs;
      p.tokens += TOKEN_PER_DELIVERY * deliveredCount * multiplier;
      p.deliveredOKRs += deliveredCount;
      totalDelivered += deliveredCount;
      
      // Track achievement
      trackEvent('okr_delivered', { count: deliveredCount });
      
      spawnConfetti(hqCenterX, hqCenterY);
      if(gameMode === 1) {
        const quote = multiplier > 1 ? 
          `${JROD_QUOTES[Math.floor(Math.random()*JROD_QUOTES.length)]} (2x BONUS!)` :
          JROD_QUOTES[Math.floor(Math.random()*JROD_QUOTES.length)];
        showQuote(quote);
      }
      p.carriedOKRs = 0;
    }

    // Update camera for this player
    cameras[pidx].x = p.x - canvasWidth/(gameMode > 1 ? 2 : 1)/2;
    cameras[pidx].y = p.y - canvasHeight/(gameMode > 2 ? 2 : 1)/2;
    cameras[pidx].x = Math.max(0, Math.min(mapData.w*TILE - canvasWidth/(gameMode > 1 ? 2 : 1), cameras[pidx].x));
    cameras[pidx].y = Math.max(0, Math.min(mapData.h*TILE - canvasHeight/(gameMode > 2 ? 2 : 1), cameras[pidx].y));
  }

  // Bob animation on uncollected OKRs
  for(let o of okrs) {
    if(!o.collected) o.bobPhase += dt * 3;
  }

  // Bob animation on powerups
  for(let p of powerups) {
    if(!p.collected) p.bobPhase += dt * 3;
  }

  // Update enemies
  for(let e of enemies) {
    // Time freeze stops enemy movement
    if(!activePowerups.timefreeze && !activePowerups.timeFreeze) {
      e.changeTimer -= dt;
      if(e.changeTimer <= 0) {
        e.changeTimer = 2 + Math.random()*3;
        e.vx = (Math.random()-0.5) * 80;
        e.vy = (Math.random()-0.5) * 80;
      }
      const nex = e.x + e.vx * dt;
      const ney = e.y + e.vy * dt;
      const etx = Math.floor(nex/TILE);
      const ety = Math.floor(ney/TILE);
      if(etx>=0&&etx<mapData.w&&ety>=0&&ety<mapData.h) {
        const t = mapData.grid[ety][etx];
        if(t===0||t===1||t===6) { e.x=nex; e.y=ney; }
        else { e.vx=-e.vx; e.vy=-e.vy; e.changeTimer=0.1; }
      } else { e.vx=-e.vx; e.vy=-e.vy; }
      e.phase += dt * 2;
    }

    // Collision with players
    for(let p of players) {
      const dist = Math.hypot(p.x-e.x, p.y-e.y);
      
      // COMBO: Check for near miss
      if (gameMode === 1 && dist < TILE * 2 && dist > TILE * 0.7 && !e.nearMissTriggered) {
        e.nearMissTriggered = true;
        triggerCombo('nearMiss', p.x, p.y);
        setTimeout(() => e.nearMissTriggered = false, 1000);
      }
      
      // Update skill-based timers
      if(p.invulnTimer) p.invulnTimer -= dt;
      if(p.startingShieldTimer) p.startingShieldTimer -= dt;
      if(p.shieldRegenTimer) p.shieldRegenTimer -= dt;
      
      // Check if player is invulnerable
      const isInvuln = (p.invulnTimer && p.invulnTimer > 0) || 
                       (p.startingShieldTimer && p.startingShieldTimer > 0) || 
                       p.activePowerups.shield || 
                       p.activePowerups.ghost;
      
      if(!isInvuln) {
        if(dist < TILE*0.7) {
          // Player takes a hit
          p.currentHits = (p.currentHits || 0) + 1;
          
          // Check if player has more hits available
          if(p.currentHits >= (p.maxHits || 1)) {
            requiredDeliveries++;
            showQuote('Scope Creep! +1 OKR required!');
            p.currentHits = 0; // Reset hits
          } else {
            showQuote(`Hit! ${p.maxHits - p.currentHits} lives left!`);
          }
          
          // Apply invulnerability period from skills
          if(p.invulnTime && p.invulnTime > 0) {
            p.invulnTimer = p.invulnTime;
          }
          
          shakeTimer = 0.3;
          shakeIntensity = 6;
          spawnParticles(p.x, p.y, 20, '#FF0000', 120, 0.4);
          const angle = Math.atan2(e.y-p.y, e.x-p.x);
          e.x += Math.cos(angle)*TILE*2;
          e.y += Math.sin(angle)*TILE*2;
          e.changeTimer = 0.5;
          
          // Track damage for daily challenge
          if (dailyChallengeActive) {
            challengeProgress.damageTaken++;
          }
          
          // Record death location for adaptive difficulty
          if (currentMapSeed && mapData.placedChunks) {
            const chunkX = Math.floor(p.x / (20 * TILE));
            const chunkY = Math.floor(p.y / (20 * TILE));
            const chunkKey = `${chunkX}_${chunkY}_${currentMapSeed}`;
            recordDeath(chunkKey);
          }
          
          // COMBO: Break combo on damage
          if (gameMode === 1) {
            damageTakenThisDelivery = true;
            breakCombo();
          }
        }
      }
    }
  }

  // Update particles
  for(let i=particles.length-1; i>=0; i--) {
    const p = particles[i];
    p.x += p.vx * dt;
    p.y += p.vy * dt;
    p.vy += 200 * dt;
    p.life -= dt;
    if(p.life <= 0) {
      ParticlePool.release(p);
      particles.splice(i, 1);
    }
  }
  
  // Update combo timer
  if (gameMode === 1) {
    updateComboTimer(dt);
  }
  
  // Update power-up UI and effects
  updatePowerupUI();
  updateScreenEffect(dt);
  updatePlayerTrail(dt);
  
  // Enhanced visual feedback updates
  if (invulnerabilityTimer > 0) {
    invulnerabilityTimer -= dt;
    invulnFlickerPhase += dt * 20;
  }
  
  // Knockback decay
  if (knockbackVelocity.x !== 0 || knockbackVelocity.y !== 0) {
    knockbackVelocity.x *= 0.9;
    knockbackVelocity.y *= 0.9;
    if (Math.abs(knockbackVelocity.x) < 0.1) knockbackVelocity.x = 0;
    if (Math.abs(knockbackVelocity.y) < 0.1) knockbackVelocity.y = 0;
  }
  
  // Camera zoom lerp
  if (cameraZoom !== cameraZoomTarget) {
    cameraZoom += (cameraZoomTarget - cameraZoom) * 0.1;
    if (Math.abs(cameraZoom - cameraZoomTarget) < 0.01) cameraZoom = cameraZoomTarget;
  }
  
  // Celebration animation decay
  if (celebrationAnimPhase > 0) {
    celebrationAnimPhase -= dt;
    if (celebrationAnimPhase < 0) celebrationAnimPhase = 0;
  }
  
  // Rainbow trail life decay
  for (let i = rainbowTrail.length - 1; i >= 0; i--) {
    rainbowTrail[i].life -= dt * 2;
    if (rainbowTrail[i].life <= 0) rainbowTrail.splice(i, 1);
  }
  
  // Smooth token display
  if (gameMode === 1 && tokens !== tokenDisplayValue) {
    animateTokenCount(tokens);
  }

  // Shake
  if(shakeTimer > 0) shakeTimer -= dt;
  if(scopeCreepCooldown > 0) scopeCreepCooldown -= dt;

  // Quote popup
  if(quoteTimer > 0) {
    quoteTimer -= dt;
    if(quoteTimer <= 0) quotePopup.style.opacity = '0';
  }

  // Tutorial system
  if(tutorialActive) {
    updateTutorial();
  }
  updateTutorialElements();
  
  // Progressive disclosure
  if(!tutorialActive) {
    checkProgressiveDisclosure();
  }

  // For single player, keep compatibility
  if(gameMode === 1) {
    player = players[0];
    camera = cameras[0];
    tokens = player.tokens;
    carriedOKRs = player.carriedOKRs;
    deliveredOKRs = player.deliveredOKRs;
    activePowerups = player.activePowerups;
  }

  // Update daily challenge progress
  if (dailyChallengeActive) {
    updateDailyChallengeProgress();
  }

  // Check level complete
  let totalDeliveredOKRs = players.reduce((sum, p) => sum + p.deliveredOKRs, 0);
  if(totalDeliveredOKRs >= requiredDeliveries) {
    setTimeout(() => showLevelComplete(), 1500);
    gameRunning = false; // Prevent multiple triggers
  }

  // Update HUD for single player or summary for multiplayer
  if(gameMode === 1) {
    document.getElementById('hud-tokens').textContent = Math.floor(tokens).toLocaleString();
    document.getElementById('hud-okrs').textContent = `${carriedOKRs}/${selectedChar.capacity}`;
    document.getElementById('hud-level').textContent = currentLevel;
    document.getElementById('hud-time').textContent = formatTime(elapsedTime);
    document.getElementById('hud-goal').textContent = `${deliveredOKRs}/${requiredDeliveries}`;
  } else {
    // Multiplayer: show total tokens and deliveries
    const totalTokens = players.reduce((sum, p) => sum + p.tokens, 0);
    document.getElementById('hud-tokens').textContent = Math.floor(totalTokens).toLocaleString();
    document.getElementById('hud-okrs').textContent = `Team: ${totalDeliveredOKRs}`;
    document.getElementById('hud-level').textContent = currentLevel;
    document.getElementById('hud-time').textContent = formatTime(elapsedTime);
    document.getElementById('hud-goal').textContent = `${totalDeliveredOKRs}/${requiredDeliveries}`;
  }
}

// ============================================================
// RENDER
// ============================================================  
function render() {
  ctx.clearRect(0, 0, canvasWidth, canvasHeight);
  ctx.fillStyle = '#0d0d1a';
  ctx.fillRect(0, 0, canvasWidth, canvasHeight);

  if(gameState !== 'playing') return;

  if (gameMode === 1) {
    // Single player - full screen
    renderSinglePlayer();
  } else {
    // Multiplayer - split screen
    renderSplitScreen();
  }
}

function renderSinglePlayer() {
  ctx.save();

  // Screen shake
  let shakeX=0, shakeY=0;
  if(shakeTimer > 0) {
    shakeX = (Math.random()-0.5)*shakeIntensity*2;
    shakeY = (Math.random()-0.5)*shakeIntensity*2;
  }
  ctx.translate(-camera.x+shakeX, -camera.y+shakeY);

  // Calculate visible tiles (with culling based on quality)
  const profile = QualitySettings.getProfile();
  const extraTiles = Math.min(1, Math.floor(profile.drawDistance / 20));
  const startTX = Math.max(0, Math.floor(camera.x/TILE)-extraTiles);
  const startTY = Math.max(0, Math.floor(camera.y/TILE)-extraTiles);
  const endTX = Math.min(mapData.w, Math.ceil((camera.x+canvasWidth)/TILE)+extraTiles);
  const endTY = Math.min(mapData.h, Math.ceil((camera.y+canvasHeight)/TILE)+extraTiles);

  // Draw tiles
  for(let y=startTY; y<endTY; y++) {
    for(let x=startTX; x<endTX; x++) {
      const t = mapData.grid[y][x];
      const px = x*TILE, py = y*TILE;

      switch(t) {
        case 0: // road
          ctx.fillStyle = currentTheme ? currentTheme.colors.road : COLORS.road;
          ctx.fillRect(px, py, TILE, TILE);
          // Road markings
          if(y%2===0 && x%7<2) {
            ctx.fillStyle = 'rgba(255,255,255,0.15)';
            ctx.fillRect(px+TILE/2-1, py+2, 2, TILE-4);
          }
          break;
        case 1: // sidewalk
          ctx.fillStyle = COLORS.sidewalk;
          ctx.fillRect(px, py, TILE, TILE);
          ctx.fillStyle = 'rgba(0,0,0,0.1)';
          ctx.fillRect(px, py, TILE, 1);
          ctx.fillRect(px, py, 1, TILE);
          break;
        case 2: // grass
          ctx.fillStyle = currentTheme ? currentTheme.colors.grass : COLORS.grass;
          ctx.fillRect(px, py, TILE, TILE);
          // Grass texture
          ctx.fillStyle = 'rgba(0,0,0,0.08)';
          if((x+y)%3===0) ctx.fillRect(px+8, py+8, 2, 2);
          if((x+y)%5===1) ctx.fillRect(px+20, py+14, 2, 2);
          break;
        case 3: // building
          ctx.fillStyle = currentTheme ? currentTheme.colors.building : COLORS.building;
          ctx.fillRect(px, py, TILE, TILE);
          ctx.fillStyle = COLORS.buildingTop;
          ctx.fillRect(px+1, py+1, TILE-2, TILE-2);
          // Windows
          ctx.fillStyle = 'rgba(255,255,200,0.3)';
          ctx.fillRect(px+4, py+4, 6, 6);
          ctx.fillRect(px+TILE-10, py+4, 6, 6);
          ctx.fillRect(px+4, py+TILE-10, 6, 6);
          ctx.fillRect(px+TILE-10, py+TILE-10, 6, 6);
          break;
        case 4: // HQ
          ctx.fillStyle = COLORS.hq;
          ctx.fillRect(px, py, TILE, TILE);
          ctx.fillStyle = '#FF6B6B';
          ctx.fillRect(px+2, py+2, TILE-4, TILE-4);
          // J logo
          ctx.fillStyle = '#fff';
          ctx.font = 'bold 14px monospace';
          ctx.textAlign = 'center';
          ctx.fillText('J', px+TILE/2, py+TILE/2+5);
          break;
        case 5: // meeting blocker
          ctx.fillStyle = COLORS.meeting;
          ctx.fillRect(px, py, TILE, TILE);
          ctx.fillStyle = '#A0522D';
          ctx.fillRect(px+2, py+2, TILE-4, TILE-4);
          ctx.fillStyle = '#fff';
          ctx.font = '8px monospace';
          ctx.textAlign = 'center';
          ctx.fillText('MTG', px+TILE/2, py+TILE/2+3);
          break;
        case 6: // tech debt
          ctx.fillStyle = COLORS.techDebt;
          ctx.fillRect(px, py, TILE, TILE);
          ctx.fillStyle = 'rgba(100,0,100,0.3)';
          ctx.fillRect(px+2, py+2, TILE-4, TILE-4);
          // Warning stripes
          ctx.strokeStyle = 'rgba(255,0,255,0.2)';
          ctx.lineWidth = 1;
          for(let i=0; i<TILE; i+=6) {
            ctx.beginPath(); ctx.moveTo(px+i, py); ctx.lineTo(px, py+i); ctx.stroke();
          }
          break;
        case 7: // office building
          ctx.fillStyle = '#4a5a6e';
          ctx.fillRect(px, py, TILE, TILE);
          ctx.fillStyle = '#5a6a80';
          ctx.fillRect(px+1, py+1, TILE-2, TILE-2);
          // Lit windows (offices have more light)
          ctx.fillStyle = 'rgba(255,255,150,0.5)';
          ctx.fillRect(px+3, py+3, 8, 6);
          ctx.fillRect(px+TILE-11, py+3, 8, 6);
          ctx.fillRect(px+3, py+TILE-9, 8, 6);
          ctx.fillRect(px+TILE-11, py+TILE-9, 8, 6);
          break;
      }
    }
  }

  // Draw HQ marker (glow)
  const hqPx = mapData.hqX*TILE+TILE/2;
  const hqPy = mapData.hqY*TILE+TILE/2;
  const hqGlow = 0.5 + Math.sin(performance.now()/300)*0.3;
  ctx.beginPath();
  ctx.arc(hqPx, hqPy, TILE*2, 0, Math.PI*2);
  ctx.fillStyle = `rgba(226,26,44,${hqGlow*0.15})`;
  ctx.fill();
  // "JROD HQ" label
  ctx.fillStyle = '#fff';
  ctx.font = 'bold 10px monospace';
  ctx.textAlign = 'center';
  ctx.fillText("JROD'S HQ", hqPx, hqPy - TILE*1.5 - 4);

  // Draw Jrod at HQ
  drawJrod(ctx, hqPx, hqPy - TILE*0.5);

  // Draw OKRs
  for(let o of okrs) {
    if(o.collected) continue;
    const bob = Math.sin(o.bobPhase)*3;
    const ox = o.x, oy = o.y + bob;

    // Glow
    ctx.beginPath();
    ctx.arc(ox, oy, 12, 0, Math.PI*2);
    ctx.fillStyle = 'rgba(255,215,0,0.2)';
    ctx.fill();

    // Pizza box
    ctx.fillStyle = '#D4A44A';
    ctx.fillRect(ox-8, oy-8, 16, 16);
    ctx.fillStyle = '#E8C56A';
    ctx.fillRect(ox-7, oy-7, 14, 14);
    // OKR text
    ctx.fillStyle = '#8B4513';
    ctx.font = 'bold 7px monospace';
    ctx.textAlign = 'center';
    ctx.fillText('OKR', ox, oy+3);

    // Sparkle
    const sp = (performance.now()/200 + o.bobPhase) % (Math.PI*2);
    ctx.fillStyle = `rgba(255,215,0,${0.5+Math.sin(sp)*0.5})`;
    ctx.fillRect(ox-1+Math.cos(sp)*10, oy-1+Math.sin(sp)*6, 2, 2);
  }

  // Draw powerups
  for(let p of powerups) {
    if(p.collected) continue;
    const bob = Math.sin(p.bobPhase)*3;
    const px2 = p.x, py2 = p.y + bob;
    const glowPhase = Math.sin(p.glowPhase) * 0.5 + 0.5;
    
    // Enhanced glow based on rarity
    const rarityGlow = p.rarity.color;
    for(let r = 20; r > 0; r -= 4) {
      ctx.beginPath();
      ctx.arc(px2, py2, r, 0, Math.PI*2);
      ctx.fillStyle = `${p.rarity.glow}${(0.05 * glowPhase * (20 - r) / 20).toFixed(2)})`;
      ctx.fill();
    }
    
    // Outer ring
    ctx.beginPath();
    ctx.arc(px2, py2, 12, 0, Math.PI*2);
    ctx.fillStyle = p.type.color + '30';
    ctx.fill();
    
    // Middle ring
    ctx.beginPath();
    ctx.arc(px2, py2, 9, 0, Math.PI*2);
    ctx.fillStyle = p.type.color + '60';
    ctx.fill();

    // Inner core
    ctx.beginPath();
    ctx.arc(px2, py2, 7, 0, Math.PI*2);
    ctx.fillStyle = p.type.color;
    ctx.fill();
    
    // Rarity indicator border
    ctx.strokeStyle = p.rarity.color;
    ctx.lineWidth = 2;
    ctx.stroke();

    // Icon
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 10px monospace';
    ctx.textAlign = 'center';
    ctx.fillText(p.type.icon, px2, py2+4);
    
    // Rotating particles around power-up
    const time = performance.now() / 1000;
    for(let i = 0; i < 3; i++) {
      const angle = (time + i * (Math.PI * 2 / 3)) * 2;
      const radius = 15 + Math.sin(time * 3 + i) * 3;
      const particleX = px2 + Math.cos(angle) * radius;
      const particleY = py2 + Math.sin(angle) * radius;
      ctx.beginPath();
      ctx.arc(particleX, particleY, 2, 0, Math.PI*2);
      ctx.fillStyle = p.rarity.color;
      ctx.fill();
    }
  }

  // Draw enemies (Scope Creep Monsters)
  for(let e of enemies) {
    const pulse = Math.sin(e.phase)*2;
    const ex = e.x, ey = e.y;

    // Body
    ctx.fillStyle = '#44AA44';
    ctx.beginPath();
    ctx.arc(ex, ey, 10+pulse, 0, Math.PI*2);
    ctx.fill();

    // Eyes
    ctx.fillStyle = '#fff';
    ctx.beginPath();
    ctx.arc(ex-4, ey-3, 3, 0, Math.PI*2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(ex+4, ey-3, 3, 0, Math.PI*2);
    ctx.fill();
    ctx.fillStyle = '#000';
    ctx.beginPath();
    ctx.arc(ex-4, ey-3, 1.5, 0, Math.PI*2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(ex+4, ey-3, 1.5, 0, Math.PI*2);
    ctx.fill();

    // Mouth
    ctx.strokeStyle = '#000';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.arc(ex, ey+3, 4, 0, Math.PI);
    ctx.stroke();

    // Label
    ctx.fillStyle = 'rgba(255,255,255,0.7)';
    ctx.font = '7px monospace';
    ctx.textAlign = 'center';
    ctx.fillText('SCOPE', ex, ey+18);
    ctx.fillText('CREEP', ex, ey+25);
  }

  // Draw player
  drawCharacterSprite(ctx, player.x, player.y-4, selectedChar, player.facing, 1, player.moving, player.animTimer);

  // Draw power-up effect indicators on player
  if(activePowerups.sprint) {
    ctx.strokeStyle = 'rgba(0,255,0,0.4)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(player.x, player.y, 14, 0, Math.PI*2);
    ctx.stroke();
  }
  if(activePowerups.shield) {
    ctx.strokeStyle = 'rgba(0,191,255,0.5)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(player.x, player.y, 16, 0, Math.PI*2);
    ctx.stroke();
    ctx.beginPath();
    ctx.arc(player.x, player.y, 18, 0, Math.PI*2);
    ctx.strokeStyle = 'rgba(0,191,255,0.2)';
    ctx.stroke();
  }

  // Draw carried OKR indicator above player
  if(carriedOKRs > 0) {
    ctx.fillStyle = COLORS.gold;
    ctx.font = 'bold 9px monospace';
    ctx.textAlign = 'center';
    ctx.fillText(`x${carriedOKRs}`, player.x, player.y - 20);
    // Small pizza icon
    ctx.fillStyle = '#D4A44A';
    ctx.fillRect(player.x-14, player.y-28, 10, 10);
    ctx.fillStyle = '#E8C56A';
    ctx.fillRect(player.x-13, player.y-27, 8, 8);
  }

  // Arrow pointing to HQ when far
  if(distToHQ(player.x, player.y) > canvasWidth*0.4) {
    const angle = Math.atan2(hqPy-player.y, hqPx-player.x);
    const arrowDist = 60;
    const ax = player.x + Math.cos(angle)*arrowDist;
    const ay = player.y + Math.sin(angle)*arrowDist;
    ctx.save();
    ctx.translate(ax, ay);
    ctx.rotate(angle);
    ctx.fillStyle = 'rgba(226,26,44,0.6)';
    ctx.beginPath();
    ctx.moveTo(8, 0);
    ctx.lineTo(-4, -5);
    ctx.lineTo(-4, 5);
    ctx.closePath();
    ctx.fill();
    ctx.restore();
  }

  // Draw particles
  for(let p of particles) {
    const alpha = p.life / p.maxLife;
    ctx.globalAlpha = alpha;
    ctx.fillStyle = p.color;
    if(p.confetti) {
      ctx.save();
      ctx.translate(p.x, p.y);
      ctx.rotate(p.life * 5);
      ctx.fillRect(-p.size/2, -p.size/2, p.size, p.size*0.5);
      ctx.restore();
    } else {
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size*alpha, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.globalAlpha = 1;
  }

  ctx.restore();

  // Apply environmental effects (weather & time of day)
  if (currentWeather || currentTimeOfDay) {
    ctx.save();
    
    // Time of day overlay
    if (currentTimeOfDay === 'sunset') {
      const gradient = ctx.createLinearGradient(0, 0, 0, canvasHeight);
      gradient.addColorStop(0, 'rgba(255,140,0,0.15)');
      gradient.addColorStop(1, 'rgba(255,80,0,0.25)');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, canvasWidth, canvasHeight);
    } else if (currentTimeOfDay === 'night') {
      ctx.fillStyle = 'rgba(0,0,40,0.4)';
      ctx.fillRect(0, 0, canvasWidth, canvasHeight);
    }
    
    // Weather effects
    if (currentWeather === 'rain') {
      ctx.strokeStyle = 'rgba(150,180,255,0.3)';
      ctx.lineWidth = 1;
      for (let i = 0; i < 100; i++) {
        const x = (Math.random() + elapsedTime * 0.5) % 1 * canvasWidth;
        const y = (Math.random() + elapsedTime * 2) % 1 * canvasHeight;
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x - 2, y + 8);
        ctx.stroke();
      }
    } else if (currentWeather === 'snow') {
      ctx.fillStyle = 'rgba(255,255,255,0.7)';
      for (let i = 0; i < 80; i++) {
        const x = (Math.random() + elapsedTime * 0.2) % 1 * canvasWidth;
        const y = (Math.random() + elapsedTime * 0.3) % 1 * canvasHeight;
        ctx.beginPath();
        ctx.arc(x, y, 2, 0, Math.PI * 2);
        ctx.fill();
      }
    } else if (currentWeather === 'fog') {
      const fogGradient = ctx.createRadialGradient(
        canvasWidth / 2, canvasHeight / 2, canvasHeight * 0.2,
        canvasWidth / 2, canvasHeight / 2, canvasHeight * 0.8
      );
      fogGradient.addColorStop(0, 'rgba(200,200,220,0)');
      fogGradient.addColorStop(1, 'rgba(200,200,220,0.4)');
      ctx.fillStyle = fogGradient;
      ctx.fillRect(0, 0, canvasWidth, canvasHeight);
    }
    
    ctx.restore();
  }

  // Draw minimap
  drawMinimap();
  
  // Practice mode watermark
  renderPracticeWatermark();
}

function distToHQ(px, py) {
  return Math.hypot(px - mapData.hqX*TILE-TILE/2, py - mapData.hqY*TILE-TILE/2);
}

// ============================================================
// CHARACTER DRAWING
// ============================================================
function drawCharacterSprite(ctx, x, y, charData, facing, scale, moving, animTimer) {
  scale = scale || 1;
  const s = scale;
  ctx.save();
  ctx.translate(x, y);

  const walkOffset = moving ? Math.sin(animTimer || 0)*2*s : 0;
  const legAnim = moving ? Math.sin((animTimer||0)*2)*3*s : 0;

  // Shadow
  ctx.fillStyle = 'rgba(0,0,0,0.3)';
  ctx.beginPath();
  ctx.ellipse(0, 8*s+walkOffset, 6*s, 2*s, 0, 0, Math.PI*2);
  ctx.fill();

  // Legs
  ctx.fillStyle = '#2a2a3a';
  ctx.fillRect(-4*s, 3*s+walkOffset, 3*s, 6*s+legAnim);
  ctx.fillRect(1*s, 3*s+walkOffset, 3*s, 6*s-legAnim);

  // Body
  ctx.fillStyle = charData.color;
  ctx.fillRect(-5*s, -4*s+walkOffset, 10*s, 8*s);
  // Shirt detail
  ctx.fillStyle = 'rgba(255,255,255,0.15)';
  ctx.fillRect(-1*s, -2*s+walkOffset, 2*s, 5*s);

  // Head
  ctx.fillStyle = '#FFCC99';
  ctx.fillRect(-4*s, -10*s+walkOffset, 8*s, 7*s);

  // Hair
  ctx.fillStyle = charData.hair;
  ctx.fillRect(-4*s, -11*s+walkOffset, 8*s, 3*s);

  // Eyes (change based on facing)
  ctx.fillStyle = '#222';
  if(facing === 3) { // up - show back of head
    ctx.fillStyle = charData.hair;
    ctx.fillRect(-4*s, -10*s+walkOffset, 8*s, 6*s);
  } else if(facing === 1) { // left
    ctx.fillRect(-3*s, -7*s+walkOffset, 2*s, 2*s);
  } else if(facing === 2) { // right
    ctx.fillRect(1*s, -7*s+walkOffset, 2*s, 2*s);
  } else { // down
    ctx.fillRect(-3*s, -7*s+walkOffset, 2*s, 2*s);
    ctx.fillRect(1*s, -7*s+walkOffset, 2*s, 2*s);
    // Mouth
    ctx.fillRect(-1*s, -4*s+walkOffset, 2*s, 1*s);
  }

  ctx.restore();
}

function drawJrod(ctx, x, y) {
  ctx.save();
  ctx.translate(x, y);

  const bob = Math.sin(performance.now()/500)*2;

  // Shadow
  ctx.fillStyle = 'rgba(0,0,0,0.3)';
  ctx.beginPath();
  ctx.ellipse(0, 10, 8, 3, 0, 0, Math.PI*2);
  ctx.fill();

  // Legs
  ctx.fillStyle = '#1a1a3a';
  ctx.fillRect(-5, 4+bob, 4, 7);
  ctx.fillRect(1, 4+bob, 4, 7);

  // Body (suit)
  ctx.fillStyle = '#2a2a5a';
  ctx.fillRect(-7, -5+bob, 14, 10);
  // Tie
  ctx.fillStyle = '#E21A2C';
  ctx.fillRect(-1, -4+bob, 2, 8);

  // Head
  ctx.fillStyle = '#FFCC99';
  ctx.fillRect(-5, -12+bob, 10, 8);
  // Hair
  ctx.fillStyle = '#333';
  ctx.fillRect(-5, -13+bob, 10, 3);
  // Sunglasses (boss energy)
  ctx.fillStyle = '#000';
  ctx.fillRect(-4, -9+bob, 3, 2);
  ctx.fillRect(1, -9+bob, 3, 2);
  ctx.fillRect(-1, -9+bob, 2, 1);

  // Crown/star
  ctx.fillStyle = '#FFD700';
  ctx.beginPath();
  ctx.moveTo(0, -16+bob);
  ctx.lineTo(-3, -13+bob);
  ctx.lineTo(3, -13+bob);
  ctx.closePath();
  ctx.fill();

  ctx.restore();
}

// ============================================================
// MINIMAP
// ============================================================
function drawMinimap() {
  const mw = minimapCanvas.width;
  const mh = minimapCanvas.height;
  const scaleX = mw / (mapData.w * TILE);
  const scaleY = mh / (mapData.h * TILE);
  const sc = Math.min(scaleX, scaleY);

  minimapCtx.fillStyle = 'rgba(0,0,0,0.8)';
  minimapCtx.fillRect(0, 0, mw, mh);

  // Draw tiles (every 2nd for performance)
  for(let y=0; y<mapData.h; y+=2) {
    for(let x=0; x<mapData.w; x+=2) {
      const t = mapData.grid[y][x];
      let color = null;
      switch(t) {
        case 0: color='#3a3a4a'; break;
        case 1: color='#5a5a6a'; break;
        case 2: color='#1a3a10'; break;
        case 3: case 7: color='#4a4a5e'; break;
        case 4: color='#E21A2C'; break;
        case 5: color='#8B4513'; break;
        case 6: color='#4a0e4a'; break;
      }
      if(color) {
        minimapCtx.fillStyle = color;
        minimapCtx.fillRect(x*TILE*sc, y*TILE*sc, TILE*2*sc+1, TILE*2*sc+1);
      }
    }
  }

  // OKR dots
  minimapCtx.fillStyle = '#FFD700';
  for(let o of okrs) {
    if(!o.collected) {
      minimapCtx.fillRect(o.x*sc-1, o.y*sc-1, 3, 3);
    }
  }

  // Enemy dots
  minimapCtx.fillStyle = '#44AA44';
  for(let e of enemies) {
    minimapCtx.fillRect(e.x*sc-1, e.y*sc-1, 3, 3);
  }

  // HQ
  minimapCtx.fillStyle = '#E21A2C';
  minimapCtx.fillRect(mapData.hqX*TILE*sc-2, mapData.hqY*TILE*sc-2, 5, 5);

  // Player
  minimapCtx.fillStyle = '#fff';
  minimapCtx.fillRect(player.x*sc-2, player.y*sc-2, 4, 4);

  // Camera viewport
  minimapCtx.strokeStyle = 'rgba(255,255,255,0.3)';
  minimapCtx.lineWidth = 1;
  minimapCtx.strokeRect(camera.x*sc, camera.y*sc, canvasWidth*sc, canvasHeight*sc);
}

// ============================================================
// TUTORIAL SYSTEM
// ============================================================

const tutorialOverlay = document.getElementById('tutorial-overlay');
const helpMenu = document.getElementById('help-menu');

// Tutorial state in localStorage
const TUTORIAL_STORAGE_KEY = 'teamDominosTutorial';

function getTutorialState() {
  try {
    const data = localStorage.getItem(TUTORIAL_STORAGE_KEY);
    return data ? JSON.parse(data) : {
      completed: false,
      currentStep: 0,
      runsCompleted: 0,
      tooltipsShown: {},
      practiceUnlocked: false
    };
  } catch(e) {
    return {
      completed: false,
      currentStep: 0,
      runsCompleted: 0,
      tooltipsShown: {},
      practiceUnlocked: false
    };
  }
}

function saveTutorialState(state) {
  try {
    localStorage.setItem(TUTORIAL_STORAGE_KEY, JSON.stringify(state));
  } catch(e) {
    console.error('Failed to save tutorial state');
  }
}

let tutorialState = getTutorialState();
let tutorialActive = false;
let currentTutorialStep = 0;
let tutorialArrows = [];
let tutorialHighlights = [];
let activeTooltips = [];
let isPracticeMode = false;

// Tutorial steps
const TUTORIAL_STEPS = [
  {
    title: "Welcome to Team Dominos!",
    text: "Let's learn how to deliver OKRs! First, practice moving around using WASD or Arrow keys.",
    keys: ['W','A','S','D'],
    checkComplete: () => {
      // Complete when player has moved significantly
      return player && (Math.abs(player.x - player.startX) > 100 || Math.abs(player.y - player.startY) > 100);
    },
    onStart: () => {
      if(player) {
        player.startX = player.x;
        player.startY = player.y;
      }
    }
  },
  {
    title: "Pick Up OKRs",
    text: "Great! Now walk over the yellow OKR (üìã) to pick it up. These are the objectives you'll deliver!",
    checkComplete: () => carriedOKRs > 0,
    onStart: () => {
      // Highlight nearest OKR
      if(okrs.length > 0 && player) {
        const nearest = okrs.reduce((closest, okr) => {
          const dist = Math.hypot(okr.x - player.x, okr.y - player.y);
          const closestDist = Math.hypot(closest.x - player.x, closest.y - player.y);
          return dist < closestDist ? okr : closest;
        });
        addTutorialHighlight(nearest.x, nearest.y, 40);
        addTutorialArrow(nearest.x, nearest.y - 60, '‚¨á');
      }
    }
  },
  {
    title: "Deliver to HQ",
    text: "Excellent! Now deliver the OKR to Jrod at the red HQ building (üè¢). Follow the arrow!",
    checkComplete: () => deliveredOKRs > 0,
    onStart: () => {
      if(mapData) {
        const hqX = mapData.hqX * TILE + TILE/2;
        const hqY = mapData.hqY * TILE + TILE/2;
        addTutorialHighlight(hqX, hqY, 60);
      }
    }
  },
  {
    title: "Power-Ups!",
    text: "Nice delivery! Power-ups give you special abilities. Pick up that green power-up to try one!",
    checkComplete: () => Object.keys(activePowerups).length > 0,
    onStart: () => {
      // Spawn a power-up near player
      if(player && powerups.length === 0) {
        powerups.push({
          x: player.x + 150,
          y: player.y + 100,
          type: POWERUP_TYPES[0], // Sprint boost
          angle: 0
        });
      }
      // Highlight power-up
      if(powerups.length > 0) {
        const pu = powerups[0];
        addTutorialHighlight(pu.x, pu.y, 35);
        addTutorialArrow(pu.x, pu.y - 50, '‚¨á');
      }
    }
  },
  {
    title: "Avoid Obstacles",
    text: "Watch out for obstacles! Meetings (‚òï) slow you down, Tech Debt (üíæ) damages you, and Scope Creep (üåø) chases you!",
    checkComplete: () => {
      // Complete after a few seconds
      if(!tutorialStepTimer) tutorialStepTimer = 0;
      tutorialStepTimer += 1/60;
      return tutorialStepTimer > 5;
    },
    onStart: () => {
      tutorialStepTimer = 0;
    }
  },
  {
    title: "Complete Your First Run!",
    text: "You're ready! Deliver OKRs, avoid obstacles, and reach the delivery goal. Good luck!",
    checkComplete: () => gameState === 'levelComplete',
    onStart: () => {
      // Clear tutorial elements
      clearTutorialElements();
    }
  }
];

let tutorialStepTimer = 0;

function startTutorial() {
  tutorialActive = true;
  currentTutorialStep = 0;
  tutorialState.currentStep = 0;
  showTutorialStep(0);
}

function showTutorialStep(stepIndex) {
  if(stepIndex >= TUTORIAL_STEPS.length) {
    completeTutorial();
    return;
  }

  currentTutorialStep = stepIndex;
  const step = TUTORIAL_STEPS[stepIndex];

  // Clear previous elements
  clearTutorialElements();

  // Create tutorial box
  tutorialOverlay.className = 'active';
  tutorialOverlay.innerHTML = `
    <div class="tutorial-box">
      <div class="tutorial-title">${step.title}</div>
      <div class="tutorial-text">${step.text}</div>
      ${step.keys ? `
        <div class="tutorial-keys">
          ${step.keys.map(k => `<div class="tutorial-key">${k}</div>`).join('')}
        </div>
      ` : ''}
      <div class="tutorial-progress">
        ${TUTORIAL_STEPS.map((_, i) => `<div class="tutorial-dot ${i === stepIndex ? 'active' : ''}"></div>`).join('')}
      </div>
    </div>
    ${tutorialState.completed ? `<button class="tutorial-skip-btn" onclick="skipTutorial()">Skip Tutorial</button>` : `<button class="tutorial-skip-btn hidden">Skip Tutorial</button>`}
  `;

  // Run step setup
  if(step.onStart) {
    step.onStart();
  }

  saveTutorialState(tutorialState);
}

function updateTutorial() {
  if(!tutorialActive) return;

  const step = TUTORIAL_STEPS[currentTutorialStep];
  if(step && step.checkComplete && step.checkComplete()) {
    // Move to next step
    setTimeout(() => {
      showTutorialStep(currentTutorialStep + 1);
    }, 500);
  }
}

function completeTutorial() {
  tutorialActive = false;
  tutorialOverlay.className = '';
  clearTutorialElements();
  
  tutorialState.completed = true;
  tutorialState.practiceUnlocked = true;
  saveTutorialState(tutorialState);

  showQuote("Tutorial Complete! You're ready to deliver!");
}

function skipTutorial() {
  if(tutorialState.completed) {
    tutorialActive = false;
    tutorialOverlay.className = '';
    clearTutorialElements();
  }
}

function addTutorialArrow(x, y, symbol) {
  const arrow = document.createElement('div');
  arrow.className = 'tutorial-arrow';
  arrow.textContent = symbol;
  arrow.style.left = '50%';
  arrow.style.top = '50%';
  document.getElementById('ui-overlay').appendChild(arrow);
  tutorialArrows.push({ element: arrow, worldX: x, worldY: y });
}

function addTutorialHighlight(x, y, size) {
  const highlight = document.createElement('div');
  highlight.className = 'tutorial-highlight';
  highlight.style.width = size + 'px';
  highlight.style.height = size + 'px';
  highlight.style.left = '50%';
  highlight.style.top = '50%';
  document.getElementById('ui-overlay').appendChild(highlight);
  tutorialHighlights.push({ element: highlight, worldX: x, worldY: y, size });
}

function updateTutorialElements() {
  if(!player) return;

  // Update arrows
  tutorialArrows.forEach(arrow => {
    const screenX = arrow.worldX - camera.x + canvasWidth/2;
    const screenY = arrow.worldY - camera.y + canvasHeight/2;
    arrow.element.style.left = screenX + 'px';
    arrow.element.style.top = screenY + 'px';
  });

  // Update highlights
  tutorialHighlights.forEach(highlight => {
    const screenX = highlight.worldX - camera.x + canvasWidth/2;
    const screenY = highlight.worldY - camera.y + canvasHeight/2;
    highlight.element.style.left = (screenX - highlight.size/2) + 'px';
    highlight.element.style.top = (screenY - highlight.size/2) + 'px';
  });
}

function clearTutorialElements() {
  tutorialArrows.forEach(arrow => arrow.element.remove());
  tutorialArrows = [];
  tutorialHighlights.forEach(highlight => highlight.element.remove());
  tutorialHighlights = [];
}

// ============================================================
// CONTEXTUAL TOOLTIPS
// ============================================================

function showTooltip(id, title, text, x, y, autoHide = true) {
  // Check if already shown
  if(tutorialState.tooltipsShown[id]) return;
  if(tutorialState.runsCompleted >= 3) return; // Only show for first 3 runs

  const tooltip = document.createElement('div');
  tooltip.className = 'tooltip';
  tooltip.style.left = x + 'px';
  tooltip.style.top = y + 'px';
  tooltip.innerHTML = `
    <div class="tooltip-close" onclick="this.parentElement.remove()">√ó</div>
    <div class="tooltip-title">${title}</div>
    <div class="tooltip-text">${text}</div>
  `;
  
  document.getElementById('ui-overlay').appendChild(tooltip);
  activeTooltips.push(tooltip);

  tutorialState.tooltipsShown[id] = true;
  saveTutorialState(tutorialState);

  if(autoHide) {
    setTimeout(() => {
      tooltip.remove();
      activeTooltips = activeTooltips.filter(t => t !== tooltip);
    }, 5000);
  }
}

function showCharacterTooltip(character) {
  if(!tutorialState.tooltipsShown['char_' + character.id]) {
    showTooltip(
      'char_' + character.id,
      character.name,
      `Speed: ${character.speed}/5, Capacity: ${character.capacity}/5. ${character.desc}`,
      canvasWidth / 2 - 140,
      100
    );
  }
}

function showPowerupTooltip(powerupType) {
  if(!tutorialState.tooltipsShown['powerup_' + powerupType.id]) {
    showTooltip(
      'powerup_' + powerupType.id,
      powerupType.name,
      `${powerupType.desc} - Lasts ${powerupType.duration}s`,
      canvasWidth / 2 - 140,
      150
    );
  }
}

function showMapTooltip(mapType) {
  if(!tutorialState.tooltipsShown['map_' + mapType]) {
    const mapInfo = {
      city: "City Map - Dense buildings, tight streets. Good for quick deliveries!",
      suburbs: "Suburbs - Open spaces, longer distances. Plan your route!",
      downtown: "Downtown - Complex layout with many shortcuts."
    };
    showTooltip(
      'map_' + mapType,
      "New Map!",
      mapInfo[mapType] || "Explore this new area!",
      canvasWidth / 2 - 140,
      100
    );
  }
}

function showComboTooltip() {
  if(!tutorialState.tooltipsShown['combo']) {
    showTooltip(
      'combo',
      "Combo System!",
      "Deliver multiple OKRs quickly to build a combo multiplier and earn bonus tokens!",
      canvasWidth / 2 - 140,
      200
    );
  }
}

// ============================================================
// PRACTICE MODE
// ============================================================

function startPracticeMode() {
  isPracticeMode = true;
  playerName = 'Practice Player';
  startGame();
}

function renderPracticeWatermark() {
  if(isPracticeMode) {
    ctx.save();
    ctx.globalAlpha = 0.15;
    ctx.font = 'bold 72px "Courier New"';
    ctx.fillStyle = '#FFD700';
    ctx.textAlign = 'center';
    ctx.translate(canvasWidth/2, canvasHeight/2);
    ctx.rotate(-Math.PI / 6);
    ctx.fillText('PRACTICE MODE', 0, 0);
    ctx.restore();
  }
}

// ============================================================
// HELP MENU
// ============================================================

function showHelpMenu() {
  helpMenu.className = 'active';
  helpMenu.innerHTML = `
    <button class="help-close-btn" onclick="hideHelpMenu()">Close</button>
    <div class="help-container">
      <div class="help-header">
        <div class="help-title">üìñ How to Play</div>
      </div>

      <div class="help-section">
        <div class="help-section-title">üéÆ Controls</div>
        <div class="help-content">
          <div class="help-controls-grid">
            <div class="help-key">W A S D</div>
            <div class="help-key-desc">Move Player 1</div>
            <div class="help-key">Arrow Keys</div>
            <div class="help-key-desc">Move Player 2 (Multiplayer)</div>
            <div class="help-key">T F G H</div>
            <div class="help-key-desc">Move Player 3 (Multiplayer)</div>
            <div class="help-key">I J K L</div>
            <div class="help-key-desc">Move Player 4 (Multiplayer)</div>
            <div class="help-key">ESC</div>
            <div class="help-key-desc">Pause Game / Open Menu</div>
          </div>
        </div>
      </div>

      <div class="help-section">
        <div class="help-section-title">üéØ How to Play</div>
        <div class="help-content">
          <p>1. <strong>Pick up OKRs (üìã)</strong> - Walk over yellow OKR markers to collect them</p>
          <p>2. <strong>Deliver to HQ (üè¢)</strong> - Bring OKRs to Jrod's red headquarters building</p>
          <p>3. <strong>Avoid Obstacles</strong> - Navigate around meetings, tech debt, and scope creep</p>
          <p>4. <strong>Collect Power-Ups</strong> - Green items give you temporary abilities</p>
          <p>5. <strong>Manage Tokens</strong> - Keep your token balance positive to stay in the game</p>
          <p>6. <strong>Complete Deliveries</strong> - Reach the delivery goal to advance to the next level</p>
        </div>
      </div>

      <div class="help-section">
        <div class="help-section-title">‚ö° Power-Ups Guide</div>
        <div class="help-grid">
          ${POWERUP_TYPES.map(pu => `
            <div class="help-item">
              <div class="help-item-icon" style="color:${pu.color}">${pu.icon}</div>
              <div class="help-item-title">${pu.name}</div>
              <div class="help-item-desc">${pu.desc} (${pu.duration}s)</div>
            </div>
          `).join('')}
        </div>
      </div>

      <div class="help-section">
        <div class="help-section-title">üë• Characters</div>
        <div class="help-grid">
          ${CHARACTERS.map(char => `
            <div class="help-item">
              <div class="help-item-icon">${char.name.charAt(0)}</div>
              <div class="help-item-title" style="color:${char.color}">${char.name}</div>
              <div class="help-item-desc">${char.desc}</div>
              <div class="help-item-desc">Speed: ${char.speed}/5 | Capacity: ${char.capacity}/5</div>
            </div>
          `).join('')}
        </div>
      </div>

      <div class="help-section">
        <div class="help-section-title">üí° Tips & Strategies</div>
        <div class="help-content">
          <p>‚Ä¢ <strong>Fast characters</strong> are great for speed runs but carry fewer OKRs</p>
          <p>‚Ä¢ <strong>High capacity characters</strong> can collect multiple OKRs per trip</p>
          <p>‚Ä¢ <strong>Plan your route</strong> - collect multiple OKRs before returning to HQ</p>
          <p>‚Ä¢ <strong>Conserve tokens</strong> - avoid unnecessary movement when carrying OKRs</p>
          <p>‚Ä¢ <strong>Stack power-ups</strong> - combine compatible power-ups for maximum effect</p>
          <p>‚Ä¢ <strong>Watch for scope creep</strong> - these enemies track your movement!</p>
          <p>‚Ä¢ <strong>Use the minimap</strong> - plan efficient routes to OKRs and HQ</p>
          <p>‚Ä¢ <strong>Build combos</strong> - deliver OKRs quickly for bonus multipliers</p>
        </div>
      </div>

      <div class="help-section">
        <div class="help-section-title">üéì Tutorial Options</div>
        <div class="help-content">
          <button class="menu-btn" onclick="replayTutorial()">Replay Tutorial</button>
          ${tutorialState.practiceUnlocked ? '<button class="menu-btn secondary" onclick="hideHelpMenu();showPracticeMode()">Practice Mode</button>' : ''}
        </div>
      </div>
    </div>
  `;
}

function hideHelpMenu() {
  helpMenu.className = '';
}

function replayTutorial() {
  hideHelpMenu();
  if(gameState === 'playing') {
    // End current game
    gameState = 'title';
    showTitle();
  }
  // Start new game with tutorial
  tutorialState.completed = false;
  tutorialState.currentStep = 0;
  saveTutorialState(tutorialState);
  
  selectedChar = CHARACTERS[2]; // Agile Alex
  playerName = 'Tutorial Player';
  gameMode = 1;
  
  setTimeout(() => {
    startGame();
    startTutorial();
  }, 500);
}

function showPracticeMode() {
  gameState = 'charSelect';
  overlay.innerHTML = `
    <button class="back-btn" onclick="showTitle()">< Back</button>
    <div style="text-align:center;">
      <div style="font-size:28px;font-weight:bold;margin-bottom:8px;color:#FFD700;">üéì Practice Mode</div>
      <div style="color:#aaa;font-size:14px;margin-bottom:16px;">Safe environment ‚Ä¢ No token penalty ‚Ä¢ Unlimited lives</div>
      <div class="char-grid" id="char-grid"></div>
      <button class="menu-btn" id="practice-start-btn" style="opacity:0.5;pointer-events:none;" onclick="startPracticeMode()">START PRACTICE</button>
    </div>
  `;

  const grid = document.getElementById('char-grid');
  CHARACTERS.forEach((c, i) => {
    const card = document.createElement('div');
    card.className = 'char-card';
    card.innerHTML = `
      <canvas width="48" height="48" id="char-preview-${i}" style="margin:0 auto;display:block;image-rendering:pixelated;"></canvas>
      <div class="char-name" style="color:${c.color}">${c.name}</div>
      <div class="char-desc">${c.desc}</div>
      <div class="char-stat">
        <span>Speed</span>
        <div class="stat-bar"><div class="stat-fill speed" style="width:${c.speed*20}%"></div></div>
      </div>
      <div class="char-stat">
        <span>Capacity</span>
        <div class="stat-bar"><div class="stat-fill capacity" style="width:${c.capacity*20}%"></div></div>
      </div>
    `;
    card.addEventListener('click', () => {
      document.querySelectorAll('.char-card').forEach(cc => cc.classList.remove('selected'));
      card.classList.add('selected');
      selectedChar = c;
      document.getElementById('practice-start-btn').style.opacity='1';
      document.getElementById('practice-start-btn').style.pointerEvents='auto';
    });
    grid.appendChild(card);

    setTimeout(() => {
      const pc = document.getElementById(`char-preview-${i}`);
      if(pc) {
        const pctx = pc.getContext('2d');
        drawCharacterSprite(pctx, 24, 24, c, 0, 1.5);
      }
    }, 0);
  });
}

// ============================================================
// PROGRESSIVE DISCLOSURE
// ============================================================

function checkProgressiveDisclosure() {
  const runs = tutorialState.runsCompleted;
  
  // Show tooltips based on run count
  if(runs === 0) {
    // First run - basics only (handled by tutorial)
  } else if(runs === 1) {
    // Second run - introduce power-ups
    if(Object.keys(activePowerups).length > 0 && !tutorialState.tooltipsShown['powerup_intro']) {
      showTooltip('powerup_intro', 'Power-Ups!', 'Collect power-ups for special abilities. Try different combinations!', canvasWidth/2-140, 150);
    }
  } else if(runs === 2) {
    // Third run - character selection
    if(!tutorialState.tooltipsShown['char_intro']) {
      showTooltip('char_intro', 'Try Different Characters!', 'Each character has unique speed and capacity stats. Experiment to find your favorite!', canvasWidth/2-140, 150);
    }
  } else if(runs === 3) {
    // Fourth run - advanced strategies
    if(!tutorialState.tooltipsShown['strategy_intro']) {
      showTooltip('strategy_intro', 'Advanced Tips', 'Plan routes, stack power-ups, and build combos for maximum efficiency!', canvasWidth/2-140, 150);
    }
  }
}

// ============================================================
// GAME LOOP
// ============================================================
let frameCount = 0;
let fpsInterval = 1000 / 60;
let fpsLastTime = 0;

function gameLoop(timestamp) {
  if(!lastTime) lastTime = timestamp;
  
  // FPS limiting based on quality settings
  const targetFPS = QualitySettings.getProfile().targetFPS;
  fpsInterval = 1000 / targetFPS;
  
  const elapsed = timestamp - fpsLastTime;
  if (elapsed < fpsInterval) {
    requestAnimationFrame(gameLoop);
    return;
  }
  
  fpsLastTime = timestamp - (elapsed % fpsInterval);
  
  let dt = (timestamp - lastTime) / 1000;
  lastTime = timestamp;
  if(dt > 0.1) dt = 0.1; // cap delta

  if(gameRunning) {
    update(dt);
    MemoryManager.cleanup();
  }
  render();
  
  // Performance monitoring
  PerformanceMonitor.update();
  frameCount++;
  
  requestAnimationFrame(gameLoop);
}

// ============================================================
// INIT
// ============================================================
showTitle();
GestureHandler.init();
requestAnimationFrame(gameLoop);

</script>
</body>
</html>
 30 seconds if not installed
  setTimeout(() => {
    if (deferredPrompt && !window.matchMedia('(display-mode: standalone)').matches) {
      const installMsg = confirm('Install Team Dominos for a better experience?');
      if (installMsg) {
        deferredPrompt.prompt();
        deferredPrompt.userChoice.then((choiceResult) => {
          if (choiceResult.outcome === 'accepted') {
            console.log('User accepted the install prompt');
          }
          deferredPrompt = null;
        });
      }
    }
  }, 30000);
});

showTitle();
GestureHandler.init();
requestAnimationFrame(gameLoop);

</script>
</body>
</html>
          if (choiceResult.outcome === 'accepted') {
            console.log('User accepted the install prompt');
          }
          deferredPrompt = null;
        });
      }
    }
  }, 30000);
});

showTitle();
GestureHandler.init();
requestAnimationFrame(gameLoop);

</script>
</body>
</html>
